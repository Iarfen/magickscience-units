\chapter{TOPOLOGY}
\hypertarget{md_HISTORY}{}\label{md_HISTORY}\index{TOPOLOGY@{TOPOLOGY}}
\label{md_HISTORY_autotoc_md0}%
\Hypertarget{md_HISTORY_autotoc_md0}%
The topology class has been very easy to create and to use. Besides his utility, it has a very simple design and hasn\textquotesingle{}t been a problem to be created. The two classes it contains, point\+\_\+2d and point\+\_\+3d, have been added to msci\+\_\+units, instead of msci\+\_\+geometry, because of his utility and operation with the coordinates classes. Without them here, it\textquotesingle{}s needed to cross-\/link with the library msci\+\_\+geometry, which was making building harder.\hypertarget{md_HISTORY_autotoc_md1}{}\doxysection{\texorpdfstring{COORDINATES}{COORDINATES}}\label{md_HISTORY_autotoc_md1}
The first version of the coordinates was with one coordinates class for each system of coordinates, all inheriting from an abstract coordinate class of the same dimensions. Following that logic, the abstract coordinates classes were coordinates\+\_\+1d, coordinates\+\_\+2d and coordinates\+\_\+3d. The inheriting coordinates classes were then cartesian\+\_\+coordinates\+\_\+2d, polar\+\_\+coordinates, cartesian\+\_\+coordinates\+\_\+3d, cylindrical\+\_\+coordinates, spherical\+\_\+coordinates. The coordinate classes were storing the data with the variables x, y, z, p, r, theta and phi. All the functions to calculate any coordinate variable of one system from another system were available.

Also, there was a hyper\+\_\+spherical\+\_\+coordinates class, which was handling the sci-\/fi ideas related to spacetimes of more than 3 dimensions of space.

The coordinate classes were allowing to store the coordinate data in one of the coordinates objects, but it was not possible to change the coordinates class. Instead, the coordinates class was permanent in that sense, and the only way to change it was changing it inside the definition of the class the coordinates class was belonging. In order to correct that, the second version of coordinates was created. It was providing a single coordinates class, without any abstract inheritance, that was storing the data of coordinates in cartesian coordinates, but was able to read and write the coordinates converted to any other coordinates system. So, it behaves like one system or another at the same time, by storing the coordinates data only one time, no multiple times.\hypertarget{md_HISTORY_autotoc_md2}{}\doxysection{\texorpdfstring{MECA\+\_\+\+NUMBERS}{MECA\_NUMBERS}}\label{md_HISTORY_autotoc_md2}
The meca numbers have been maybe the most creative part of this library. They have had some improvements in their design and in their implementation, but they\textquotesingle{}ve remained relatively constant in their idea over time, and to they haven\textquotesingle{}t changed a big amount over the history. Their central idea has, instead, been fixed.

Besides that, they\textquotesingle{}ve been a very hard implementation. The most important class has been angle\+\_\+number, at the present called simply angle. This class has not presented any problem in their implementation, it has been easy besides his big utility, but the other classes doesn\textquotesingle{}t have that history. The safe\+\_\+number class has been one of the hardest, as the class lab\+\_\+number. Both of those classes have been hard to implement with unit classes, because they were requiring, for that purpose, to convert the class scalar\+\_\+unit to a template class, instead of been a normal class. That extra amount of complexity was meaning that safe\+\_\+number and lab\+\_\+number were not really useful classes. Then, safe\+\_\+number has been removed from the library, and lab\+\_\+number has been converted to a template class, that instead of, as previously, being composed inside a scalar\+\_\+unit object, now holds scalar\+\_\+units as value and as error\+\_\+value, and then it works with an easy to use API.\hypertarget{md_HISTORY_autotoc_md3}{}\doxysection{\texorpdfstring{UNITS}{UNITS}}\label{md_HISTORY_autotoc_md3}
The unit classes have been hard to create, and have been a good challenge. Their first implementation was functionally perfect, they work good to allow to work with units instead of with numbers, as was their purpose. The implementation was with an abstract scalar\+\_\+unit class and their derived unit classes, like mass, length and force, that were fixed in dimensions, allowing only to change their prefix. Besides that, there was the auto\+\_\+unit class to allow to have a unit with any dimension needed. Apart from the scalar\+\_\+units, there was the vector\+\_\+unit class, and their derived vectorial unit classes, like force and velocity. In order to allow to have a vector\+\_\+unit with any dimension, the class auto\+\_\+vector was available. Needed for the implementation, there were the scalar\+\_\+unit\+\_\+crtp$<$$>$ and vector\+\_\+unit\+\_\+crtp$<$$>$ classes.

The problem with that first version of the units library was his complexity. The classes auto\+\_\+unit and auto\+\_\+vector were adding too much complexity. Also, the implementation wasn\textquotesingle{}t as simple enough in order to allow for a compilation enoughly simple and close to the use of float as possible. That was very important, because to have an implementation that was producing machine code close to the code produced when working with float was meaning that the implementation was as perfect as possible, because it\textquotesingle{}s not possible to have a unit class more simple than the central primitive type it uses.

Then, the second version of the units library was created, which was simplifying the complexities of the first, making a simpler implementation that was allowing a simpler compilation. For that purpose, scalar\+\_\+unit was changed to be a normal class, instead of an abstract class, and vector\+\_\+unit has losed his multiple inheritance with coordinates classes. Additional to that, vector\+\_\+unit has been divided in vector\+\_\+unit\+\_\+1d, vector\+\_\+unit\+\_\+2d, vector\+\_\+unit\+\_\+3d and vector\+\_\+unit\+\_\+nd classes. This division was allowing to have a better protection against an incorrect use of dimensions, and was saving RAM because of storing less variables for the cases were was not needed to store more variables related to dimensions, which were msci\+::angle classes. 