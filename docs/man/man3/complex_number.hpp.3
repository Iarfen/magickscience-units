.TH "meca_number/complex_number.hpp" 3 "Version 2.0.0" "scifir-units" \" -*- nroff -*-
.ad l
.nh
.SH NAME
meca_number/complex_number.hpp
.SH SYNOPSIS
.br
.PP
\fC#include '\&.\&./meca_number/angle\&.hpp'\fP
.br
\fC#include '\&.\&./util/is_number\&.hpp'\fP
.br
\fC#include '\&.\&./units/scalar_unit\&.hpp'\fP
.br
\fC#include '\&.\&./util/types\&.hpp'\fP
.br
\fC#include 'boost/algorithm/string\&.hpp'\fP
.br
\fC#include <cmath>\fP
.br
\fC#include <string>\fP
.br

.SS "Classes"

.in +1c
.ti -1c
.RI "class \fBscifir::complex_number< T >\fP"
.br
.in -1c
.SS "Namespaces"

.in +1c
.ti -1c
.RI "namespace \fBscifir\fP"
.br
.RI "The namespace scifir contains all scifir-units, excepting the string literals, which are outside\&. "
.in -1c
.SS "Functions"

.in +1c
.ti -1c
.RI "template<\fBtypename\fP T > \fBstring\fP \fBscifir::to_string\fP (\fBconst\fP \fBcomplex_number\fP< T > &x)"
.br
.ti -1c
.RI "\fBbool\fP \fBscifir::is_complex\fP (\fBconst\fP \fBstring\fP &\fBinit_complex_number\fP)"
.br
.ti -1c
.RI "template<\fBtypename\fP T > T \fBscifir::abs\fP (\fBconst\fP \fBcomplex_number\fP< T > &x)"
.br
.ti -1c
.RI "template<\fBtypename\fP T > \fBcomplex_number\fP< \fBscalar_unit\fP > \fBscifir::sqrt\fP (\fBconst\fP \fBcomplex_number\fP< T > &x)"
.br
.ti -1c
.RI "template<typename T , typename U > bool \fBoperator==\fP (const \fBscifir::complex_number\fP< T > &x, const \fBscifir::complex_number\fP< U > &y)"
.br
.ti -1c
.RI "template<typename T , typename U > bool \fBoperator!=\fP (const \fBscifir::complex_number\fP< T > &x, const \fBscifir::complex_number\fP< U > &y)"
.br
.ti -1c
.RI "template<typename T > bool \fBoperator==\fP (const \fBscifir::complex_number\fP< T > &x, const string &init_complex_number)"
.br
.ti -1c
.RI "template<typename T > bool \fBoperator!=\fP (const \fBscifir::complex_number\fP< T > &x, const string &init_complex_number)"
.br
.ti -1c
.RI "template<typename T > bool \fBoperator==\fP (const string &init_complex_number, const \fBscifir::complex_number\fP< T > &x)"
.br
.ti -1c
.RI "template<typename T > bool \fBoperator!=\fP (const string &init_complex_number, const \fBscifir::complex_number\fP< T > &x)"
.br
.ti -1c
.RI "template<typename T > void \fBoperator+=\fP (string &x, const \fBscifir::complex_number\fP< T > &y)"
.br
.ti -1c
.RI "template<typename T > string \fBoperator+\fP (const string &x, const \fBscifir::complex_number\fP< T > &y)"
.br
.ti -1c
.RI "template<typename T > string \fBoperator+\fP (const \fBscifir::complex_number\fP< T > &x, const string &y)"
.br
.ti -1c
.RI "template<typename T > ostream & \fBoperator<<\fP (ostream &os, const \fBscifir::complex_number\fP< T > &x)"
.br
.ti -1c
.RI "template<typename T > istream & \fBoperator>>\fP (istream &is, \fBscifir::complex_number\fP< T > &x)"
.br
.in -1c
.SH "Function Documentation"
.PP 
.SS "template<typename T , typename U > bool operator!= (const \fBscifir::complex_number\fP< T > & x, const \fBscifir::complex_number\fP< U > & y)"

.PP
Definition at line \fB229\fP of file \fBcomplex_number\&.hpp\fP\&..PP
.nf
230 {
231     return !(x == y);
232 }
.fi

.SS "template<typename T > bool operator!= (const \fBscifir::complex_number\fP< T > & x, const string & init_complex_number)"

.PP
Definition at line \fB241\fP of file \fBcomplex_number\&.hpp\fP\&..PP
.nf
242 {
243     return !(x == init_complex_number);
244 }
.fi

.SS "template<typename T > bool operator!= (const string & init_complex_number, const \fBscifir::complex_number\fP< T > & x)"

.PP
Definition at line \fB253\fP of file \fBcomplex_number\&.hpp\fP\&..PP
.nf
254 {
255     return !(init_complex_number == x);
256 }
.fi

.SS "template<typename T > string operator+ (const \fBscifir::complex_number\fP< T > & x, const string & y)"

.PP
Definition at line \fB271\fP of file \fBcomplex_number\&.hpp\fP\&..PP
.nf
272 {
273     return to_string(x) + y;
274 }
.fi

.SS "template<typename T > string operator+ (const string & x, const \fBscifir::complex_number\fP< T > & y)"

.PP
Definition at line \fB265\fP of file \fBcomplex_number\&.hpp\fP\&..PP
.nf
266 {
267     return x + to_string(y);
268 }
.fi

.SS "template<typename T > void operator+= (string & x, const \fBscifir::complex_number\fP< T > & y)"

.PP
Definition at line \fB259\fP of file \fBcomplex_number\&.hpp\fP\&..PP
.nf
260 {
261     x += to_string(y);
262 }
.fi

.SS "template<typename T > ostream & operator<< (ostream & os, const \fBscifir::complex_number\fP< T > & x)"

.PP
Definition at line \fB277\fP of file \fBcomplex_number\&.hpp\fP\&..PP
.nf
278 {
279     return os << to_string(x);
280 }
.fi

.SS "template<typename T , typename U > bool operator== (const \fBscifir::complex_number\fP< T > & x, const \fBscifir::complex_number\fP< U > & y)"

.PP
Definition at line \fB216\fP of file \fBcomplex_number\&.hpp\fP\&..PP
.nf
217 {
218     if (x\&.real == y\&.real and x\&.imaginary == y\&.imaginary)
219     {
220         return true;
221     }
222     else
223     {
224         return false;
225     }
226 }
.fi

.SS "template<typename T > bool operator== (const \fBscifir::complex_number\fP< T > & x, const string & init_complex_number)"

.PP
Definition at line \fB235\fP of file \fBcomplex_number\&.hpp\fP\&..PP
.nf
236 {
237     return (x == scifir::complex_number<T>(init_complex_number));
238 }
.fi

.SS "template<typename T > bool operator== (const string & init_complex_number, const \fBscifir::complex_number\fP< T > & x)"

.PP
Definition at line \fB247\fP of file \fBcomplex_number\&.hpp\fP\&..PP
.nf
248 {
249     return (scifir::complex_number<T>(init_complex_number) == x);
250 }
.fi

.SS "template<typename T > istream & operator>> (istream & is, \fBscifir::complex_number\fP< T > & x)"

.PP
Definition at line \fB283\fP of file \fBcomplex_number\&.hpp\fP\&..PP
.nf
284 {
285     char a[256];
286     is\&.getline(a, 256);
287     string b(a);
288     x = scifir::complex_number<T>(b);
289     return is;
290 }
.fi

.SH "Author"
.PP 
Generated automatically by Doxygen for scifir-units from the source code\&.
