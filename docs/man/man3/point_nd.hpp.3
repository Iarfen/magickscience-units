.TH "topology/point_nd.hpp" 3 "Sat Jul 13 2024" "Version 2.0.0" "scifir-units" \" -*- nroff -*-
.ad l
.nh
.SH NAME
topology/point_nd.hpp
.SH SYNOPSIS
.br
.PP
\fC#include '\&.\&./predefined_units/physics_units\&.hpp'\fP
.br
\fC#include '\&.\&./units/unit_basic\&.hpp'\fP
.br
\fC#include '\&.\&./util/types\&.hpp'\fP
.br
\fC#include <iostream>\fP
.br
\fC#include <string>\fP
.br
\fC#include <vector>\fP
.br

.SS "Classes"

.in +1c
.ti -1c
.RI "class \fBscifir::point_nd< T >\fP"
.br
.ti -1c
.RI "class \fBscifir::point_nd< float >\fP"
.br
.in -1c
.SS "Namespaces"

.in +1c
.ti -1c
.RI " \fBscifir\fP"
.br
.RI "The namespace scifir contains all scifir-units, excepting the string literals, which are outside\&. "
.in -1c
.SS "Functions"

.in +1c
.ti -1c
.RI "template<typename T > string \fBscifir::to_string\fP (const point_nd< T > &x)"
.br
.ti -1c
.RI "string \fBscifir::to_string\fP (const point_nd< float > &x)"
.br
.ti -1c
.RI "template<typename T , typename U > T \fBscifir::distance\fP (const point_nd< T > &x1, const point_nd< U > &x2)"
.br
.ti -1c
.RI "float \fBscifir::distance\fP (const point_nd< float > &x, const point_nd< float > &y)"
.br
.ti -1c
.RI "template<typename T , typename U > bool \fBoperator==\fP (const \fBscifir::point_nd\fP< T > &x, const \fBscifir::point_nd\fP< U > &y)"
.br
.ti -1c
.RI "template<typename T , typename U > bool \fBoperator!=\fP (const \fBscifir::point_nd\fP< T > &x, const \fBscifir::point_nd\fP< U > &y)"
.br
.ti -1c
.RI "template<typename T > bool \fBoperator==\fP (const \fBscifir::point_nd\fP< T > &x, const string &init_point_nd)"
.br
.ti -1c
.RI "template<typename T > bool \fBoperator!=\fP (const \fBscifir::point_nd\fP< T > &x, const string &init_point_nd)"
.br
.ti -1c
.RI "template<typename T > bool \fBoperator==\fP (const string &init_point_nd, const \fBscifir::point_nd\fP< T > &x)"
.br
.ti -1c
.RI "template<typename T > bool \fBoperator!=\fP (const string &init_point_nd, const \fBscifir::point_nd\fP< T > &x)"
.br
.ti -1c
.RI "template<typename T > void \fBoperator+=\fP (string &x, const \fBscifir::point_nd\fP< T > &y)"
.br
.ti -1c
.RI "template<typename T > string \fBoperator+\fP (const string &x, const \fBscifir::point_nd\fP< T > &y)"
.br
.ti -1c
.RI "template<typename T > string \fBoperator+\fP (const \fBscifir::point_nd\fP< T > &x, const string &y)"
.br
.ti -1c
.RI "template<typename T > ostream & \fBoperator<<\fP (ostream &os, const \fBscifir::point_nd\fP< T > &x)"
.br
.ti -1c
.RI "ostream & \fBoperator<<\fP (ostream &os, const \fBscifir::point_nd\fP< float > &x)"
.br
.ti -1c
.RI "template<typename T > istream & \fBoperator>>\fP (istream &is, \fBscifir::point_nd\fP< T > &x)"
.br
.in -1c
.SH "Function Documentation"
.PP 
.SS "template<typename T , typename U > bool operator!= (const \fBscifir::point_nd\fP< T > & x, const \fBscifir::point_nd\fP< U > & y)"

.PP
Definition at line 1106 of file point_nd\&.hpp\&.
.PP
.nf
1107 {
1108     return !(x == y);
1109 }
.fi
.SS "template<typename T > bool operator!= (const \fBscifir::point_nd\fP< T > & x, const string & init_point_nd)"

.PP
Definition at line 1119 of file point_nd\&.hpp\&.
.PP
.nf
1120 {
1121     return !(x == init_point_nd);
1122 }
.fi
.SS "template<typename T > bool operator!= (const string & init_point_nd, const \fBscifir::point_nd\fP< T > & x)"

.PP
Definition at line 1132 of file point_nd\&.hpp\&.
.PP
.nf
1133 {
1134     return !(init_point_nd == x);
1135 }
.fi
.SS "template<typename T > string operator+ (const \fBscifir::point_nd\fP< T > & x, const string & y)"

.PP
Definition at line 1150 of file point_nd\&.hpp\&.
.PP
.nf
1151 {
1152     return to_string(x) + y;
1153 }
.fi
.SS "template<typename T > string operator+ (const string & x, const \fBscifir::point_nd\fP< T > & y)"

.PP
Definition at line 1144 of file point_nd\&.hpp\&.
.PP
.nf
1145 {
1146     return x + to_string(y);
1147 }
.fi
.SS "template<typename T > void operator+= (string & x, const \fBscifir::point_nd\fP< T > & y)"

.PP
Definition at line 1138 of file point_nd\&.hpp\&.
.PP
.nf
1139 {
1140     x += to_string(y);
1141 }
.fi
.SS "ostream& operator<< (ostream & os, const \fBscifir::point_nd\fP< float > & x)"

.PP
Definition at line 69 of file point_nd\&.cpp\&.
.PP
.nf
70 {
71     return os << scifir::to_string(x);
72 }
.fi
.SS "template<typename T > ostream& operator<< (ostream & os, const \fBscifir::point_nd\fP< T > & x)"

.PP
Definition at line 1156 of file point_nd\&.hpp\&.
.PP
.nf
1157 {
1158     return os << to_string(x);
1159 }
.fi
.SS "template<typename T , typename U > bool operator== (const \fBscifir::point_nd\fP< T > & x, const \fBscifir::point_nd\fP< U > & y)"

.PP
Definition at line 1093 of file point_nd\&.hpp\&.
.PP
.nf
1094 {
1095     for (int i = 0; i < x\&.values\&.size(); i++)
1096     {
1097         if (x\&.values[i] != y\&.values[i])
1098         {
1099             return false;
1100         }
1101     }
1102     return true;
1103 }
.fi
.SS "template<typename T > bool operator== (const \fBscifir::point_nd\fP< T > & x, const string & init_point_nd)"

.PP
Definition at line 1112 of file point_nd\&.hpp\&.
.PP
.nf
1113 {
1114     scifir::point_nd<T> y(init_point_nd);
1115     return (x == y);
1116 }
.fi
.SS "template<typename T > bool operator== (const string & init_point_nd, const \fBscifir::point_nd\fP< T > & x)"

.PP
Definition at line 1125 of file point_nd\&.hpp\&.
.PP
.nf
1126 {
1127     scifir::point_nd<T> y(init_point_nd);
1128     return (x == y);
1129 }
.fi
.SS "template<typename T > istream& operator>> (istream & is, \fBscifir::point_nd\fP< T > & x)"

.PP
Definition at line 1164 of file point_nd\&.hpp\&.
.PP
.nf
1165 {
1166     char a[256];
1167     is\&.getline(a, 256);
1168     string b(a);
1169     boost::trim(b);
1170     x = scifir::point_nd<T>(b);
1171     return is;
1172 }
.fi
.SH "Author"
.PP 
Generated automatically by Doxygen for scifir-units from the source code\&.
