.TH "units/scalar_unit.hpp" 3 "Sat Jul 13 2024" "Version 2.0.0" "scifir-units" \" -*- nroff -*-
.ad l
.nh
.SH NAME
units/scalar_unit.hpp
.SH SYNOPSIS
.br
.PP
\fC#include '\&.\&./units/dimension\&.hpp'\fP
.br
\fC#include '\&.\&./units/prefix\&.hpp'\fP
.br
\fC#include '\&.\&./util/is_number\&.hpp'\fP
.br
\fC#include <cmath>\fP
.br
\fC#include <map>\fP
.br
\fC#include <string>\fP
.br
\fC#include <iostream>\fP
.br
\fC#include <sstream>\fP
.br
\fC#include <string_view>\fP
.br
\fC#include <vector>\fP
.br

.SS "Classes"

.in +1c
.ti -1c
.RI "class \fBscifir::scalar_unit\fP"
.br
.RI "Class that allows to create scalar units, which are cmoposed of a value (as a float) and dimensions\&. The dimensions can be of any number, and be basic dimensions and/or abbreviations of dimensions\&. "
.in -1c
.SS "Namespaces"

.in +1c
.ti -1c
.RI " \fBscifir\fP"
.br
.RI "The namespace scifir contains all scifir-units, excepting the string literals, which are outside\&. "
.in -1c
.SS "Macros"

.in +1c
.ti -1c
.RI "#define \fBSCALAR_UNIT_HPP_BEGIN\fP(name)"
.br
.ti -1c
.RI "#define \fBSCALAR_UNIT_HPP_END\fP()"
.br
.ti -1c
.RI "#define \fBSCALAR_UNIT_HPP\fP(name)"
.br
.ti -1c
.RI "#define \fBSCALAR_UNIT_CPP\fP(name,  init_dimensions)"
.br
.in -1c
.SS "Functions"

.in +1c
.ti -1c
.RI "string \fBscifir::to_string\fP (const scalar_unit &x)"
.br
.RI "Generates an string representation of the \fBscalar_unit\fP, it uses the display of the \fBscalar_unit\fP with 2 decimals, without brackets and without a close prefix\&. "
.ti -1c
.RI "bool \fBscifir::is_scalar_unit\fP (const string &init_scalar)"
.br
.RI "Checks if an string is an initialization string of a \fBscalar_unit\fP\&. "
.ti -1c
.RI "float \fBscifir::abs\fP (const scalar_unit &x)"
.br
.RI "Returns the absolute value of the \fBscalar_unit\fP, without dimensions\&. "
.ti -1c
.RI "scalar_unit \fBscifir::pow\fP (const scalar_unit &x, int exponent)"
.br
.RI "Exponentiates a \fBscalar_unit\fP to some numeric type, the dimensions are also exponentiated\&. "
.ti -1c
.RI "scalar_unit \fBscifir::sqrt\fP (const scalar_unit &x)"
.br
.RI "Square root of a \fBscalar_unit\fP, it squares the dimensions too\&. "
.ti -1c
.RI "scalar_unit \fBscifir::sqrt_nth\fP (const scalar_unit &x, int index)"
.br
.RI "Nth root of a \fBscalar_unit\fP to any numeric value, it squares the dimensions too\&. "
.ti -1c
.RI "template<typename T , typename  = typename enable_if<scifir::is_number<T>::value>::type> \fBscifir::scalar_unit\fP \fBoperator+\fP (const T &y, const \fBscifir::scalar_unit\fP &x)"
.br
.RI "Sums a numeric type y with an scalar_unit x, returns that result as a new scalar_unit with the same dimensions of x\&. "
.ti -1c
.RI "template<typename T , typename  = typename enable_if<scifir::is_number<T>::value>::type> \fBscifir::scalar_unit\fP \fBoperator\-\fP (const T &y, const \fBscifir::scalar_unit\fP &x)"
.br
.RI "Substracts a scalar_unit x to a numeric type y, returns that result as a new scalar_unit with the same dimensions of x\&. "
.ti -1c
.RI "template<typename T , typename  = typename enable_if<scifir::is_number<T>::value>::type> \fBscifir::scalar_unit\fP \fBoperator*\fP (const T &y, const \fBscifir::scalar_unit\fP &x)"
.br
.RI "Multiplies a numeric type y with an scalar_unit x, returns that result as a new scalar_unit with the same dimensions of x\&. "
.ti -1c
.RI "template<typename T , typename  = typename enable_if<scifir::is_number<T>::value>::type> \fBscifir::scalar_unit\fP \fBoperator/\fP (const T &y, const \fBscifir::scalar_unit\fP &x)"
.br
.RI "Divides a numeric type y with an scalar_unit x, returns that result as a new scalar_unit with the same dimensions of x\&. "
.ti -1c
.RI "template<typename T , typename  = typename enable_if<scifir::is_number<T>::value>::type> float \fBoperator^\fP (const T &x, const \fBscifir::scalar_unit\fP &y)"
.br
.RI "Exponentiates a numeric type x with a scalar_unit y, only if that scalar_unit as empty dimensions, returns a float as the result of the calculation\&. "
.ti -1c
.RI "bool \fBoperator!=\fP (const \fBscifir::scalar_unit\fP &x, \fBscifir::scalar_unit\fP y)"
.br
.RI "Returns true if two scalar_unit classes doesn't have the same value when changed to same dimensions\&. If their basic dimensions are different, it returns false\&. "
.ti -1c
.RI "bool \fBoperator<\fP (const \fBscifir::scalar_unit\fP &x, const \fBscifir::scalar_unit\fP &y)"
.br
.RI "Returns true if x has a lower value than y, compared with the same dimensions\&. If their dimensions are not equal, they are changed to be equal in order to do the comparison\&. "
.ti -1c
.RI "bool \fBoperator>\fP (const \fBscifir::scalar_unit\fP &x, const \fBscifir::scalar_unit\fP &y)"
.br
.RI "Returns true if x has a greather value than y, compared with the same dimensions\&. If their dimensions are not equal, they are changed to be equal in order to do the comparison\&. "
.ti -1c
.RI "bool \fBoperator<=\fP (const \fBscifir::scalar_unit\fP &x, const \fBscifir::scalar_unit\fP &y)"
.br
.RI "Returns true if x has a lower or equal value than y, compared with the same dimensions\&. If their dimensions are not equal, they are changed to be equal in order to do the comparison\&. "
.ti -1c
.RI "bool \fBoperator>=\fP (const \fBscifir::scalar_unit\fP &x, const \fBscifir::scalar_unit\fP &y)"
.br
.RI "Returns true if x has a greather or equal value than y, compared with the same dimensions\&. If their dimensions are not equal, they are changed to be equal in order to do the comparison\&. "
.ti -1c
.RI "bool \fBoperator==\fP (const \fBscifir::scalar_unit\fP &x, const string &init_scalar)"
.br
.RI "Returns true if x is equal to the scalar_unit initialized with the string being compared\&. The display() function is not used, and so the values are compared with all its decimal numbers\&. "
.ti -1c
.RI "bool \fBoperator!=\fP (const \fBscifir::scalar_unit\fP &x, const string &init_scalar)"
.br
.RI "Returns true if x is not equal to the scalar_unit initialized with the string being compared\&. The display() function is not used, and so the values are compared with all its decimal numbers\&. "
.ti -1c
.RI "bool \fBoperator<\fP (const \fBscifir::scalar_unit\fP &x, const string &init_scalar)"
.br
.RI "Returns true if x is lower than the scalar_unit initialized with the string being compared\&. "
.ti -1c
.RI "bool \fBoperator>\fP (const \fBscifir::scalar_unit\fP &x, const string &init_scalar)"
.br
.RI "Returns true if x is greather than the scalar_unit initialized with the string being compared\&. "
.ti -1c
.RI "bool \fBoperator<=\fP (const \fBscifir::scalar_unit\fP &x, const string &init_scalar)"
.br
.RI "Returns true if x is lower or equal to the scalar_unit initialized with the string being compared\&. "
.ti -1c
.RI "bool \fBoperator>=\fP (const \fBscifir::scalar_unit\fP &x, const string &init_scalar)"
.br
.RI "Returns true if x is greather or equal to the scalar_unit initialized with the string being compared\&. "
.ti -1c
.RI "bool \fBoperator==\fP (const string &init_scalar, const \fBscifir::scalar_unit\fP &x)"
.br
.RI "Returns true if x is equal to the scalar_unit initialized with the string being compared\&. The display() function is not used, and so the values are compared with all its decimal numbers\&. "
.ti -1c
.RI "bool \fBoperator!=\fP (const string &init_scalar, const \fBscifir::scalar_unit\fP &x)"
.br
.RI "Returns true if x is not equal to the scalar_unit initialized with the string being compared\&. The display() function is not used, and so the values are compared with all its decimal numbers\&. "
.ti -1c
.RI "bool \fBoperator<\fP (const string &init_scalar, const \fBscifir::scalar_unit\fP &x)"
.br
.RI "Returns true if x is greather than the scalar_unit initialized with the string being compared\&. "
.ti -1c
.RI "bool \fBoperator>\fP (const string &init_scalar, const \fBscifir::scalar_unit\fP &x)"
.br
.RI "Returns true if x is lower than the scalar_unit initialized with the string being compared\&. "
.ti -1c
.RI "bool \fBoperator<=\fP (const string &init_scalar, const \fBscifir::scalar_unit\fP &x)"
.br
.RI "Returns true if x is greather or equal to the scalar_unit initialized with the string being compared\&. "
.ti -1c
.RI "bool \fBoperator>=\fP (const string &init_scalar, const \fBscifir::scalar_unit\fP &x)"
.br
.RI "Returns true if x is lower or equal to the scalar_unit initialized with the string being compared\&. "
.ti -1c
.RI "template<typename T , typename  = typename enable_if<scifir::is_number<T>::value>::type> bool \fBoperator==\fP (const T &x, const \fBscifir::scalar_unit\fP &y)"
.br
.RI "Returns true if the value of the scalar_unit is equal to the numeric type, ignoring the dimensions\&. "
.ti -1c
.RI "template<typename T , typename  = typename enable_if<scifir::is_number<T>::value>::type> bool \fBoperator!=\fP (const T &x, const \fBscifir::scalar_unit\fP &y)"
.br
.RI "Returns true if the value of the scalar_unit is not equal to the numeric type, ignoring the dimensions\&. "
.ti -1c
.RI "template<typename T , typename  = typename enable_if<scifir::is_number<T>::value>::type> bool \fBoperator<\fP (const T &x, const \fBscifir::scalar_unit\fP &y)"
.br
.RI "Returns true if the value of y is greather than the numeric type, ignoring the dimensions\&. "
.ti -1c
.RI "template<typename T , typename  = typename enable_if<scifir::is_number<T>::value>::type> bool \fBoperator>\fP (const T &x, const \fBscifir::scalar_unit\fP &y)"
.br
.RI "Returns true if the value of y is lower than the numeric type, ignoring the dimensions\&. "
.ti -1c
.RI "template<typename T , typename  = typename enable_if<scifir::is_number<T>::value>::type> bool \fBoperator<=\fP (const T &x, const \fBscifir::scalar_unit\fP &y)"
.br
.RI "Returns true if the value of y is lower or equal than the numeric type, ignoring the dimensions\&. "
.ti -1c
.RI "template<typename T , typename  = typename enable_if<scifir::is_number<T>::value>::type> bool \fBoperator>=\fP (const T &x, const \fBscifir::scalar_unit\fP &y)"
.br
.RI "Returns true if the value of y is equal or greather than the numeric type, ignoring the dimensions\&. "
.ti -1c
.RI "template<typename T , typename  = typename enable_if<scifir::is_number<T>::value>::type> bool \fBoperator==\fP (const \fBscifir::scalar_unit\fP &x, const T &y)"
.br
.RI "Returns true if the value of the scalar_unit is equal to the numeric type, ignoring the dimensions\&. "
.ti -1c
.RI "template<typename T , typename  = typename enable_if<scifir::is_number<T>::value>::type> bool \fBoperator!=\fP (const \fBscifir::scalar_unit\fP &x, const T &y)"
.br
.RI "Returns true if the value of the scalar_unit is not equal to the numeric type, ignoring the dimensions\&. "
.ti -1c
.RI "template<typename T , typename  = typename enable_if<scifir::is_number<T>::value>::type> bool \fBoperator<\fP (const \fBscifir::scalar_unit\fP &x, const T &y)"
.br
.RI "Returns true if the value of x is lower than the numeric type, ignoring the dimensions\&. "
.ti -1c
.RI "template<typename T , typename  = typename enable_if<scifir::is_number<T>::value>::type> bool \fBoperator>\fP (const \fBscifir::scalar_unit\fP &x, const T &y)"
.br
.RI "Returns true if the value of x is greather than the numeric type, ignoring the dimensions\&. "
.ti -1c
.RI "template<typename T , typename  = typename enable_if<scifir::is_number<T>::value>::type> bool \fBoperator<=\fP (const \fBscifir::scalar_unit\fP &x, const T &y)"
.br
.RI "Returns true if the value of x is lower or equal than the numeric type, ignoring the dimensions\&. "
.ti -1c
.RI "template<typename T , typename  = typename enable_if<scifir::is_number<T>::value>::type> bool \fBoperator>=\fP (const \fBscifir::scalar_unit\fP &x, const T &y)"
.br
.RI "Returns true if the value of x is equal or greather than the numeric type, ignoring the dimensions\&. "
.ti -1c
.RI "void \fBoperator+=\fP (string &x, const \fBscifir::scalar_unit\fP &y)"
.br
.RI "Concatenates the string representation of the scalar_unit y to the string x\&. "
.ti -1c
.RI "string \fBoperator+\fP (const string &x, const \fBscifir::scalar_unit\fP &y)"
.br
.RI "Creates a new string as the concatenation of the string x with the representation string of the scalar_unit y\&. "
.ti -1c
.RI "string \fBoperator+\fP (const \fBscifir::scalar_unit\fP &y, const string &x)"
.br
.RI "Creates a new string as the concatenation of the string x with the representation string of the scalar_unit y\&. "
.ti -1c
.RI "ostream & \fBoperator<<\fP (ostream &os, const \fBscifir::scalar_unit\fP &x)"
.br
.RI "Adds the string representation of the scalar_unit x to an output stream os\&. "
.ti -1c
.RI "istream & \fBoperator>>\fP (istream &is, \fBscifir::scalar_unit\fP &x)"
.br
.RI "Allows that an istream initializes by string a scalar_unit x\&. "
.in -1c
.SH "Macro Definition Documentation"
.PP 
.SS "#define SCALAR_UNIT_CPP(name, init_dimensions)"
\fBValue:\fP
.PP
.nf
  name::name() : scalar_unit() { \
    scalar_unit::dimensions = name::real_dimensions; \
} \
\
    name::name(const scalar_unit& x) \
    { \
        if (x\&.has_dimensions(name::real_dimensions)) \
        { \
            value = x\&.get_value(); \
            dimensions = x\&.get_dimensions(); \
        } \
    } \
\
    name::name(scalar_unit&& x) \
    { \
        if (x\&.has_dimensions(name::real_dimensions)) \
        { \
            value = std::move(x\&.get_value()); \
            dimensions = std::move(x\&.get_dimensions()); \
        } \
    } \
\
const string name::dimensions_match = init_dimensions; \
const vector<dimension> name::real_dimensions = create_derived_dimensions(init_dimensions)
.fi
.PP
Definition at line 49 of file scalar_unit\&.hpp\&.
.SS "#define SCALAR_UNIT_HPP(name)"
\fBValue:\fP
.PP
.nf
   class name : public scalar_unit \
    {   \
        public: \
            using scalar_unit::scalar_unit; \
            name(); \
            name(const scalar_unit&); \
            name(scalar_unit&&); \
            using scalar_unit::operator =; \
            using scalar_unit::operator+=; \
            using scalar_unit::operator-=; \
\
            static const string dimensions_match; \
            static const vector<dimension> real_dimensions; \
    }
.fi
.PP
Definition at line 34 of file scalar_unit\&.hpp\&.
.SS "#define SCALAR_UNIT_HPP_BEGIN(name)"
\fBValue:\fP
.PP
.nf
 class name : public scalar_unit \
    {   \
        public: \
            using scalar_unit::scalar_unit; \
            name(); \
            name(const scalar_unit&); \
            name(scalar_unit&&); \
            using scalar_unit::operator =; \
            using scalar_unit::operator+=; \
            using scalar_unit::operator-=
.fi
.PP
Definition at line 16 of file scalar_unit\&.hpp\&.
.SS "#define SCALAR_UNIT_HPP_END()"
\fBValue:\fP
.PP
.nf
\
        public: \
            static const string dimensions_match; \
            static const vector<dimension> real_dimensions; \
    }
.fi
.PP
Definition at line 27 of file scalar_unit\&.hpp\&.
.SH "Function Documentation"
.PP 
.SS "bool operator!= (const \fBscifir::scalar_unit\fP & x, const string & init_scalar)"

.PP
Returns true if x is not equal to the scalar_unit initialized with the string being compared\&. The display() function is not used, and so the values are compared with all its decimal numbers\&. 
.PP
Definition at line 804 of file scalar_unit\&.cpp\&.
.PP
.nf
805 {
806     return !(x == init_scalar);
807 }
.fi
.SS "template<typename T , typename  = typename enable_if<scifir::is_number<T>::value>::type> bool operator!= (const \fBscifir::scalar_unit\fP & x, const T & y)"

.PP
Returns true if the value of the scalar_unit is not equal to the numeric type, ignoring the dimensions\&. 
.PP
Definition at line 505 of file scalar_unit\&.hpp\&.
.PP
.nf
506 {
507     return !(x == y);
508 }
.fi
.SS "bool operator!= (const \fBscifir::scalar_unit\fP & x, \fBscifir::scalar_unit\fP y)"

.PP
Returns true if two scalar_unit classes doesn't have the same value when changed to same dimensions\&. If their basic dimensions are different, it returns false\&. 
.PP
Definition at line 747 of file scalar_unit\&.cpp\&.
.PP
.nf
748 {
749     return !(x == y);
750 }
.fi
.SS "bool operator!= (const string & init_scalar, const \fBscifir::scalar_unit\fP & x)"

.PP
Returns true if x is not equal to the scalar_unit initialized with the string being compared\&. The display() function is not used, and so the values are compared with all its decimal numbers\&. 
.PP
Definition at line 836 of file scalar_unit\&.cpp\&.
.PP
.nf
837 {
838     return (x != init_scalar);
839 }
.fi
.SS "template<typename T , typename  = typename enable_if<scifir::is_number<T>::value>::type> bool operator!= (const T & x, const \fBscifir::scalar_unit\fP & y)"

.PP
Returns true if the value of the scalar_unit is not equal to the numeric type, ignoring the dimensions\&. 
.PP
Definition at line 469 of file scalar_unit\&.hpp\&.
.PP
.nf
470 {
471     return !(x == y);
472 }
.fi
.SS "template<typename T , typename  = typename enable_if<scifir::is_number<T>::value>::type> \fBscifir::scalar_unit\fP operator* (const T & y, const \fBscifir::scalar_unit\fP & x)"

.PP
Multiplies a numeric type y with an scalar_unit x, returns that result as a new scalar_unit with the same dimensions of x\&. 
.PP
Definition at line 415 of file scalar_unit\&.hpp\&.
.PP
.nf
416 {
417     scifir::scalar_unit z = x;
418     z *= y;
419     return z;
420 }
.fi
.SS "string operator+ (const \fBscifir::scalar_unit\fP & y, const string & x)"

.PP
Creates a new string as the concatenation of the string x with the representation string of the scalar_unit y\&. 
.PP
Definition at line 878 of file scalar_unit\&.cpp\&.
.PP
.nf
879 {
880     ostringstream output;
881     output << y;
882     output << x;
883     return output\&.str();
884 }
.fi
.SS "string operator+ (const string & x, const \fBscifir::scalar_unit\fP & y)"

.PP
Creates a new string as the concatenation of the string x with the representation string of the scalar_unit y\&. 
.PP
Definition at line 870 of file scalar_unit\&.cpp\&.
.PP
.nf
871 {
872     ostringstream output;
873     output << x;
874     output << y;
875     return output\&.str();
876 }
.fi
.SS "template<typename T , typename  = typename enable_if<scifir::is_number<T>::value>::type> \fBscifir::scalar_unit\fP operator+ (const T & y, const \fBscifir::scalar_unit\fP & x)"

.PP
Sums a numeric type y with an scalar_unit x, returns that result as a new scalar_unit with the same dimensions of x\&. 
.PP
Definition at line 399 of file scalar_unit\&.hpp\&.
.PP
.nf
400 {
401     scifir::scalar_unit z = x;
402     z += y;
403     return z;
404 }
.fi
.SS "void operator+= (string & x, const \fBscifir::scalar_unit\fP & y)"

.PP
Concatenates the string representation of the scalar_unit y to the string x\&. 
.PP
Definition at line 863 of file scalar_unit\&.cpp\&.
.PP
.nf
864 {
865     ostringstream output;
866     output << y;
867     x += output\&.str();
868 }
.fi
.SS "template<typename T , typename  = typename enable_if<scifir::is_number<T>::value>::type> \fBscifir::scalar_unit\fP operator\- (const T & y, const \fBscifir::scalar_unit\fP & x)"

.PP
Substracts a scalar_unit x to a numeric type y, returns that result as a new scalar_unit with the same dimensions of x\&. 
.PP
Definition at line 407 of file scalar_unit\&.hpp\&.
.PP
.nf
408 {
409     scifir::scalar_unit z = scifir::scalar_unit((long double)y,x\&.get_dimensions());
410     z -= x;
411     return z;
412 }
.fi
.SS "template<typename T , typename  = typename enable_if<scifir::is_number<T>::value>::type> \fBscifir::scalar_unit\fP operator/ (const T & y, const \fBscifir::scalar_unit\fP & x)"

.PP
Divides a numeric type y with an scalar_unit x, returns that result as a new scalar_unit with the same dimensions of x\&. 
.PP
Definition at line 423 of file scalar_unit\&.hpp\&.
.PP
.nf
424 {
425     scifir::scalar_unit z = scifir::scalar_unit((long double)y,vector<scifir::dimension>());
426     return z / x;
427 }
.fi
.SS "bool operator< (const \fBscifir::scalar_unit\fP & x, const \fBscifir::scalar_unit\fP & y)"

.PP
Returns true if x has a lower value than y, compared with the same dimensions\&. If their dimensions are not equal, they are changed to be equal in order to do the comparison\&. 
.PP
Definition at line 752 of file scalar_unit\&.cpp\&.
.PP
.nf
753 {
754     if(!x\&.has_dimensions(y))
755     {
756         return false;
757     }
758     scifir::scalar_unit z = x;
759     z\&.change_dimensions(y);
760     if(z\&.get_value() < y\&.get_value())
761     {
762         return true;
763     }
764     else
765     {
766         return false;
767     }
768 }
.fi
.SS "bool operator< (const \fBscifir::scalar_unit\fP & x, const string & init_scalar)"

.PP
Returns true if x is lower than the scalar_unit initialized with the string being compared\&. 
.PP
Definition at line 809 of file scalar_unit\&.cpp\&.
.PP
.nf
810 {
811     scifir::scalar_unit y(init_scalar);
812     return (x < y);
813 }
.fi
.SS "template<typename T , typename  = typename enable_if<scifir::is_number<T>::value>::type> bool operator< (const \fBscifir::scalar_unit\fP & x, const T & y)"

.PP
Returns true if the value of x is lower than the numeric type, ignoring the dimensions\&. 
.PP
Definition at line 511 of file scalar_unit\&.hpp\&.
.PP
.nf
512 {
513     return (x\&.get_value() < y);
514 }
.fi
.SS "bool operator< (const string & init_scalar, const \fBscifir::scalar_unit\fP & x)"

.PP
Returns true if x is greather than the scalar_unit initialized with the string being compared\&. 
.PP
Definition at line 841 of file scalar_unit\&.cpp\&.
.PP
.nf
842 {
843     scifir::scalar_unit y(init_scalar);
844     return (y < x);
845 }
.fi
.SS "template<typename T , typename  = typename enable_if<scifir::is_number<T>::value>::type> bool operator< (const T & x, const \fBscifir::scalar_unit\fP & y)"

.PP
Returns true if the value of y is greather than the numeric type, ignoring the dimensions\&. 
.PP
Definition at line 475 of file scalar_unit\&.hpp\&.
.PP
.nf
476 {
477     return (x < y\&.get_value());
478 }
.fi
.SS "ostream& operator<< (ostream & os, const \fBscifir::scalar_unit\fP & x)"

.PP
Adds the string representation of the scalar_unit x to an output stream os\&. 
.PP
Definition at line 886 of file scalar_unit\&.cpp\&.
.PP
.nf
887 {
888     return os << to_string(x);
889 }
.fi
.SS "bool operator<= (const \fBscifir::scalar_unit\fP & x, const \fBscifir::scalar_unit\fP & y)"

.PP
Returns true if x has a lower or equal value than y, compared with the same dimensions\&. If their dimensions are not equal, they are changed to be equal in order to do the comparison\&. 
.PP
Definition at line 788 of file scalar_unit\&.cpp\&.
.PP
.nf
789 {
790     return !(x > y);
791 }
.fi
.SS "bool operator<= (const \fBscifir::scalar_unit\fP & x, const string & init_scalar)"

.PP
Returns true if x is lower or equal to the scalar_unit initialized with the string being compared\&. 
.PP
Definition at line 821 of file scalar_unit\&.cpp\&.
.PP
.nf
822 {
823     return !(x > init_scalar);
824 }
.fi
.SS "template<typename T , typename  = typename enable_if<scifir::is_number<T>::value>::type> bool operator<= (const \fBscifir::scalar_unit\fP & x, const T & y)"

.PP
Returns true if the value of x is lower or equal than the numeric type, ignoring the dimensions\&. 
.PP
Definition at line 523 of file scalar_unit\&.hpp\&.
.PP
.nf
524 {
525     return (x\&.get_value() <= y);
526 }
.fi
.SS "bool operator<= (const string & init_scalar, const \fBscifir::scalar_unit\fP & x)"

.PP
Returns true if x is greather or equal to the scalar_unit initialized with the string being compared\&. 
.PP
Definition at line 853 of file scalar_unit\&.cpp\&.
.PP
.nf
854 {
855     return !(init_scalar > x);
856 }
.fi
.SS "template<typename T , typename  = typename enable_if<scifir::is_number<T>::value>::type> bool operator<= (const T & x, const \fBscifir::scalar_unit\fP & y)"

.PP
Returns true if the value of y is lower or equal than the numeric type, ignoring the dimensions\&. 
.PP
Definition at line 487 of file scalar_unit\&.hpp\&.
.PP
.nf
488 {
489     return (x <= y\&.get_value());
490 }
.fi
.SS "bool operator== (const \fBscifir::scalar_unit\fP & x, const string & init_scalar)"

.PP
Returns true if x is equal to the scalar_unit initialized with the string being compared\&. The display() function is not used, and so the values are compared with all its decimal numbers\&. 
.PP
Definition at line 798 of file scalar_unit\&.cpp\&.
.PP
.nf
799 {
800     scifir::scalar_unit y(init_scalar);
801     return (x == y);
802 }
.fi
.SS "template<typename T , typename  = typename enable_if<scifir::is_number<T>::value>::type> bool operator== (const \fBscifir::scalar_unit\fP & x, const T & y)"

.PP
Returns true if the value of the scalar_unit is equal to the numeric type, ignoring the dimensions\&. 
.PP
Definition at line 499 of file scalar_unit\&.hpp\&.
.PP
.nf
500 {
501     return (x\&.get_value() == y);
502 }
.fi
.SS "bool operator== (const string & init_scalar, const \fBscifir::scalar_unit\fP & x)"

.PP
Returns true if x is equal to the scalar_unit initialized with the string being compared\&. The display() function is not used, and so the values are compared with all its decimal numbers\&. 
.PP
Definition at line 831 of file scalar_unit\&.cpp\&.
.PP
.nf
832 {
833     return (x == init_scalar);
834 }
.fi
.SS "template<typename T , typename  = typename enable_if<scifir::is_number<T>::value>::type> bool operator== (const T & x, const \fBscifir::scalar_unit\fP & y)"

.PP
Returns true if the value of the scalar_unit is equal to the numeric type, ignoring the dimensions\&. 
.PP
Definition at line 463 of file scalar_unit\&.hpp\&.
.PP
.nf
464 {
465     return (x == y\&.get_value());
466 }
.fi
.SS "bool operator> (const \fBscifir::scalar_unit\fP & x, const \fBscifir::scalar_unit\fP & y)"

.PP
Returns true if x has a greather value than y, compared with the same dimensions\&. If their dimensions are not equal, they are changed to be equal in order to do the comparison\&. 
.PP
Definition at line 770 of file scalar_unit\&.cpp\&.
.PP
.nf
771 {
772     if(!x\&.has_dimensions(y))
773     {
774         return false;
775     }
776     scifir::scalar_unit z = x;
777     z\&.change_dimensions(y);
778     if(z\&.get_value() > y\&.get_value())
779     {
780         return true;
781     }
782     else
783     {
784         return false;
785     }
786 }
.fi
.SS "bool operator> (const \fBscifir::scalar_unit\fP & x, const string & init_scalar)"

.PP
Returns true if x is greather than the scalar_unit initialized with the string being compared\&. 
.PP
Definition at line 815 of file scalar_unit\&.cpp\&.
.PP
.nf
816 {
817     scifir::scalar_unit y(init_scalar);
818     return (x > y);
819 }
.fi
.SS "template<typename T , typename  = typename enable_if<scifir::is_number<T>::value>::type> bool operator> (const \fBscifir::scalar_unit\fP & x, const T & y)"

.PP
Returns true if the value of x is greather than the numeric type, ignoring the dimensions\&. 
.PP
Definition at line 517 of file scalar_unit\&.hpp\&.
.PP
.nf
518 {
519     return (x\&.get_value() > y);
520 }
.fi
.SS "bool operator> (const string & init_scalar, const \fBscifir::scalar_unit\fP & x)"

.PP
Returns true if x is lower than the scalar_unit initialized with the string being compared\&. 
.PP
Definition at line 847 of file scalar_unit\&.cpp\&.
.PP
.nf
848 {
849     scifir::scalar_unit y(init_scalar);
850     return (y > x);
851 }
.fi
.SS "template<typename T , typename  = typename enable_if<scifir::is_number<T>::value>::type> bool operator> (const T & x, const \fBscifir::scalar_unit\fP & y)"

.PP
Returns true if the value of y is lower than the numeric type, ignoring the dimensions\&. 
.PP
Definition at line 481 of file scalar_unit\&.hpp\&.
.PP
.nf
482 {
483     return (x > y\&.get_value());
484 }
.fi
.SS "bool operator>= (const \fBscifir::scalar_unit\fP & x, const \fBscifir::scalar_unit\fP & y)"

.PP
Returns true if x has a greather or equal value than y, compared with the same dimensions\&. If their dimensions are not equal, they are changed to be equal in order to do the comparison\&. 
.PP
Definition at line 793 of file scalar_unit\&.cpp\&.
.PP
.nf
794 {
795     return !(x < y);
796 }
.fi
.SS "bool operator>= (const \fBscifir::scalar_unit\fP & x, const string & init_scalar)"

.PP
Returns true if x is greather or equal to the scalar_unit initialized with the string being compared\&. 
.PP
Definition at line 826 of file scalar_unit\&.cpp\&.
.PP
.nf
827 {
828     return !(x < init_scalar);
829 }
.fi
.SS "template<typename T , typename  = typename enable_if<scifir::is_number<T>::value>::type> bool operator>= (const \fBscifir::scalar_unit\fP & x, const T & y)"

.PP
Returns true if the value of x is equal or greather than the numeric type, ignoring the dimensions\&. 
.PP
Definition at line 529 of file scalar_unit\&.hpp\&.
.PP
.nf
530 {
531     return (x\&.get_value() >= y);
532 }
.fi
.SS "bool operator>= (const string & init_scalar, const \fBscifir::scalar_unit\fP & x)"

.PP
Returns true if x is lower or equal to the scalar_unit initialized with the string being compared\&. 
.PP
Definition at line 858 of file scalar_unit\&.cpp\&.
.PP
.nf
859 {
860     return !(init_scalar < x);
861 }
.fi
.SS "template<typename T , typename  = typename enable_if<scifir::is_number<T>::value>::type> bool operator>= (const T & x, const \fBscifir::scalar_unit\fP & y)"

.PP
Returns true if the value of y is equal or greather than the numeric type, ignoring the dimensions\&. 
.PP
Definition at line 493 of file scalar_unit\&.hpp\&.
.PP
.nf
494 {
495     return (x >= y\&.get_value());
496 }
.fi
.SS "istream& operator>> (istream & is, \fBscifir::scalar_unit\fP & x)"

.PP
Allows that an istream initializes by string a scalar_unit x\&. 
.PP
Definition at line 891 of file scalar_unit\&.cpp\&.
.PP
.nf
892 {
893     char a[256];
894     is\&.getline(a, 256);
895     string b(a);
896     boost::trim(b);
897     x = scifir::scalar_unit(b);
898     return is;
899 }
.fi
.SS "template<typename T , typename  = typename enable_if<scifir::is_number<T>::value>::type> float operator^ (const T & x, const \fBscifir::scalar_unit\fP & y)"

.PP
Exponentiates a numeric type x with a scalar_unit y, only if that scalar_unit as empty dimensions, returns a float as the result of the calculation\&. 
.PP
Definition at line 430 of file scalar_unit\&.hpp\&.
.PP
.nf
431 {
432     if(y\&.has_empty_dimensions())
433     {
434         return std::pow(x, y\&.get_value());
435     }
436     else
437     {
438         return 0;
439     }
440 }
.fi
.SH "Author"
.PP 
Generated automatically by Doxygen for scifir-units from the source code\&.
