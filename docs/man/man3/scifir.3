.TH "scifir" 3 "Sat Jul 13 2024" "Version 2.0.0" "scifir-units" \" -*- nroff -*-
.ad l
.nh
.SH NAME
scifir \- The namespace scifir contains all scifir-units, excepting the string literals, which are outside\&.  

.SH SYNOPSIS
.br
.PP
.SS "Classes"

.in +1c
.ti -1c
.RI "class \fBcoordinates_1d\fP"
.br
.ti -1c
.RI "class \fBcoordinates_1d< float >\fP"
.br
.ti -1c
.RI "class \fBcoordinates_2d\fP"
.br
.ti -1c
.RI "class \fBcoordinates_2d< float >\fP"
.br
.ti -1c
.RI "class \fBcoordinates_2dr\fP"
.br
.ti -1c
.RI "class \fBcoordinates_2dr< float >\fP"
.br
.ti -1c
.RI "class \fBcoordinates_3d\fP"
.br
.ti -1c
.RI "class \fBcoordinates_3d< float >\fP"
.br
.ti -1c
.RI "class \fBcoordinates_3dr\fP"
.br
.ti -1c
.RI "class \fBcoordinates_3dr< float >\fP"
.br
.ti -1c
.RI "class \fBcoordinates_nd\fP"
.br
.ti -1c
.RI "class \fBcoordinates_nd< float >\fP"
.br
.ti -1c
.RI "class \fBcoordinates_ndr\fP"
.br
.ti -1c
.RI "class \fBcoordinates_ndr< float >\fP"
.br
.ti -1c
.RI "class \fBangle\fP"
.br
.RI "Class that allows to work with angles\&. Each angle sizes 4 bytes\&. "
.ti -1c
.RI "class \fBcomplex_number\fP"
.br
.ti -1c
.RI "class \fBlab_number\fP"
.br
.ti -1c
.RI "class \fBcas_number\fP"
.br
.ti -1c
.RI "class \fBsize_2d\fP"
.br
.ti -1c
.RI "class \fBsize_3d\fP"
.br
.ti -1c
.RI "class \fBaid\fP"
.br
.ti -1c
.RI "class \fBcolor\fP"
.br
.ti -1c
.RI "class \fBpercentage\fP"
.br
.ti -1c
.RI "class \fBpH\fP"
.br
.ti -1c
.RI "class \fBpixel\fP"
.br
.ti -1c
.RI "class \fBpOH\fP"
.br
.ti -1c
.RI "class \fBsize_2d< float >\fP"
.br
.ti -1c
.RI "class \fBsize_3d< float >\fP"
.br
.ti -1c
.RI "class \fBsize_nd\fP"
.br
.ti -1c
.RI "class \fBsize_nd< float >\fP"
.br
.ti -1c
.RI "class \fBzid\fP"
.br
.ti -1c
.RI "class \fBdirection\fP"
.br
.ti -1c
.RI "class \fBpoint_1d\fP"
.br
.ti -1c
.RI "class \fBpoint_1d< float >\fP"
.br
.ti -1c
.RI "class \fBpoint_2d\fP"
.br
.ti -1c
.RI "class \fBpoint_2d< float >\fP"
.br
.ti -1c
.RI "class \fBpoint_3d\fP"
.br
.ti -1c
.RI "class \fBpoint_3d< float >\fP"
.br
.ti -1c
.RI "class \fBpoint_nd\fP"
.br
.ti -1c
.RI "class \fBpoint_nd< float >\fP"
.br
.ti -1c
.RI "class \fBconversion\fP"
.br
.ti -1c
.RI "class \fBdimension\fP"
.br
.RI "Class that represents dimensions of the SI system of units\&. Each prefix sizes 6 bytes, 1 byte for the dimension type, 1 byte for the prefix, 1 byte for the position (which can be the NUMERATOR or the DENOMINATOR), and 3 bytes for the custom dimension (in case it's used one)\&. "
.ti -1c
.RI "class \fBprefix\fP"
.br
.RI "Class that represents prefixes of the SI system of units\&. Each prefix sizes 1 byte\&. "
.ti -1c
.RI "class \fBscalar_unit\fP"
.br
.RI "Class that allows to create scalar units, which are cmoposed of a value (as a float) and dimensions\&. The dimensions can be of any number, and be basic dimensions and/or abbreviations of dimensions\&. "
.ti -1c
.RI "class \fBvector_unit_2d\fP"
.br
.RI "Class that creates a vector unit in 2D\&. The vector is in \fBpolar coordinates\fP with a value and dimensions of the \fBscalar_unit\fP, and an angle theta for his direction\&. "
.ti -1c
.RI "class \fBvector_unit_3d\fP"
.br
.RI "Class that creates a vector unit in 3D\&. The vector is in \fBspherical coordinates\fP with a value and dimensions of the \fBscalar_unit\fP, and an angle theta and another angle phi for his direction\&. "
.ti -1c
.RI "class \fBvector_unit_nd\fP"
.br
.ti -1c
.RI "struct \fBis_number\fP"
.br
.ti -1c
.RI "struct \fBis_integer_number\fP"
.br
.ti -1c
.RI "class \fBmatrix\fP"
.br
.in -1c
.SS "Typedefs"

.in +1c
.ti -1c
.RI "typedef length \fBwavelength\fP"
.br
.in -1c
.SS "Enumerations"

.in +1c
.ti -1c
.RI "enum class \fBastronomical_body\fP : int8_t { \fBNONE\fP, \fBMILKY_WAY\fP, \fBANDROMEDA\fP, \fBSOLAR_SYSTEM\fP, \fBSUN\fP, \fBMOON\fP, \fBMERCURY\fP, \fBVENUS\fP, \fBEARTH\fP, \fBMARS\fP, \fBJUPITER\fP, \fBSATURN\fP, \fBURANUS\fP, \fBNEPTUNE\fP, \fBCERES\fP, \fBORCUS\fP, \fBPLUTO\fP, \fBHAUMEA\fP, \fBQUAOAR\fP, \fBMAKEMAKE\fP, \fBGONGGONG\fP, \fBERIS\fP, \fBSEDNA\fP, \fBIO\fP, \fBEUROPA\fP, \fBGANYMEDE\fP, \fBCALLISTO\fP, \fBMIMAS\fP, \fBENCELADUS\fP, \fBTETHYS\fP, \fBDIONE\fP, \fBRHEA\fP, \fBTITAN\fP, \fBIAPETUS\fP, \fBMIRANDA\fP, \fBARIEL\fP, \fBUMBRIEL\fP, \fBTITANIA\fP, \fBOBERON\fP, \fBTRITON\fP, \fBCHARON\fP, \fBDYSNOMIA\fP }"
.br
.ti -1c
.RI "enum class \fBmovement\fP { \fBSTILL\fP, \fBWALK\fP, \fBRUN\fP, \fBSWIM\fP, \fBCLIMB\fP, \fBFLY\fP }"
.br
.ti -1c
.RI "enum class \fBmovement_state\fP { \fBSTILL\fP, \fBACTIVE\fP }"
.br
.ti -1c
.RI "enum class \fBbody_health\fP { \fBHEALTHY\fP, \fBDAMAGED\fP, \fBSICK\fP, \fBSICK_AND_DAMAGED\fP }"
.br
.ti -1c
.RI "enum class \fBalert_state\fP { \fBVIGIL\fP, \fBSLEEP\fP, \fBMEDITATION\fP }"
.br
.ti -1c
.RI "enum class \fBfeeling\fP { \fBSADNESS\fP, \fBRANCOR\fP, \fBLOVE\fP }"
.br
.ti -1c
.RI "enum class \fBemotion\fP { \fBHAPPY\fP, \fBEXCITED\fP, \fBTENDER\fP, \fBSCARED\fP, \fBANGRY\fP, \fBSAD\fP }"
.br
.ti -1c
.RI "enum class \fBsensation\fP { \fBLIGHT\fP, \fBSOUND\fP, \fBACCELERATION\fP, \fBODOR\fP, \fBTASTE\fP, \fBTOUCH\fP, \fBTEMPERATURE\fP }"
.br
.ti -1c
.RI "enum class \fBconscience_state\fP { \fBNORMAL\fP, \fBALTERED\fP }"
.br
.in -1c
.SS "Functions"

.in +1c
.ti -1c
.RI "string \fBto_string\fP (const \fBcoordinates_1d\fP< float > &x)"
.br
.ti -1c
.RI "float \fBdistance\fP (const \fBcoordinates_1d\fP< float > &x, const \fBcoordinates_1d\fP< float > &y)"
.br
.ti -1c
.RI "float \fBdistance\fP (const \fBcoordinates_1d\fP< float > &x, const \fBpoint_1d\fP< float > &y)"
.br
.ti -1c
.RI "float \fBdistance\fP (const \fBpoint_1d\fP< float > &x, const \fBcoordinates_1d\fP< float > &y)"
.br
.ti -1c
.RI "template<typename T > string \fBto_string\fP (const \fBcoordinates_1d\fP< T > &x)"
.br
.ti -1c
.RI "template<typename T , typename U > T \fBdistance\fP (const \fBcoordinates_1d\fP< T > &x, const \fBcoordinates_1d\fP< U > &y)"
.br
.ti -1c
.RI "template<typename T , typename U > T \fBdistance\fP (const \fBcoordinates_1d\fP< T > &x, const \fBpoint_1d\fP< U > &y)"
.br
.ti -1c
.RI "template<typename T , typename U > T \fBdistance\fP (const \fBpoint_1d\fP< T > &x, const \fBcoordinates_1d\fP< U > &y)"
.br
.ti -1c
.RI "string \fBto_string\fP (const \fBcoordinates_2d\fP< float > &x)"
.br
.ti -1c
.RI "float \fBdistance\fP (const \fBcoordinates_2d\fP< float > &x, const \fBcoordinates_2d\fP< float > &y)"
.br
.ti -1c
.RI "float \fBdistance\fP (const \fBcoordinates_2d\fP< float > &x, const \fBpoint_2d\fP< float > &y)"
.br
.ti -1c
.RI "float \fBdistance\fP (const \fBpoint_2d\fP< float > &x, const \fBcoordinates_2d\fP< float > &y)"
.br
.ti -1c
.RI "template<typename T > string \fBto_string\fP (const \fBcoordinates_2d\fP< T > &x)"
.br
.ti -1c
.RI "template<typename T , typename U > T \fBdistance\fP (const \fBcoordinates_2d\fP< T > &x, const \fBcoordinates_2d\fP< U > &y)"
.br
.ti -1c
.RI "template<typename T , typename U > T \fBdistance\fP (const \fBcoordinates_2d\fP< T > &x, const \fBpoint_2d\fP< U > &y)"
.br
.ti -1c
.RI "template<typename T , typename U > T \fBdistance\fP (const \fBpoint_2d\fP< T > &x, const \fBcoordinates_2d\fP< U > &y)"
.br
.ti -1c
.RI "\fBscalar_unit\fP \fBcartesian_2d_to_polar_p\fP (const \fBscalar_unit\fP &x, \fBscalar_unit\fP y)"
.br
.ti -1c
.RI "\fBangle\fP \fBcartesian_2d_to_polar_theta\fP (const \fBscalar_unit\fP &x, \fBscalar_unit\fP y)"
.br
.ti -1c
.RI "\fBscalar_unit\fP \fBpolar_to_cartesian_2d_x\fP (const \fBscalar_unit\fP &p, const \fBangle\fP &theta)"
.br
.ti -1c
.RI "\fBscalar_unit\fP \fBpolar_to_cartesian_2d_y\fP (const \fBscalar_unit\fP &p, const \fBangle\fP &theta)"
.br
.ti -1c
.RI "float \fBcartesian_2d_to_polar_p\fP (float x, float y)"
.br
.ti -1c
.RI "\fBangle\fP \fBcartesian_2d_to_polar_theta\fP (float x, float y)"
.br
.ti -1c
.RI "float \fBpolar_to_cartesian_2d_x\fP (float p, const \fBangle\fP &theta)"
.br
.ti -1c
.RI "float \fBpolar_to_cartesian_2d_y\fP (float p, const \fBangle\fP &theta)"
.br
.ti -1c
.RI "string \fBto_string\fP (const \fBcoordinates_2dr\fP< float > &x)"
.br
.ti -1c
.RI "float \fBdistance\fP (const \fBcoordinates_2dr\fP< float > &x, const \fBcoordinates_2dr\fP< float > &y)"
.br
.ti -1c
.RI "float \fBdistance\fP (const \fBcoordinates_2dr\fP< float > &x, const \fBcoordinates_2d\fP< float > &y)"
.br
.ti -1c
.RI "float \fBdistance\fP (const \fBcoordinates_2d\fP< float > &x, const \fBcoordinates_2dr\fP< float > &y)"
.br
.ti -1c
.RI "float \fBdistance\fP (const \fBcoordinates_2dr\fP< float > &x, const \fBpoint_2d\fP< float > &y)"
.br
.ti -1c
.RI "float \fBdistance\fP (const \fBpoint_2d\fP< float > &x, const \fBcoordinates_2dr\fP< float > &y)"
.br
.ti -1c
.RI "template<typename T > string \fBto_string\fP (const \fBcoordinates_2dr\fP< T > &x)"
.br
.ti -1c
.RI "template<typename T , typename U > T \fBdistance\fP (const \fBcoordinates_2dr\fP< T > &x, const \fBcoordinates_2dr\fP< U > &y)"
.br
.ti -1c
.RI "template<typename T , typename U > T \fBdistance\fP (const \fBcoordinates_2dr\fP< T > &x, const \fBcoordinates_2d\fP< U > &y)"
.br
.ti -1c
.RI "template<typename T , typename U > T \fBdistance\fP (const \fBcoordinates_2d\fP< T > &x, const \fBcoordinates_2dr\fP< U > &y)"
.br
.ti -1c
.RI "template<typename T , typename U > T \fBdistance\fP (const \fBcoordinates_2dr\fP< T > &x, const \fBpoint_2d\fP< U > &y)"
.br
.ti -1c
.RI "template<typename T , typename U > T \fBdistance\fP (const \fBpoint_2d\fP< T > &x, const \fBcoordinates_2dr\fP< U > &y)"
.br
.ti -1c
.RI "string \fBto_string\fP (const \fBcoordinates_3d\fP< float > &x)"
.br
.ti -1c
.RI "float \fBdistance\fP (const \fBcoordinates_3d\fP< float > &x, const \fBcoordinates_3d\fP< float > &y)"
.br
.ti -1c
.RI "float \fBdistance\fP (const \fBcoordinates_3d\fP< float > &x, const \fBpoint_3d\fP< float > &y)"
.br
.ti -1c
.RI "float \fBdistance\fP (const \fBpoint_3d\fP< float > &x, const \fBcoordinates_3d\fP< float > &y)"
.br
.ti -1c
.RI "template<typename T > string \fBto_string\fP (const \fBcoordinates_3d\fP< T > &x)"
.br
.ti -1c
.RI "template<typename T , typename U > T \fBdistance\fP (const \fBcoordinates_3d\fP< T > &x, const \fBcoordinates_3d\fP< U > &y)"
.br
.ti -1c
.RI "template<typename T , typename U > T \fBdistance\fP (const \fBcoordinates_3d\fP< T > &x, const \fBpoint_3d\fP< U > &y)"
.br
.ti -1c
.RI "template<typename T , typename U > T \fBdistance\fP (const \fBpoint_3d\fP< T > &x, const \fBcoordinates_3d\fP< U > &y)"
.br
.ti -1c
.RI "\fBscalar_unit\fP \fBcartesian_3d_to_cylindrical_p\fP (const \fBscalar_unit\fP &x, \fBscalar_unit\fP y, const \fBscalar_unit\fP &z)"
.br
.ti -1c
.RI "\fBangle\fP \fBcartesian_3d_to_cylindrical_theta\fP (const \fBscalar_unit\fP &x, \fBscalar_unit\fP y, const \fBscalar_unit\fP &z)"
.br
.ti -1c
.RI "\fBscalar_unit\fP \fBcartesian_3d_to_cylindrical_z\fP (const \fBscalar_unit\fP &x, const \fBscalar_unit\fP &y, const \fBscalar_unit\fP &z)"
.br
.ti -1c
.RI "\fBscalar_unit\fP \fBcartesian_3d_to_spherical_r\fP (const \fBscalar_unit\fP &x, \fBscalar_unit\fP y, \fBscalar_unit\fP z)"
.br
.ti -1c
.RI "\fBangle\fP \fBcartesian_3d_to_spherical_theta\fP (const \fBscalar_unit\fP &x, \fBscalar_unit\fP y, const \fBscalar_unit\fP &z)"
.br
.ti -1c
.RI "\fBangle\fP \fBcartesian_3d_to_spherical_phi\fP (const \fBscalar_unit\fP &x, \fBscalar_unit\fP y, \fBscalar_unit\fP z)"
.br
.ti -1c
.RI "\fBscalar_unit\fP \fBspherical_to_cartesian_3d_x\fP (const \fBscalar_unit\fP &r, const \fBangle\fP &theta, const \fBangle\fP &phi)"
.br
.ti -1c
.RI "\fBscalar_unit\fP \fBspherical_to_cartesian_3d_y\fP (const \fBscalar_unit\fP &r, const \fBangle\fP &theta, const \fBangle\fP &phi)"
.br
.ti -1c
.RI "\fBscalar_unit\fP \fBspherical_to_cartesian_3d_z\fP (const \fBscalar_unit\fP &r, const \fBangle\fP &theta, const \fBangle\fP &phi)"
.br
.ti -1c
.RI "\fBscalar_unit\fP \fBspherical_to_cylindrical_p\fP (const \fBscalar_unit\fP &r, const \fBangle\fP &theta, const \fBangle\fP &phi)"
.br
.ti -1c
.RI "\fBangle\fP \fBspherical_to_cylindrical_theta\fP (const \fBscalar_unit\fP &r, const \fBangle\fP &theta, const \fBangle\fP &phi)"
.br
.ti -1c
.RI "\fBscalar_unit\fP \fBspherical_to_cylindrical_z\fP (const \fBscalar_unit\fP &r, const \fBangle\fP &theta, const \fBangle\fP &phi)"
.br
.ti -1c
.RI "\fBscalar_unit\fP \fBcylindrical_to_cartesian_3d_x\fP (const \fBscalar_unit\fP &p, const \fBangle\fP &theta, const \fBscalar_unit\fP &z)"
.br
.ti -1c
.RI "\fBscalar_unit\fP \fBcylindrical_to_cartesian_3d_y\fP (const \fBscalar_unit\fP &p, const \fBangle\fP &theta, const \fBscalar_unit\fP &z)"
.br
.ti -1c
.RI "\fBscalar_unit\fP \fBcylindrical_to_cartesian_3d_z\fP (const \fBscalar_unit\fP &p, const \fBangle\fP &theta, const \fBscalar_unit\fP &z)"
.br
.ti -1c
.RI "\fBscalar_unit\fP \fBcylindrical_to_spherical_r\fP (const \fBscalar_unit\fP &p, const \fBangle\fP &theta, \fBscalar_unit\fP z)"
.br
.ti -1c
.RI "\fBangle\fP \fBcylindrical_to_spherical_theta\fP (const \fBscalar_unit\fP &p, const \fBangle\fP &theta, const \fBscalar_unit\fP &z)"
.br
.ti -1c
.RI "\fBangle\fP \fBcylindrical_to_spherical_phi\fP (const \fBscalar_unit\fP &p, const \fBangle\fP &theta, \fBscalar_unit\fP z)"
.br
.ti -1c
.RI "float \fBcartesian_3d_to_cylindrical_p\fP (float x, float y, float z)"
.br
.ti -1c
.RI "\fBangle\fP \fBcartesian_3d_to_cylindrical_theta\fP (float x, float y, float z)"
.br
.ti -1c
.RI "float \fBcartesian_3d_to_cylindrical_z\fP (float x, float y, float z)"
.br
.ti -1c
.RI "float \fBcartesian_3d_to_spherical_r\fP (float x, float y, float z)"
.br
.ti -1c
.RI "\fBangle\fP \fBcartesian_3d_to_spherical_theta\fP (float x, float y, float z)"
.br
.ti -1c
.RI "\fBangle\fP \fBcartesian_3d_to_spherical_phi\fP (float x, float y, float z)"
.br
.ti -1c
.RI "float \fBspherical_to_cartesian_3d_x\fP (float r, const \fBangle\fP &theta, const \fBangle\fP &phi)"
.br
.ti -1c
.RI "float \fBspherical_to_cartesian_3d_y\fP (float r, const \fBangle\fP &theta, const \fBangle\fP &phi)"
.br
.ti -1c
.RI "float \fBspherical_to_cartesian_3d_z\fP (float r, const \fBangle\fP &theta, const \fBangle\fP &phi)"
.br
.ti -1c
.RI "float \fBspherical_to_cylindrical_p\fP (float r, const \fBangle\fP &theta, const \fBangle\fP &phi)"
.br
.ti -1c
.RI "\fBangle\fP \fBspherical_to_cylindrical_theta\fP (float r, const \fBangle\fP &theta, const \fBangle\fP &phi)"
.br
.ti -1c
.RI "float \fBspherical_to_cylindrical_z\fP (float r, const \fBangle\fP &theta, const \fBangle\fP &phi)"
.br
.ti -1c
.RI "float \fBcylindrical_to_cartesian_3d_x\fP (float p, const \fBangle\fP &theta, float z)"
.br
.ti -1c
.RI "float \fBcylindrical_to_cartesian_3d_y\fP (float p, const \fBangle\fP &theta, float z)"
.br
.ti -1c
.RI "float \fBcylindrical_to_cartesian_3d_z\fP (float p, const \fBangle\fP &theta, float z)"
.br
.ti -1c
.RI "float \fBcylindrical_to_spherical_r\fP (float p, const \fBangle\fP &theta, float z)"
.br
.ti -1c
.RI "\fBangle\fP \fBcylindrical_to_spherical_theta\fP (float p, const \fBangle\fP &theta, float z)"
.br
.ti -1c
.RI "\fBangle\fP \fBcylindrical_to_spherical_phi\fP (float p, const \fBangle\fP &theta, float z)"
.br
.ti -1c
.RI "string \fBto_string\fP (const \fBcoordinates_3dr\fP< float > &x)"
.br
.ti -1c
.RI "float \fBdistance\fP (const \fBcoordinates_3dr\fP< float > &x, const \fBcoordinates_3dr\fP< float > &y)"
.br
.ti -1c
.RI "float \fBdistance\fP (const \fBcoordinates_3dr\fP< float > &x, const \fBcoordinates_3d\fP< float > &y)"
.br
.ti -1c
.RI "float \fBdistance\fP (const \fBcoordinates_3d\fP< float > &x, const \fBcoordinates_3dr\fP< float > &y)"
.br
.ti -1c
.RI "float \fBdistance\fP (const \fBcoordinates_3dr\fP< float > &x, const \fBpoint_3d\fP< float > &y)"
.br
.ti -1c
.RI "float \fBdistance\fP (const \fBpoint_3d\fP< float > &x, const \fBcoordinates_3dr\fP< float > &y)"
.br
.ti -1c
.RI "template<typename T > string \fBto_string\fP (const \fBcoordinates_3dr\fP< T > &x)"
.br
.ti -1c
.RI "template<typename T , typename U > T \fBdistance\fP (const \fBcoordinates_3dr\fP< T > &x, const \fBcoordinates_3dr\fP< U > &y)"
.br
.ti -1c
.RI "template<typename T , typename U > T \fBdistance\fP (const \fBcoordinates_3dr\fP< T > &x, const \fBcoordinates_3d\fP< U > &y)"
.br
.ti -1c
.RI "template<typename T , typename U > T \fBdistance\fP (const \fBcoordinates_3d\fP< T > &x, const \fBcoordinates_3dr\fP< U > &y)"
.br
.ti -1c
.RI "template<typename T , typename U > T \fBdistance\fP (const \fBcoordinates_3dr\fP< T > &x, const \fBpoint_3d\fP< U > &y)"
.br
.ti -1c
.RI "template<typename T , typename U > T \fBdistance\fP (const \fBpoint_3d\fP< T > &x, const \fBcoordinates_3dr\fP< U > &y)"
.br
.ti -1c
.RI "string \fBto_string\fP (const \fBcoordinates_nd\fP< float > &x)"
.br
.ti -1c
.RI "float \fBdistance\fP (const \fBcoordinates_nd\fP< float > &x, const \fBcoordinates_nd\fP< float > &y)"
.br
.ti -1c
.RI "float \fBdistance\fP (const \fBcoordinates_nd\fP< float > &x, const \fBpoint_nd\fP< float > &y)"
.br
.ti -1c
.RI "float \fBdistance\fP (const \fBpoint_nd\fP< float > &x, const \fBcoordinates_nd\fP< float > &y)"
.br
.ti -1c
.RI "template<typename T > string \fBto_string\fP (const \fBcoordinates_nd\fP< T > &x)"
.br
.ti -1c
.RI "template<typename T , typename U > T \fBdistance\fP (const \fBcoordinates_nd\fP< T > &x, const \fBcoordinates_nd\fP< U > &y)"
.br
.ti -1c
.RI "template<typename T , typename U > T \fBdistance\fP (const \fBcoordinates_nd\fP< T > &x, const \fBpoint_nd\fP< U > &y)"
.br
.ti -1c
.RI "template<typename T , typename U > T \fBdistance\fP (const \fBpoint_nd\fP< T > &x, const \fBcoordinates_nd\fP< U > &y)"
.br
.ti -1c
.RI "string \fBto_string\fP (const \fBcoordinates_ndr\fP< float > &x)"
.br
.ti -1c
.RI "float \fBdistance\fP (const \fBcoordinates_ndr\fP< float > &x, const \fBcoordinates_ndr\fP< float > &y)"
.br
.ti -1c
.RI "float \fBdistance\fP (const \fBcoordinates_ndr\fP< float > &x, const \fBcoordinates_nd\fP< float > &y)"
.br
.ti -1c
.RI "float \fBdistance\fP (const \fBcoordinates_nd\fP< float > &x, const \fBcoordinates_ndr\fP< float > &y)"
.br
.ti -1c
.RI "float \fBdistance\fP (const \fBcoordinates_ndr\fP< float > &x, const \fBpoint_nd\fP< float > &y)"
.br
.ti -1c
.RI "float \fBdistance\fP (const \fBpoint_nd\fP< float > &x, const \fBcoordinates_ndr\fP< float > &y)"
.br
.ti -1c
.RI "template<typename T > string \fBto_string\fP (const \fBcoordinates_ndr\fP< T > &x)"
.br
.ti -1c
.RI "template<typename T , typename U > T \fBdistance\fP (const \fBcoordinates_ndr\fP< T > &x, const \fBcoordinates_ndr\fP< U > &y)"
.br
.ti -1c
.RI "template<typename T , typename U > T \fBdistance\fP (const \fBcoordinates_ndr\fP< T > &x, const \fBcoordinates_nd\fP< U > &y)"
.br
.ti -1c
.RI "template<typename T , typename U > T \fBdistance\fP (const \fBcoordinates_nd\fP< T > &x, const \fBcoordinates_ndr\fP< U > &y)"
.br
.ti -1c
.RI "template<typename T , typename U > T \fBdistance\fP (const \fBcoordinates_ndr\fP< T > &x, const \fBpoint_nd\fP< U > &y)"
.br
.ti -1c
.RI "template<typename T , typename U > T \fBdistance\fP (const \fBpoint_nd\fP< T > &x, const \fBcoordinates_ndr\fP< U > &y)"
.br
.ti -1c
.RI "string \fBto_string\fP (const \fBangle\fP &x)"
.br
.RI "Converts an angle to their string representation\&. "
.ti -1c
.RI "bool \fBis_angle\fP (const string &init_angle)"
.br
.RI "Checks if some string is an initialization string of an angle\&. "
.ti -1c
.RI "bool \fBparallel\fP (const \fBangle\fP &x, const \fBangle\fP &y)"
.br
.RI "Checks if two angles in a 2D correspond to parallel lines (or parallel vectors)\&. "
.ti -1c
.RI "bool \fBorthogonal\fP (const \fBangle\fP &x, const \fBangle\fP &y)"
.br
.RI "Checks if two angles in a 2D correspond to orthogonal lines (or orthogonal vectors)\&. "
.ti -1c
.RI "\fBangle\fP \fBsqrt\fP (const \fBangle\fP &x)"
.br
.RI "Calculates the square root of the angle x and returns that new angle\&. "
.ti -1c
.RI "\fBangle\fP \fBsqrt_nth\fP (const \fBangle\fP &x, int index)"
.br
.RI "Calculates the nth root of the angle x and returns that new angle\&. "
.ti -1c
.RI "float \fBsin\fP (const \fBangle\fP &x)"
.br
.RI "Calculates the sin of angle x\&. It uses the \fBsin()\fP function of the standard library of C++, the difference is that angle is in degrees, not in radians\&. "
.ti -1c
.RI "float \fBcos\fP (const \fBangle\fP &x)"
.br
.RI "Calculates the cos of angle x\&. It uses the \fBcos()\fP function of the standard library of C++, the difference is that angle is in degrees, not in radians\&. "
.ti -1c
.RI "float \fBtan\fP (const \fBangle\fP &x)"
.br
.RI "Calculates the tan of angle x\&. It uses the \fBtan()\fP function of the standard library of C++, the difference is that angle is in degrees, not in radians\&. "
.ti -1c
.RI "\fBangle\fP \fBasin\fP (float x)"
.br
.RI "Calculates the asin of some value x and returns the result as angle in degrees\&. "
.ti -1c
.RI "\fBangle\fP \fBacos\fP (float x)"
.br
.RI "Calculates the acos of some value x and returns the result as angle in degrees\&. "
.ti -1c
.RI "\fBangle\fP \fBatan\fP (float x)"
.br
.RI "Calculates the atan of some value x and returns the result as angle in degrees\&. "
.ti -1c
.RI "float \fBsinh\fP (const \fBangle\fP &x)"
.br
.RI "Calculates the sinh of angle x\&. It uses the \fBsinh()\fP function of the standard library of C++, the difference is that angle is in degrees, not in radians\&. "
.ti -1c
.RI "float \fBcosh\fP (const \fBangle\fP &x)"
.br
.RI "Calculates the cosh of angle x\&. It uses the \fBcosh()\fP function of the standard library of C++, the difference is that angle is in degrees, not in radians\&. "
.ti -1c
.RI "float \fBtanh\fP (const \fBangle\fP &x)"
.br
.RI "Calculates the tanh of angle x\&. It uses the \fBtanh()\fP function of the standard library of C++, the difference is that angle is in degrees, not in radians\&. "
.ti -1c
.RI "\fBangle\fP \fBasinh\fP (float x)"
.br
.RI "Calculates the asinh of some value x and returns the result as angle in degrees\&. "
.ti -1c
.RI "\fBangle\fP \fBacosh\fP (float x)"
.br
.RI "Calculates the acosh of some value x and returns the result as angle in degrees\&. "
.ti -1c
.RI "\fBangle\fP \fBatanh\fP (float x)"
.br
.RI "Calculates the atanh of some value x and returns the result as angle in degrees\&. "
.ti -1c
.RI "float \fBradian_to_degree\fP (float x)"
.br
.RI "Converts a radian to degree\&. "
.ti -1c
.RI "float \fBdegree_to_radian\fP (float x)"
.br
.RI "Converts a degree to a radian\&. "
.ti -1c
.RI "float \fBasin_degree\fP (float x)"
.br
.RI "Calculates the asin receiving x in degrees\&. It uses the \fBasin()\fP function of the standard library of C++, but the difference is that the argument is in degrees, not in radians\&. "
.ti -1c
.RI "float \fBacos_degree\fP (float x)"
.br
.RI "Calculates the acos receiving x in degrees\&. It uses the \fBacos()\fP function of the standard library of C++, but the difference is that the argument is in degrees, not in radians\&. "
.ti -1c
.RI "float \fBatan_degree\fP (float x)"
.br
.RI "Calculates the atan receiving x in degrees\&. It uses the \fBatan()\fP function of the standard library of C++, but the difference is that the argument is in degrees, not in radians\&. "
.ti -1c
.RI "float \fBasinh_degree\fP (float x)"
.br
.RI "Calculates the asinh receiving x in degrees\&. It uses the \fBasinh()\fP function of the standard library of C++, but the difference is that the argument is in degrees, not in radians\&. "
.ti -1c
.RI "float \fBacosh_degree\fP (float x)"
.br
.RI "Calculates the acosh receiving x in degrees\&. It uses the \fBacosh()\fP function of the standard library of C++, but the difference is that the argument is in degrees, not in radians\&. "
.ti -1c
.RI "float \fBatanh_degree\fP (float x)"
.br
.RI "Calculates the atanh receiving x in degrees\&. It uses the \fBatanh()\fP function of the standard library of C++, but the difference is that the argument is in degrees, not in radians\&. "
.ti -1c
.RI "bool \fBis_complex\fP (const string &init_complex_number)"
.br
.ti -1c
.RI "template<typename T > string \fBto_string\fP (const \fBcomplex_number\fP< T > &x)"
.br
.ti -1c
.RI "template<typename T > T \fBabs\fP (const \fBcomplex_number\fP< T > &x)"
.br
.ti -1c
.RI "template<typename T > \fBcomplex_number\fP< \fBscalar_unit\fP > \fBsqrt\fP (const \fBcomplex_number\fP< T > &x)"
.br
.ti -1c
.RI "bool \fBis_lab_number\fP (const string &init_lab_number)"
.br
.ti -1c
.RI "template<typename T > string \fBto_string\fP (const \fBlab_number\fP< T > &x)"
.br
.ti -1c
.RI "\fBVECTOR_UNIT_CPP\fP (specific_angular_momentum,'m2/s')"
.br
.ti -1c
.RI "\fBVECTOR_UNIT_HPP\fP (specific_angular_momentum)"
.br
.ti -1c
.RI "\fBSCALAR_UNIT_CPP\fP (density,'g/m3')"
.br
.ti -1c
.RI "\fBSCALAR_UNIT_CPP\fP (viscosity,'m2/s')"
.br
.ti -1c
.RI "\fBSCALAR_UNIT_CPP\fP (specific_volume,'m3/g')"
.br
.ti -1c
.RI "\fBSCALAR_UNIT_CPP\fP (specific_heat_capacity,'m2/s2*K')"
.br
.ti -1c
.RI "\fBSCALAR_UNIT_CPP\fP (specific_entropy,'m2/s2*K')"
.br
.ti -1c
.RI "\fBSCALAR_UNIT_CPP\fP (specific_energy,'m2/s2')"
.br
.ti -1c
.RI "\fBSCALAR_UNIT_CPP\fP (molar_volume,'m3/mol')"
.br
.ti -1c
.RI "\fBSCALAR_UNIT_CPP\fP (molar_mass,'g/mol')"
.br
.ti -1c
.RI "\fBSCALAR_UNIT_CPP\fP (molar_heat_capacity,'m2*g/s2*K*mol')"
.br
.ti -1c
.RI "\fBSCALAR_UNIT_CPP\fP (molar_enthalpy,'m2*g/s2*mol')"
.br
.ti -1c
.RI "\fBSCALAR_UNIT_CPP\fP (molar_entropy,'m2*g/s2*K*mol')"
.br
.ti -1c
.RI "\fBSCALAR_UNIT_CPP\fP (molar_energy,'m2*g/s2*mol')"
.br
.ti -1c
.RI "\fBSCALAR_UNIT_CPP\fP (molar_conductivity,'s3*A2/g*mol')"
.br
.ti -1c
.RI "\fBSCALAR_UNIT_CPP\fP (energy_density,'g/m*s2')"
.br
.ti -1c
.RI "\fBSCALAR_UNIT_CPP\fP (catalytic_efficiency,'m3/s*mol')"
.br
.ti -1c
.RI "\fBSCALAR_UNIT_CPP\fP (molarity,'mol/m3')"
.br
.ti -1c
.RI "\fBSCALAR_UNIT_CPP\fP (molality,'mol/g')"
.br
.ti -1c
.RI "\fBSCALAR_UNIT_CPP\fP (linear_mass_density,'g/m')"
.br
.ti -1c
.RI "\fBSCALAR_UNIT_CPP\fP (area_density,'g/m2')"
.br
.ti -1c
.RI "\fBSCALAR_UNIT_CPP\fP (dynamic_viscosity,'g/m*s')"
.br
.ti -1c
.RI "\fBSCALAR_UNIT_CPP\fP (mass_flow_rate,'g/s')"
.br
.ti -1c
.RI "\fBSCALAR_UNIT_CPP\fP (catalytic_activity,'kat')"
.br
.ti -1c
.RI "\fBSCALAR_UNIT_HPP\fP (density)"
.br
.ti -1c
.RI "\fBSCALAR_UNIT_HPP\fP (viscosity)"
.br
.ti -1c
.RI "\fBSCALAR_UNIT_HPP\fP (specific_volume)"
.br
.ti -1c
.RI "\fBSCALAR_UNIT_HPP\fP (specific_heat_capacity)"
.br
.ti -1c
.RI "\fBSCALAR_UNIT_HPP\fP (specific_entropy)"
.br
.ti -1c
.RI "\fBSCALAR_UNIT_HPP\fP (specific_energy)"
.br
.ti -1c
.RI "\fBSCALAR_UNIT_HPP\fP (molar_volume)"
.br
.ti -1c
.RI "\fBSCALAR_UNIT_HPP\fP (molar_mass)"
.br
.ti -1c
.RI "\fBSCALAR_UNIT_HPP\fP (molar_heat_capacity)"
.br
.ti -1c
.RI "\fBSCALAR_UNIT_HPP\fP (molar_enthalpy)"
.br
.ti -1c
.RI "\fBSCALAR_UNIT_HPP\fP (molar_entropy)"
.br
.ti -1c
.RI "\fBSCALAR_UNIT_HPP\fP (molar_energy)"
.br
.ti -1c
.RI "\fBSCALAR_UNIT_HPP\fP (molar_conductivity)"
.br
.ti -1c
.RI "\fBSCALAR_UNIT_HPP\fP (energy_density)"
.br
.ti -1c
.RI "\fBSCALAR_UNIT_HPP\fP (catalytic_efficiency)"
.br
.ti -1c
.RI "\fBSCALAR_UNIT_HPP\fP (molarity)"
.br
.ti -1c
.RI "\fBSCALAR_UNIT_HPP\fP (molality)"
.br
.ti -1c
.RI "\fBSCALAR_UNIT_HPP\fP (linear_mass_density)"
.br
.ti -1c
.RI "\fBSCALAR_UNIT_HPP\fP (area_density)"
.br
.ti -1c
.RI "\fBSCALAR_UNIT_HPP\fP (dynamic_viscosity)"
.br
.ti -1c
.RI "\fBSCALAR_UNIT_HPP\fP (mass_flow_rate)"
.br
.ti -1c
.RI "\fBSCALAR_UNIT_HPP\fP (catalytic_activity)"
.br
.ti -1c
.RI "\fBSCALAR_UNIT_CPP\fP (electrical_conductivity,'A2*s3/kg*m3')"
.br
.ti -1c
.RI "\fBSCALAR_UNIT_CPP\fP (resistance,'kg*m2/A2*s3')"
.br
.ti -1c
.RI "\fBSCALAR_UNIT_CPP\fP (electric_conductance,'A2*s3/kg*m2')"
.br
.ti -1c
.RI "\fBSCALAR_UNIT_CPP\fP (capacitance,'A2*s4/m2*kg')"
.br
.ti -1c
.RI "\fBSCALAR_UNIT_CPP\fP (permittivity,'A2*s4/kg*m3')"
.br
.ti -1c
.RI "\fBSCALAR_UNIT_CPP\fP (resistivity,'kg*m3/A2*s3')"
.br
.ti -1c
.RI "\fBSCALAR_UNIT_CPP\fP (linear_charge_density,'A*s/m')"
.br
.ti -1c
.RI "\fBSCALAR_UNIT_CPP\fP (frequency_drift,'1/s2')"
.br
.ti -1c
.RI "\fBSCALAR_UNIT_HPP\fP (electrical_conductivity)"
.br
.ti -1c
.RI "\fBSCALAR_UNIT_HPP\fP (resistance)"
.br
.ti -1c
.RI "\fBSCALAR_UNIT_HPP\fP (electric_conductance)"
.br
.ti -1c
.RI "\fBSCALAR_UNIT_HPP\fP (capacitance)"
.br
.ti -1c
.RI "\fBSCALAR_UNIT_HPP\fP (permittivity)"
.br
.ti -1c
.RI "\fBSCALAR_UNIT_HPP\fP (resistivity)"
.br
.ti -1c
.RI "\fBSCALAR_UNIT_HPP\fP (linear_charge_density)"
.br
.ti -1c
.RI "\fBSCALAR_UNIT_HPP\fP (frequency_drift)"
.br
.ti -1c
.RI "\fBSCALAR_UNIT_CPP\fP (transfer_speed,'B/s')"
.br
.ti -1c
.RI "\fBSCALAR_UNIT_HPP\fP (transfer_speed)"
.br
.ti -1c
.RI "\fBVECTOR_UNIT_2D_CPP\fP (displacement,'m')"
.br
.ti -1c
.RI "\fBVECTOR_UNIT_3D_CPP\fP (displacement,'m')"
.br
.ti -1c
.RI "\fBVECTOR_UNIT_ND_CPP\fP (displacement,'m')"
.br
.ti -1c
.RI "\fBVECTOR_UNIT_CPP\fP (velocity,'m/s')"
.br
.ti -1c
.RI "\fBVECTOR_UNIT_CPP\fP (acceleration,'m/s2')"
.br
.ti -1c
.RI "\fBVECTOR_UNIT_CPP\fP (jerk,'m/s3')"
.br
.ti -1c
.RI "\fBVECTOR_UNIT_CPP\fP (snap,'m/s4')"
.br
.ti -1c
.RI "\fBVECTOR_UNIT_CPP\fP (angular_velocity,'rad/s')"
.br
.ti -1c
.RI "\fBVECTOR_UNIT_CPP\fP (angular_acceleration,'rad/s2')"
.br
.ti -1c
.RI "\fBVECTOR_UNIT_CPP\fP (angular_momentum,'m2*kg/s')"
.br
.ti -1c
.RI "\fBVECTOR_UNIT_CPP\fP (impulse,'m*kg/s')"
.br
.ti -1c
.RI "\fBVECTOR_UNIT_CPP\fP (force,'kg*m/s2')"
.br
.ti -1c
.RI "\fBVECTOR_UNIT_CPP\fP (torque,'kg*m2/s2')"
.br
.ti -1c
.RI "\fBVECTOR_UNIT_CPP\fP (pressure,'kg/m*s2')"
.br
.ti -1c
.RI "\fBVECTOR_UNIT_CPP\fP (surface_tension,'kg/s2')"
.br
.ti -1c
.RI "\fBSCALAR_UNIT_CPP\fP (stiffness,'kg/s2')"
.br
.ti -1c
.RI "\fBSCALAR_UNIT_CPP\fP (moment_of_inertia,'m2*kg')"
.br
.ti -1c
.RI "\fBSCALAR_UNIT_CPP\fP (electric_current,'A')"
.br
.ti -1c
.RI "\fBSCALAR_UNIT_CPP\fP (voltage,'V')"
.br
.ti -1c
.RI "\fBVECTOR_UNIT_CPP\fP (electric_displacement_field,'A*s/m2')"
.br
.ti -1c
.RI "\fBSCALAR_UNIT_CPP\fP (electric_charge_density,'A*s/m3')"
.br
.ti -1c
.RI "\fBSCALAR_UNIT_CPP\fP (electric_current_density,'A/m2')"
.br
.ti -1c
.RI "\fBVECTOR_UNIT_CPP\fP (electric_field_strength,'kg*m/A*s3')"
.br
.ti -1c
.RI "\fBSCALAR_UNIT_CPP\fP (electron_mobility,'A*s2/kg')"
.br
.ti -1c
.RI "\fBSCALAR_UNIT_CPP\fP (inductance,'H')"
.br
.ti -1c
.RI "\fBSCALAR_UNIT_CPP\fP (volumetric_flow,'m3/s')"
.br
.ti -1c
.RI "\fBSCALAR_UNIT_CPP\fP (diffusion_coefficient,'m2/s')"
.br
.ti -1c
.RI "\fBSCALAR_UNIT_CPP\fP (compressibility,'m*s2/kg')"
.br
.ti -1c
.RI "\fBSCALAR_UNIT_CPP\fP (polarization_density,'A*s/m2')"
.br
.ti -1c
.RI "\fBSCALAR_UNIT_CPP\fP (magnetic_permeability,'A2*s2/kg*m')"
.br
.ti -1c
.RI "\fBSCALAR_UNIT_CPP\fP (magnetization,'A/m')"
.br
.ti -1c
.RI "\fBSCALAR_UNIT_CPP\fP (magnetic_flux,'Wb')"
.br
.ti -1c
.RI "\fBVECTOR_UNIT_CPP\fP (magnetic_strength,'Wb/m2')"
.br
.ti -1c
.RI "\fBVECTOR_UNIT_CPP\fP (magnetic_moment,'A*m2')"
.br
.ti -1c
.RI "\fBSCALAR_UNIT_CPP\fP (magnetic_reluctance,'A2*s2/kg*m2')"
.br
.ti -1c
.RI "\fBVECTOR_UNIT_CPP\fP (magnetic_vector_potential,'kg*m/A*s2')"
.br
.ti -1c
.RI "\fBSCALAR_UNIT_CPP\fP (magnetic_rigidity,'kg*m/A*s2')"
.br
.ti -1c
.RI "\fBVECTOR_UNIT_CPP\fP (magnetomotive_force,'A')"
.br
.ti -1c
.RI "\fBSCALAR_UNIT_CPP\fP (magnetic_susceptibility,'A2*s2/kg*m')"
.br
.ti -1c
.RI "\fBSCALAR_UNIT_CPP\fP (optical_power,'1/m')"
.br
.ti -1c
.RI "\fBSCALAR_UNIT_CPP\fP (luminance,'cd/m2')"
.br
.ti -1c
.RI "\fBSCALAR_UNIT_CPP\fP (illuminance,'lx')"
.br
.ti -1c
.RI "\fBSCALAR_UNIT_CPP\fP (luminous_flux,'lm')"
.br
.ti -1c
.RI "\fBSCALAR_UNIT_CPP\fP (luminous_energy,'cd*sr*s')"
.br
.ti -1c
.RI "\fBSCALAR_UNIT_CPP\fP (luminous_exposure,'cd*sr*s/m2')"
.br
.ti -1c
.RI "\fBSCALAR_UNIT_CPP\fP (luminous_efficacy,'lm/W')"
.br
.ti -1c
.RI "\fBSCALAR_UNIT_CPP\fP (ionizing_radiation,'A*s/kg')"
.br
.ti -1c
.RI "\fBSCALAR_UNIT_CPP\fP (absorbed_dose,'m2/s3')"
.br
.ti -1c
.RI "\fBSCALAR_UNIT_CPP\fP (energy,'kg*m2/s2')"
.br
.ti -1c
.RI "\fBSCALAR_UNIT_CPP\fP (action,'kg*m2/s')"
.br
.ti -1c
.RI "\fBSCALAR_UNIT_CPP\fP (power,'kg*m2/s3')"
.br
.ti -1c
.RI "\fBSCALAR_UNIT_CPP\fP (power_density,'kg/m*s3')"
.br
.ti -1c
.RI "\fBSCALAR_UNIT_CPP\fP (enthalpy,'kg*m2/s2')"
.br
.ti -1c
.RI "\fBSCALAR_UNIT_CPP\fP (entropy,'kg*m2/K*s2')"
.br
.ti -1c
.RI "\fBSCALAR_UNIT_CPP\fP (heat_capacity,'kg*m2/K*s2')"
.br
.ti -1c
.RI "\fBSCALAR_UNIT_CPP\fP (heat_flux_density,'kg/s3')"
.br
.ti -1c
.RI "\fBSCALAR_UNIT_CPP\fP (thermal_conductivity,'kg*m/K*s3')"
.br
.ti -1c
.RI "\fBSCALAR_UNIT_CPP\fP (thermal_diffusivity,'m2/s')"
.br
.ti -1c
.RI "\fBSCALAR_UNIT_CPP\fP (thermal_resistance,'K*s3/kg*m2')"
.br
.ti -1c
.RI "\fBSCALAR_UNIT_CPP\fP (thermal_expansion_coefficient,'1/K')"
.br
.ti -1c
.RI "\fBVECTOR_UNIT_CPP\fP (temperature_gradient,'K/m')"
.br
.ti -1c
.RI "\fBSCALAR_UNIT_CPP\fP (energy_flux_density,'kg/s3')"
.br
.ti -1c
.RI "\fBSCALAR_UNIT_CPP\fP (wavenumber,'1/m')"
.br
.ti -1c
.RI "\fBSCALAR_UNIT_CPP\fP (frequency,'1/s')"
.br
.ti -1c
.RI "\fBVECTOR_UNIT_2D_HPP\fP (displacement)"
.br
.ti -1c
.RI "\fBVECTOR_UNIT_3D_HPP\fP (displacement)"
.br
.ti -1c
.RI "\fBVECTOR_UNIT_ND_HPP\fP (displacement)"
.br
.ti -1c
.RI "\fBVECTOR_UNIT_HPP\fP (velocity)"
.br
.ti -1c
.RI "\fBVECTOR_UNIT_HPP\fP (acceleration)"
.br
.ti -1c
.RI "\fBVECTOR_UNIT_HPP\fP (jerk)"
.br
.ti -1c
.RI "\fBVECTOR_UNIT_HPP\fP (snap)"
.br
.ti -1c
.RI "\fBVECTOR_UNIT_HPP\fP (angular_velocity)"
.br
.ti -1c
.RI "\fBVECTOR_UNIT_HPP\fP (angular_acceleration)"
.br
.ti -1c
.RI "\fBVECTOR_UNIT_HPP\fP (angular_momentum)"
.br
.ti -1c
.RI "\fBVECTOR_UNIT_HPP\fP (impulse)"
.br
.ti -1c
.RI "\fBVECTOR_UNIT_HPP\fP (force)"
.br
.ti -1c
.RI "\fBVECTOR_UNIT_HPP\fP (torque)"
.br
.ti -1c
.RI "\fBVECTOR_UNIT_HPP\fP (pressure)"
.br
.ti -1c
.RI "\fBVECTOR_UNIT_HPP\fP (surface_tension)"
.br
.ti -1c
.RI "\fBSCALAR_UNIT_HPP\fP (stiffness)"
.br
.ti -1c
.RI "\fBSCALAR_UNIT_HPP\fP (moment_of_inertia)"
.br
.ti -1c
.RI "\fBSCALAR_UNIT_HPP\fP (electric_current)"
.br
.ti -1c
.RI "\fBSCALAR_UNIT_HPP\fP (voltage)"
.br
.ti -1c
.RI "\fBVECTOR_UNIT_HPP\fP (electric_displacement_field)"
.br
.ti -1c
.RI "\fBSCALAR_UNIT_HPP\fP (electric_charge_density)"
.br
.ti -1c
.RI "\fBSCALAR_UNIT_HPP\fP (electric_current_density)"
.br
.ti -1c
.RI "\fBVECTOR_UNIT_HPP\fP (electric_field_strength)"
.br
.ti -1c
.RI "\fBSCALAR_UNIT_HPP\fP (electron_mobility)"
.br
.ti -1c
.RI "\fBSCALAR_UNIT_HPP\fP (inductance)"
.br
.ti -1c
.RI "\fBSCALAR_UNIT_HPP\fP (volumetric_flow)"
.br
.ti -1c
.RI "\fBSCALAR_UNIT_HPP\fP (diffusion_coefficient)"
.br
.ti -1c
.RI "\fBSCALAR_UNIT_HPP\fP (compressibility)"
.br
.ti -1c
.RI "\fBSCALAR_UNIT_HPP\fP (polarization_density)"
.br
.ti -1c
.RI "\fBSCALAR_UNIT_HPP\fP (magnetic_permeability)"
.br
.ti -1c
.RI "\fBSCALAR_UNIT_HPP\fP (magnetization)"
.br
.ti -1c
.RI "\fBSCALAR_UNIT_HPP\fP (magnetic_flux)"
.br
.ti -1c
.RI "\fBVECTOR_UNIT_HPP\fP (magnetic_strength)"
.br
.ti -1c
.RI "\fBVECTOR_UNIT_HPP\fP (magnetic_moment)"
.br
.ti -1c
.RI "\fBSCALAR_UNIT_HPP\fP (magnetic_reluctance)"
.br
.ti -1c
.RI "\fBVECTOR_UNIT_HPP\fP (magnetic_vector_potential)"
.br
.ti -1c
.RI "\fBSCALAR_UNIT_HPP\fP (magnetic_rigidity)"
.br
.ti -1c
.RI "\fBVECTOR_UNIT_HPP\fP (magnetomotive_force)"
.br
.ti -1c
.RI "\fBSCALAR_UNIT_HPP\fP (magnetic_susceptibility)"
.br
.ti -1c
.RI "\fBSCALAR_UNIT_HPP\fP (optical_power)"
.br
.ti -1c
.RI "\fBSCALAR_UNIT_HPP\fP (luminance)"
.br
.ti -1c
.RI "\fBSCALAR_UNIT_HPP\fP (illuminance)"
.br
.ti -1c
.RI "\fBSCALAR_UNIT_HPP\fP (luminous_flux)"
.br
.ti -1c
.RI "\fBSCALAR_UNIT_HPP\fP (luminous_energy)"
.br
.ti -1c
.RI "\fBSCALAR_UNIT_HPP\fP (luminous_exposure)"
.br
.ti -1c
.RI "\fBSCALAR_UNIT_HPP\fP (luminous_efficacy)"
.br
.ti -1c
.RI "\fBSCALAR_UNIT_HPP\fP (ionizing_radiation)"
.br
.ti -1c
.RI "\fBSCALAR_UNIT_HPP\fP (absorbed_dose)"
.br
.ti -1c
.RI "\fBSCALAR_UNIT_HPP\fP (energy)"
.br
.ti -1c
.RI "\fBSCALAR_UNIT_HPP\fP (action)"
.br
.ti -1c
.RI "\fBSCALAR_UNIT_HPP\fP (power)"
.br
.ti -1c
.RI "\fBSCALAR_UNIT_HPP\fP (power_density)"
.br
.ti -1c
.RI "\fBSCALAR_UNIT_HPP\fP (enthalpy)"
.br
.ti -1c
.RI "\fBSCALAR_UNIT_HPP\fP (entropy)"
.br
.ti -1c
.RI "\fBSCALAR_UNIT_HPP\fP (heat_capacity)"
.br
.ti -1c
.RI "\fBSCALAR_UNIT_HPP\fP (heat_flux_density)"
.br
.ti -1c
.RI "\fBSCALAR_UNIT_HPP\fP (thermal_conductivity)"
.br
.ti -1c
.RI "\fBSCALAR_UNIT_HPP\fP (thermal_diffusivity)"
.br
.ti -1c
.RI "\fBSCALAR_UNIT_HPP\fP (thermal_resistance)"
.br
.ti -1c
.RI "\fBSCALAR_UNIT_HPP\fP (thermal_expansion_coefficient)"
.br
.ti -1c
.RI "\fBVECTOR_UNIT_HPP\fP (temperature_gradient)"
.br
.ti -1c
.RI "\fBSCALAR_UNIT_HPP\fP (energy_flux_density)"
.br
.ti -1c
.RI "\fBSCALAR_UNIT_HPP\fP (wavenumber)"
.br
.ti -1c
.RI "\fBSCALAR_UNIT_HPP\fP (frequency)"
.br
.ti -1c
.RI "\fBSCALAR_UNIT_CPP\fP (radioactivity,'Bq')"
.br
.ti -1c
.RI "\fBVECTOR_UNIT_CPP\fP (irradiance,'kg/s3')"
.br
.ti -1c
.RI "\fBVECTOR_UNIT_CPP\fP (radiant_exposure,'kg/s2')"
.br
.ti -1c
.RI "\fBSCALAR_UNIT_CPP\fP (radiant_intensity,'kg*m2/s3')"
.br
.ti -1c
.RI "\fBSCALAR_UNIT_CPP\fP (spectral_intensity,'kg*m/s3')"
.br
.ti -1c
.RI "\fBSCALAR_UNIT_CPP\fP (radiance,'kg/s3')"
.br
.ti -1c
.RI "\fBSCALAR_UNIT_CPP\fP (spectral_radiance,'kg/m*s3')"
.br
.ti -1c
.RI "\fBVECTOR_UNIT_CPP\fP (radiant_flux,'kg*m2/s3')"
.br
.ti -1c
.RI "\fBVECTOR_UNIT_CPP\fP (spectral_flux,'kg*m/s3')"
.br
.ti -1c
.RI "\fBSCALAR_UNIT_HPP\fP (radioactivity)"
.br
.ti -1c
.RI "\fBVECTOR_UNIT_HPP\fP (irradiance)"
.br
.ti -1c
.RI "\fBVECTOR_UNIT_HPP\fP (radiant_exposure)"
.br
.ti -1c
.RI "\fBSCALAR_UNIT_HPP\fP (radiant_intensity)"
.br
.ti -1c
.RI "\fBSCALAR_UNIT_HPP\fP (spectral_intensity)"
.br
.ti -1c
.RI "\fBSCALAR_UNIT_HPP\fP (radiance)"
.br
.ti -1c
.RI "\fBSCALAR_UNIT_HPP\fP (spectral_radiance)"
.br
.ti -1c
.RI "\fBVECTOR_UNIT_HPP\fP (radiant_flux)"
.br
.ti -1c
.RI "\fBVECTOR_UNIT_HPP\fP (spectral_flux)"
.br
.ti -1c
.RI "\fBSCALAR_UNIT_CPP\fP (\fBarea\fP,'m2')"
.br
.ti -1c
.RI "\fBSCALAR_UNIT_CPP\fP (\fBvolume\fP,'m3')"
.br
.ti -1c
.RI "\fBSCALAR_UNIT_CPP\fP (volume_4d,'m4')"
.br
.ti -1c
.RI "\fBSCALAR_UNIT_CPP\fP (curvature,'1/m')"
.br
.ti -1c
.RI "\fBSCALAR_UNIT_HPP_BEGIN\fP (\fBarea\fP)"
.br
.ti -1c
.RI "\fBarea\fP (const \fBsize_2d\fP< length > &)"
.br
.ti -1c
.RI "\fBSCALAR_UNIT_HPP_END\fP ()"
.br
.ti -1c
.RI "\fBSCALAR_UNIT_HPP_BEGIN\fP (\fBvolume\fP)"
.br
.ti -1c
.RI "\fBvolume\fP (const \fBsize_3d\fP< length > &)"
.br
.ti -1c
.RI "\fBSCALAR_UNIT_HPP\fP (volume_4d)"
.br
.ti -1c
.RI "\fBSCALAR_UNIT_HPP\fP (curvature)"
.br
.ti -1c
.RI "string \fBto_string\fP (const \fBaid\fP &x)"
.br
.ti -1c
.RI "string \fBto_string\fP (const \fBaid::type\fP &x)"
.br
.ti -1c
.RI "\fBaid::type\fP \fBcreate_astronomical_type\fP (const string &astronomical_type_abbreviation)"
.br
.ti -1c
.RI "string \fBto_string\fP (const \fBfeeling\fP &)"
.br
.ti -1c
.RI "string \fBto_string\fP (const \fBemotion\fP &)"
.br
.ti -1c
.RI "string \fBto_string\fP (const \fBsensation\fP &)"
.br
.ti -1c
.RI "string \fBto_string\fP (const \fBpercentage\fP &x)"
.br
.ti -1c
.RI "bool \fBis_percentage\fP (const string &init_percentage)"
.br
.ti -1c
.RI "string \fBto_string\fP (const \fBpH\fP &x)"
.br
.ti -1c
.RI "string \fBto_string\fP (const \fBpixel\fP &x)"
.br
.ti -1c
.RI "bool \fBis_pixel\fP (const string &init_pixel)"
.br
.ti -1c
.RI "\fBpixel\fP \fBsqrt\fP (const \fBpixel\fP &x)"
.br
.ti -1c
.RI "\fBpixel\fP \fBsqrt_nth\fP (const \fBpixel\fP &x, int index)"
.br
.ti -1c
.RI "string \fBto_string\fP (const \fBpOH\fP &x)"
.br
.ti -1c
.RI "string \fBto_string\fP (const \fBsize_2d\fP< float > &x)"
.br
.ti -1c
.RI "template<typename T > string \fBto_string\fP (const \fBsize_2d\fP< T > &x)"
.br
.ti -1c
.RI "string \fBto_string\fP (const \fBsize_3d\fP< float > &x)"
.br
.ti -1c
.RI "template<typename T > string \fBto_string\fP (const \fBsize_3d\fP< T > &x)"
.br
.ti -1c
.RI "string \fBto_string\fP (const \fBsize_nd\fP< float > &x)"
.br
.ti -1c
.RI "template<typename T > string \fBto_string\fP (const \fBsize_nd\fP< T > &x)"
.br
.ti -1c
.RI "string \fBto_string\fP (const \fBzid\fP &x)"
.br
.ti -1c
.RI "\fBdirection::name\fP \fBcreate_direction\fP (const string &x)"
.br
.ti -1c
.RI "\fBdirection::name\fP \fBinvert\fP (\fBdirection::name\fP x)"
.br
.ti -1c
.RI "string \fBto_string\fP (\fBdirection::name\fP x)"
.br
.ti -1c
.RI "string \fBto_string\fP (const \fBdirection\fP &x)"
.br
.ti -1c
.RI "string \fBto_string\fP (const \fBpoint_1d\fP< float > &x)"
.br
.ti -1c
.RI "float \fBdistance\fP (const \fBpoint_1d\fP< float > &x, const \fBpoint_1d\fP< float > &y)"
.br
.ti -1c
.RI "template<typename T > string \fBto_string\fP (const \fBpoint_1d\fP< T > &x)"
.br
.ti -1c
.RI "template<typename T , typename U > T \fBdistance\fP (const \fBpoint_1d\fP< T > &x, const \fBpoint_1d\fP< U > &y)"
.br
.ti -1c
.RI "string \fBto_string\fP (const \fBpoint_2d\fP< float > &x)"
.br
.ti -1c
.RI "float \fBdistance\fP (const \fBpoint_2d\fP< float > &x, const \fBpoint_2d\fP< float > &y)"
.br
.ti -1c
.RI "template<typename T > string \fBto_string\fP (const \fBpoint_2d\fP< T > &x)"
.br
.ti -1c
.RI "template<typename T , typename U > T \fBdistance\fP (const \fBpoint_2d\fP< T > &x, const \fBpoint_2d\fP< U > &y)"
.br
.ti -1c
.RI "string \fBto_string\fP (const \fBpoint_3d\fP< float > &x)"
.br
.ti -1c
.RI "float \fBdistance\fP (const \fBpoint_3d\fP< float > &x, const \fBpoint_3d\fP< float > &y)"
.br
.ti -1c
.RI "template<typename T > string \fBto_string\fP (const \fBpoint_3d\fP< T > &x)"
.br
.ti -1c
.RI "template<typename T , typename U > T \fBdistance\fP (const \fBpoint_3d\fP< T > &x, const \fBpoint_3d\fP< U > &y)"
.br
.ti -1c
.RI "string \fBto_string\fP (const \fBpoint_nd\fP< float > &x)"
.br
.ti -1c
.RI "float \fBdistance\fP (const \fBpoint_nd\fP< float > &x, const \fBpoint_nd\fP< float > &y)"
.br
.ti -1c
.RI "template<typename T > string \fBto_string\fP (const \fBpoint_nd\fP< T > &x)"
.br
.ti -1c
.RI "template<typename T , typename U > T \fBdistance\fP (const \fBpoint_nd\fP< T > &x1, const \fBpoint_nd\fP< U > &x2)"
.br
.ti -1c
.RI "string \fBto_string\fP (const \fBdimension\fP &x)"
.br
.RI "Creates the string representation of a dimension\&. "
.ti -1c
.RI "string \fBto_string\fP (const vector< \fBdimension\fP > &x_dimensions, bool with_brackets)"
.br
.RI "Creates the string representation of a vector of dimensions\&. Used to display the dimensions of \fBscalar_unit\fP and all vector_unit classes\&. The dimensions can be displayed optionally between brackets like '[]' too\&. "
.ti -1c
.RI "vector< \fBdimension\fP > \fBcreate_dimensions\fP (string init_dimensions)"
.br
.RI "Creates the dimensions from an initialization string of dimensions\&. "
.ti -1c
.RI "vector< \fBdimension\fP > \fBcreate_derived_dimensions\fP (const string &init_dimensions)"
.br
.RI "Creates the derived dimensions from an initialization string of dimensions\&. "
.ti -1c
.RI "vector< \fBdimension\fP > \fBcreate_derived_dimensions\fP (const vector< \fBdimension\fP > &x)"
.br
.RI "Creates all the derived dimensions from a vector of dimensions\&. "
.ti -1c
.RI "vector< \fBdimension\fP > \fBcreate_derived_dimensions\fP (const vector< \fBdimension\fP > &x, long double &value)"
.br
.RI "Creates all the derived dimensions from a vector of dimensions, updating also the associated value related to those dimensions based on the prefix math and the conversion factor of the dimension, if that conversion factor is different than one\&. "
.ti -1c
.RI "vector< \fBdimension\fP > \fBmultiply_dimensions\fP (const vector< \fBdimension\fP > &x, const vector< \fBdimension\fP > &y)"
.br
.RI "Multiplies two vectors of dimensions\&. The result is normalized after, which means that equal dimensions at the numerator and at the denominator are cancelled\&. "
.ti -1c
.RI "vector< \fBdimension\fP > \fBmultiply_dimensions\fP (vector< \fBdimension\fP > x, const vector< \fBdimension\fP > &y, long double &value)"
.br
.RI "Multiplies two vectors of dimensions\&. The result is normalized after, which means that equal dimensions at the numerator and at the denominator are cancelled\&. It also updates the value associated with those two vectors of dimensions with the prefix m ath and the conversion factor of those dimensions\&. "
.ti -1c
.RI "vector< \fBdimension\fP > \fBdivide_dimensions\fP (vector< \fBdimension\fP > x, const vector< \fBdimension\fP > &y, long double &value)"
.br
.RI "Divides the first vector of dimensions with the other\&. The result is normalized after, which means that equal dimensions at the numerator and at the denominator are cancelled\&. It also updates the value associated with those two vectors of dimensions with the prefix m ath and the conversion factor of those dimensions\&. "
.ti -1c
.RI "vector< \fBdimension\fP > \fBsquare_dimensions\fP (vector< \fBdimension\fP > x, long double &value, int index)"
.br
.RI "Squares a vector of dimensions by an index\&. The value is updated too related to the prefix math and the conversion factor of this operation\&. "
.ti -1c
.RI "vector< \fBdimension\fP > \fBpower_dimensions\fP (const vector< \fBdimension\fP > &x, int exponent)"
.br
.RI "Powers the dimensions by an exponent\&. "
.ti -1c
.RI "vector< \fBdimension\fP > \fBnormalize_dimensions\fP (const vector< \fBdimension\fP > &x)"
.br
.RI "Normalizes the dimensions, which means that repited dimensions at the numerator and at the denominator are cancelled\&. "
.ti -1c
.RI "vector< \fBdimension\fP > \fBnormalize_dimensions\fP (const vector< \fBdimension\fP > &x, long double &value)"
.br
.RI "Normalizes the dimensions, which means that repited dimensions at the numerator and at the denominator are cancelled\&. The value is updated if there are dimensions cancelled\&. "
.ti -1c
.RI "bool \fBcommon_dimension\fP (const \fBdimension\fP &x, const \fBdimension\fP &y)"
.br
.RI "Checks if there's an equal basic dimension between the basic dimensions of those two dimensions\&. "
.ti -1c
.RI "bool \fBequal_dimensions\fP (const string &init_dimensions_x, const string &init_dimensions_y)"
.br
.RI "Checks if two initialization strings of dimensions initialize the same basic dimensions\&. "
.ti -1c
.RI "bool \fBequal_dimensions\fP (const vector< \fBdimension\fP > &x, const vector< \fBdimension\fP > &y)"
.br
.ti -1c
.RI "bool \fBequal_dimensions_and_prefixes\fP (const vector< \fBdimension\fP > &x, const vector< \fBdimension\fP > &y)"
.br
.RI "Checks if the derived dimensions of two vectors of dimensions are equal, and if they have also the same prefixes\&. "
.ti -1c
.RI "\fBprefix::type\fP \fBprefix_string\fP (const string &x)"
.br
.RI "Returns the value of the enum \fBprefix::type\fP associated with the string x given\&. "
.ti -1c
.RI "\fBprefix\fP \fBclosest_prefix\fP (const \fBprefix\fP &actual_prefix, int actual_scale)"
.br
.RI "Returns the closes prefix related to the scale of the current value\&. It is used when displaying a \fBscalar_unit\fP to the most close prefix available\&. "
.ti -1c
.RI "\fBprefix\fP \fBcreate_prefix_by_factor\fP (int factor)"
.br
.RI "Creates the prefix of the factor given, which is always between a range\&. "
.ti -1c
.RI "string \fBto_string\fP (const \fBscalar_unit\fP &x)"
.br
.RI "Generates an string representation of the \fBscalar_unit\fP, it uses the display of the \fBscalar_unit\fP with 2 decimals, without brackets and without a close prefix\&. "
.ti -1c
.RI "bool \fBis_scalar_unit\fP (const string &init_scalar)"
.br
.RI "Checks if an string is an initialization string of a \fBscalar_unit\fP\&. "
.ti -1c
.RI "float \fBabs\fP (const \fBscalar_unit\fP &x)"
.br
.RI "Returns the absolute value of the \fBscalar_unit\fP, without dimensions\&. "
.ti -1c
.RI "\fBscalar_unit\fP \fBpow\fP (const \fBscalar_unit\fP &x, int exponent)"
.br
.RI "Exponentiates a \fBscalar_unit\fP to some numeric type, the dimensions are also exponentiated\&. "
.ti -1c
.RI "\fBscalar_unit\fP \fBsqrt\fP (const \fBscalar_unit\fP &x)"
.br
.RI "Square root of a \fBscalar_unit\fP, it squares the dimensions too\&. "
.ti -1c
.RI "\fBscalar_unit\fP \fBsqrt_nth\fP (const \fBscalar_unit\fP &x, int index)"
.br
.RI "Nth root of a \fBscalar_unit\fP to any numeric value, it squares the dimensions too\&. "
.ti -1c
.RI "\fBSCALAR_UNIT_CPP\fP (length,'m')"
.br
.ti -1c
.RI "\fBSCALAR_UNIT_CPP\fP (\fBtime_duration\fP,'s')"
.br
.ti -1c
.RI "\fBSCALAR_UNIT_CPP\fP (\fBmass\fP,'g')"
.br
.ti -1c
.RI "\fBSCALAR_UNIT_CPP\fP (charge,'C')"
.br
.ti -1c
.RI "\fBSCALAR_UNIT_CPP\fP (temperature,'K')"
.br
.ti -1c
.RI "\fBSCALAR_UNIT_CPP\fP (\fBmole\fP,'mol')"
.br
.ti -1c
.RI "\fBSCALAR_UNIT_CPP\fP (light,'cd')"
.br
.ti -1c
.RI "\fBSCALAR_UNIT_CPP\fP (data,'B')"
.br
.ti -1c
.RI "\fBSCALAR_UNIT_HPP\fP (length)"
.br
.ti -1c
.RI "\fBSCALAR_UNIT_HPP_BEGIN\fP (\fBtime_duration\fP)"
.br
.ti -1c
.RI "\fBtime_duration\fP (const string &init_time)"
.br
.ti -1c
.RI "int \fBget_years\fP () const"
.br
.ti -1c
.RI "int \fBget_months\fP () const"
.br
.ti -1c
.RI "int \fBget_weeks\fP () const"
.br
.ti -1c
.RI "int \fBget_days\fP () const"
.br
.ti -1c
.RI "int \fBget_hours\fP () const"
.br
.ti -1c
.RI "int \fBget_minutes\fP () const"
.br
.ti -1c
.RI "int \fBget_seconds\fP () const"
.br
.ti -1c
.RI "string \fBget_finish_date\fP () const"
.br
.ti -1c
.RI "string \fBdisplay_as_time\fP () const"
.br
.ti -1c
.RI "string \fBdisplay_years\fP () const"
.br
.ti -1c
.RI "string \fBdisplay_months\fP () const"
.br
.ti -1c
.RI "string \fBdisplay_weeks\fP () const"
.br
.ti -1c
.RI "string \fBdisplay_days\fP () const"
.br
.ti -1c
.RI "string \fBdisplay_hours\fP () const"
.br
.ti -1c
.RI "string \fBdisplay_minutes\fP () const"
.br
.ti -1c
.RI "string \fBdisplay_seconds\fP () const"
.br
.ti -1c
.RI "template<typename T1 , typename T2 > \fBscifir::time_duration\fP & \fBoperator+=\fP (chrono::duration< T1, T2 > x)"
.br
.ti -1c
.RI "template<typename T1 , typename T2 > \fBscifir::time_duration\fP & \fBoperator\-=\fP (chrono::duration< T1, T2 > x)"
.br
.ti -1c
.RI "\fBSCALAR_UNIT_HPP_BEGIN\fP (\fBmass\fP)"
.br
.ti -1c
.RI "\fBmass\fP (const \fBpercentage\fP &new_percentage, const mass &new_mass)"
.br
.ti -1c
.RI "\fBmass\fP (const string &init_percentage, const string &init_mass)"
.br
.ti -1c
.RI "\fBSCALAR_UNIT_HPP\fP (charge)"
.br
.ti -1c
.RI "\fBSCALAR_UNIT_HPP\fP (temperature)"
.br
.ti -1c
.RI "\fBSCALAR_UNIT_HPP_BEGIN\fP (\fBmole\fP)"
.br
.ti -1c
.RI "\fBmole\fP (const \fBpercentage\fP &new_percentage, const mole &new_mole)"
.br
.ti -1c
.RI "\fBmole\fP (const string &init_percentage, const string &init_mole)"
.br
.ti -1c
.RI "int \fBnumber_of_particles\fP () const"
.br
.ti -1c
.RI "\fBSCALAR_UNIT_HPP\fP (light)"
.br
.ti -1c
.RI "\fBSCALAR_UNIT_HPP\fP (data)"
.br
.ti -1c
.RI "\fBscalar_unit\fP \fBnorm\fP (const \fBvector_unit_2d\fP &x)"
.br
.RI "It returns the value of the vector in polar coordinates, p\&. "
.ti -1c
.RI "\fBvector_unit_2d\fP \fBsqrt\fP (const \fBvector_unit_2d\fP &x)"
.br
.RI "It squares the vector, creating a \fBvector_unit_2d\fP with the value squared and always the same theta\&. The dimensions are squared with the same rules for the square of dimensions than \fBscalar_unit\fP classes\&. "
.ti -1c
.RI "\fBvector_unit_2d\fP \fBsqrt_nth\fP (const \fBvector_unit_2d\fP &x, int index)"
.br
.RI "It takes the root of the vector with the index given, creating a \fBvector_unit_2d\fP with the value rooted to that index and always maintains the same theta\&. The dimensions are squared with the same rules for the square of dimensions than \fBscalar_unit\fP classes\&. "
.ti -1c
.RI "\fBscalar_unit\fP \fBdot_product\fP (const \fBvector_unit_2d\fP &x, const \fBvector_unit_2d\fP &y)"
.br
.RI "Creates a \fBscalar_unit\fP as the dot product of the two vectors x and y\&. "
.ti -1c
.RI "\fBangle\fP \fBangle_between\fP (const \fBvector_unit_2d\fP &x, const \fBvector_unit_2d\fP &y)"
.br
.RI "Returns the angle between two vectors x and y inside a 2D space\&. "
.ti -1c
.RI "bool \fBsame_direction\fP (const \fBvector_unit_2d\fP &x, const \fBvector_unit_2d\fP &y)"
.br
.RI "Checks if two vectors x and y have the same direction\&. "
.ti -1c
.RI "bool \fBparallel\fP (const \fBvector_unit_2d\fP &x, const \fBvector_unit_2d\fP &y)"
.br
.RI "Checks if two vectors x and y are parallel, which means that their direction is the same or the exact opposite\&. "
.ti -1c
.RI "bool \fBorthogonal\fP (const \fBvector_unit_2d\fP &x, const \fBvector_unit_2d\fP &y)"
.br
.RI "Checks if two vectors x and y are orthogonal, that's, if they have 90 degrees of difference\&. "
.ti -1c
.RI "string \fBto_string\fP (const \fBvector_unit_2d\fP &x)"
.br
.RI "It generates a string representation of \fBvector_unit_2d\fP\&. "
.ti -1c
.RI "\fBscalar_unit\fP \fBnorm\fP (const \fBvector_unit_3d\fP &x)"
.br
.RI "It returns the value of the vector in spherical coordinates, r\&. "
.ti -1c
.RI "\fBvector_unit_3d\fP \fBsqrt\fP (const \fBvector_unit_3d\fP &x)"
.br
.RI "It squares the vector, creating a \fBvector_unit_3d\fP with the value squared and always the same theta and the same phi\&. The dimensions are squared with the same rules for the square of dimensions than \fBscalar_unit\fP classes\&. "
.ti -1c
.RI "\fBvector_unit_3d\fP \fBsqrt_nth\fP (const \fBvector_unit_3d\fP &x, int index)"
.br
.RI "It takes the root of the vector with the index given, creating a \fBvector_unit_3d\fP with the value rooted to that index and always maintains the same theta and the same phi\&. The dimensions are squared with the same rules for the square of dimensions than \fBscalar_unit\fP classes\&. "
.ti -1c
.RI "\fBscalar_unit\fP \fBdot_product\fP (const \fBvector_unit_3d\fP &x, const \fBvector_unit_3d\fP &y)"
.br
.RI "Creates a \fBscalar_unit\fP as the dot product of the two vectors x and y\&. "
.ti -1c
.RI "\fBvector_unit_3d\fP \fBcross_product\fP (const \fBvector_unit_3d\fP &x, const \fBvector_unit_3d\fP &y)"
.br
.RI "Creates a \fBvector_unit_3d\fP as the cross product of the two vectors x and y\&. "
.ti -1c
.RI "\fBangle\fP \fBangle_between\fP (const \fBvector_unit_3d\fP &x, const \fBvector_unit_3d\fP &y)"
.br
.RI "Returns the angle between two vectors x and y inside a 3D space\&. "
.ti -1c
.RI "bool \fBsame_direction\fP (const \fBvector_unit_3d\fP &x, const \fBvector_unit_3d\fP &y)"
.br
.RI "Checks if two vectors x and y have the same direction\&. "
.ti -1c
.RI "bool \fBparallel\fP (const \fBvector_unit_3d\fP &x, const \fBvector_unit_3d\fP &y)"
.br
.RI "Checks if two vectors x and y are parallel, which means that their direction is the same or the exact opposite\&. "
.ti -1c
.RI "bool \fBorthogonal\fP (const \fBvector_unit_3d\fP &x, const \fBvector_unit_3d\fP &y)"
.br
.RI "Checks if two vectors x and y are orthogonal, that's, if they have 90 degrees between them\&. "
.ti -1c
.RI "string \fBto_string\fP (const \fBvector_unit_3d\fP &x)"
.br
.RI "It generates a string representation of \fBvector_unit_3d\fP\&. "
.ti -1c
.RI "string \fBto_string\fP (const \fBvector_unit_nd\fP &x)"
.br
.RI "It generates a string representation of \fBvector_unit_nd\fP\&. "
.ti -1c
.RI "\fBscalar_unit\fP \fBnorm\fP (const \fBvector_unit_nd\fP &x)"
.br
.RI "It returns the value of the vector, which is the value in 1D, p in 2D (polar coordinates), or r in 3D (spherical coordinates)\&. "
.ti -1c
.RI "\fBvector_unit_nd\fP \fBsqrt\fP (const \fBvector_unit_nd\fP &x)"
.br
.RI "It squares the vector, creating a \fBvector_unit_nd\fP with the value squared and always the same angles\&. The dimensions are squared with the same rules for the square of dimensions than \fBscalar_unit\fP classes\&. "
.ti -1c
.RI "\fBvector_unit_nd\fP \fBsqrt_nth\fP (const \fBvector_unit_nd\fP &x, int index)"
.br
.RI "It takes the root of the vector with the index given, creating a \fBvector_unit_nd\fP with the value rooted to that index and always maintains the same angles\&. The dimensions are squared with the same rules for the square of dimensions than \fBscalar_unit\fP classes\&. "
.ti -1c
.RI "\fBscalar_unit\fP \fBdot_product\fP (const \fBvector_unit_nd\fP &x, const \fBvector_unit_nd\fP &y)"
.br
.RI "Creates a \fBscalar_unit\fP as the dot product of the two vectors x and y\&. "
.ti -1c
.RI "\fBvector_unit_nd\fP \fBcross_product\fP (const \fBvector_unit_nd\fP &x, const \fBvector_unit_nd\fP &y)"
.br
.RI "Creates a \fBvector_unit_nd\fP as the cross product of the two vectors x and y\&. If both vectors aren't in 3D, it returns an empty \fBvector_unit_nd\fP, because the cross product doesn't exists outside 3D\&. "
.ti -1c
.RI "\fBangle\fP \fBangle_between\fP (const \fBvector_unit_nd\fP &x, const \fBvector_unit_nd\fP &y)"
.br
.RI "Returns the angle between two vectors x and y inside the ND space, which can be 2D or 3D, depending on the ND of the vectors\&. If the vectors have different ND, it returns an empty \fBvector_unit_nd\fP instead\&. "
.ti -1c
.RI "bool \fBsame_nd\fP (const \fBvector_unit_nd\fP &x, const \fBvector_unit_nd\fP &y)"
.br
.RI "Checks if two vectors have the same number of dimensions\&. "
.ti -1c
.RI "bool \fBsame_direction\fP (const \fBvector_unit_nd\fP &x, const \fBvector_unit_nd\fP &y)"
.br
.RI "Checks if two vectors x and y have the same direction\&. Both vectors must have the same ND, otherwise it returns an empty \fBvector_unit_nd\fP instead\&. "
.ti -1c
.RI "bool \fBparallel\fP (const \fBvector_unit_nd\fP &x, const \fBvector_unit_nd\fP &y)"
.br
.RI "Checks if two vectors x and y are parallel, which means that their direction is the same or the exact opposite\&. Both vectors must have the same ND, otherwise it returns an empty \fBvector_unit_nd\fP instead\&. "
.ti -1c
.RI "bool \fBorthogonal\fP (const \fBvector_unit_nd\fP &x, const \fBvector_unit_nd\fP &y)"
.br
.RI "Checks if two vectors x and y are orthogonal, that's, if they have 90 degrees between them\&. Both vectors must have the same ND, otherwise it returns an empty \fBvector_unit_nd\fP instead\&. "
.ti -1c
.RI "float \fBparse_float\fP (const string &x)"
.br
.ti -1c
.RI "int \fBparse_int\fP (const string &x)"
.br
.ti -1c
.RI "string \fBdisplay_float\fP (const float &value, int number_of_decimals)"
.br
.ti -1c
.RI "string \fBdisplay_double\fP (const double &value, int number_of_decimals)"
.br
.ti -1c
.RI "string \fBdisplay_long_double\fP (const long double &value, int number_of_decimals)"
.br
.in -1c
.SS "Variables"

.in +1c
.ti -1c
.RI "\fBangle\fP \fBcoordinates_ndr_no_angle\fP = \fBangle\fP()"
.br
.ti -1c
.RI "constexpr float \fBPI\fP = boost::math::constants::pi<float>()"
.br
.ti -1c
.RI "static const long double \fBAVOGADRO_CONSTANT\fP = 6\&.02214076e23"
.br
.ti -1c
.RI "map< string, \fBconversion\fP > \fBget_conversion\fP"
.br
.in -1c
.SH "Detailed Description"
.PP 
The namespace scifir contains all scifir-units, excepting the string literals, which are outside\&. 
.SH "Typedef Documentation"
.PP 
.SS "typedef length \fBscifir::wavelength\fP"

.PP
Definition at line 93 of file physics_units\&.hpp\&.
.SH "Enumeration Type Documentation"
.PP 
.SS "enum \fBscifir::alert_state\fP\fC [strong]\fP"

.PP
\fBEnumerator\fP
.in +1c
.TP
\fB\fIVIGIL \fP\fP
.TP
\fB\fISLEEP \fP\fP
.TP
\fB\fIMEDITATION \fP\fP
.PP
Definition at line 10 of file mind\&.hpp\&.
.PP
.nf
10 { VIGIL, SLEEP, MEDITATION };
.fi
.SS "enum \fBscifir::astronomical_body\fP : int8_t\fC [strong]\fP"

.PP
\fBEnumerator\fP
.in +1c
.TP
\fB\fINONE \fP\fP
.TP
\fB\fIMILKY_WAY \fP\fP
.TP
\fB\fIANDROMEDA \fP\fP
.TP
\fB\fISOLAR_SYSTEM \fP\fP
.TP
\fB\fISUN \fP\fP
.TP
\fB\fIMOON \fP\fP
.TP
\fB\fIMERCURY \fP\fP
.TP
\fB\fIVENUS \fP\fP
.TP
\fB\fIEARTH \fP\fP
.TP
\fB\fIMARS \fP\fP
.TP
\fB\fIJUPITER \fP\fP
.TP
\fB\fISATURN \fP\fP
.TP
\fB\fIURANUS \fP\fP
.TP
\fB\fINEPTUNE \fP\fP
.TP
\fB\fICERES \fP\fP
.TP
\fB\fIORCUS \fP\fP
.TP
\fB\fIPLUTO \fP\fP
.TP
\fB\fIHAUMEA \fP\fP
.TP
\fB\fIQUAOAR \fP\fP
.TP
\fB\fIMAKEMAKE \fP\fP
.TP
\fB\fIGONGGONG \fP\fP
.TP
\fB\fIERIS \fP\fP
.TP
\fB\fISEDNA \fP\fP
.TP
\fB\fIIO \fP\fP
.TP
\fB\fIEUROPA \fP\fP
.TP
\fB\fIGANYMEDE \fP\fP
.TP
\fB\fICALLISTO \fP\fP
.TP
\fB\fIMIMAS \fP\fP
.TP
\fB\fIENCELADUS \fP\fP
.TP
\fB\fITETHYS \fP\fP
.TP
\fB\fIDIONE \fP\fP
.TP
\fB\fIRHEA \fP\fP
.TP
\fB\fITITAN \fP\fP
.TP
\fB\fIIAPETUS \fP\fP
.TP
\fB\fIMIRANDA \fP\fP
.TP
\fB\fIARIEL \fP\fP
.TP
\fB\fIUMBRIEL \fP\fP
.TP
\fB\fITITANIA \fP\fP
.TP
\fB\fIOBERON \fP\fP
.TP
\fB\fITRITON \fP\fP
.TP
\fB\fICHARON \fP\fP
.TP
\fB\fIDYSNOMIA \fP\fP
.PP
Definition at line 11 of file aid\&.hpp\&.
.PP
.nf
11 : int8_t {NONE,MILKY_WAY,ANDROMEDA,SOLAR_SYSTEM,SUN,MOON,MERCURY,VENUS,EARTH,MARS,JUPITER,SATURN,URANUS,NEPTUNE,CERES,ORCUS,PLUTO,HAUMEA,QUAOAR,MAKEMAKE,GONGGONG,ERIS,SEDNA,IO,EUROPA,GANYMEDE,CALLISTO,MIMAS,ENCELADUS,TETHYS,DIONE,RHEA,TITAN,IAPETUS,MIRANDA,ARIEL,UMBRIEL,TITANIA,OBERON,TRITON,CHARON,DYSNOMIA};
.fi
.SS "enum \fBscifir::body_health\fP\fC [strong]\fP"

.PP
\fBEnumerator\fP
.in +1c
.TP
\fB\fIHEALTHY \fP\fP
.TP
\fB\fIDAMAGED \fP\fP
.TP
\fB\fISICK \fP\fP
.TP
\fB\fISICK_AND_DAMAGED \fP\fP
.PP
Definition at line 12 of file body\&.hpp\&.
.PP
.nf
12 { HEALTHY, DAMAGED, SICK, SICK_AND_DAMAGED };
.fi
.SS "enum \fBscifir::conscience_state\fP\fC [strong]\fP"

.PP
\fBEnumerator\fP
.in +1c
.TP
\fB\fINORMAL \fP\fP
.TP
\fB\fIALTERED \fP\fP
.PP
Definition at line 18 of file mind\&.hpp\&.
.PP
.nf
18 { NORMAL, ALTERED };
.fi
.SS "enum \fBscifir::emotion\fP\fC [strong]\fP"

.PP
\fBEnumerator\fP
.in +1c
.TP
\fB\fIHAPPY \fP\fP
.TP
\fB\fIEXCITED \fP\fP
.TP
\fB\fITENDER \fP\fP
.TP
\fB\fISCARED \fP\fP
.TP
\fB\fIANGRY \fP\fP
.TP
\fB\fISAD \fP\fP
.PP
Definition at line 14 of file mind\&.hpp\&.
.PP
.nf
14 { HAPPY, EXCITED, TENDER, SCARED, ANGRY, SAD };
.fi
.SS "enum \fBscifir::feeling\fP\fC [strong]\fP"

.PP
\fBEnumerator\fP
.in +1c
.TP
\fB\fISADNESS \fP\fP
.TP
\fB\fIRANCOR \fP\fP
.TP
\fB\fILOVE \fP\fP
.PP
Definition at line 12 of file mind\&.hpp\&.
.PP
.nf
12 { SADNESS, RANCOR, LOVE };
.fi
.SS "enum \fBscifir::movement\fP\fC [strong]\fP"

.PP
\fBEnumerator\fP
.in +1c
.TP
\fB\fISTILL \fP\fP
.TP
\fB\fIWALK \fP\fP
.TP
\fB\fIRUN \fP\fP
.TP
\fB\fISWIM \fP\fP
.TP
\fB\fICLIMB \fP\fP
.TP
\fB\fIFLY \fP\fP
.PP
Definition at line 8 of file body\&.hpp\&.
.PP
.nf
8 { STILL, WALK, RUN, SWIM, CLIMB, FLY };
.fi
.SS "enum \fBscifir::movement_state\fP\fC [strong]\fP"

.PP
\fBEnumerator\fP
.in +1c
.TP
\fB\fISTILL \fP\fP
.TP
\fB\fIACTIVE \fP\fP
.PP
Definition at line 10 of file body\&.hpp\&.
.PP
.nf
10 { STILL, ACTIVE };
.fi
.SS "enum \fBscifir::sensation\fP\fC [strong]\fP"

.PP
\fBEnumerator\fP
.in +1c
.TP
\fB\fILIGHT \fP\fP
.TP
\fB\fISOUND \fP\fP
.TP
\fB\fIACCELERATION \fP\fP
.TP
\fB\fIODOR \fP\fP
.TP
\fB\fITASTE \fP\fP
.TP
\fB\fITOUCH \fP\fP
.TP
\fB\fITEMPERATURE \fP\fP
.PP
Definition at line 16 of file mind\&.hpp\&.
.PP
.nf
16 { LIGHT, SOUND, ACCELERATION, ODOR, TASTE, TOUCH, TEMPERATURE };
.fi
.SH "Function Documentation"
.PP 
.SS "template<typename T > T scifir::abs (const \fBcomplex_number\fP< T > & x)"

.PP
Definition at line 182 of file complex_number\&.hpp\&.
.PP
.nf
183     {
184         return scifir::sqrt((x\&.real^2) + (x\&.imaginary^2));
185     }
.fi
.SS "float scifir::abs (const \fBscalar_unit\fP & x)"

.PP
Returns the absolute value of the \fBscalar_unit\fP, without dimensions\&. 
.PP
Definition at line 720 of file scalar_unit\&.cpp\&.
.PP
.nf
721     {
722         return std::abs(x\&.get_value());
723     }
.fi
.SS "\fBangle\fP scifir::acos (float x)"

.PP
Calculates the acos of some value x and returns the result as angle in degrees\&. 
.PP
Definition at line 366 of file angle\&.cpp\&.
.PP
.nf
367     {
368         return angle(radian_to_degree(std::acos(x)));
369     }
.fi
.SS "float scifir::acos_degree (float x)\fC [inline]\fP"

.PP
Calculates the acos receiving x in degrees\&. It uses the \fBacos()\fP function of the standard library of C++, but the difference is that the argument is in degrees, not in radians\&. 
.PP
Definition at line 193 of file angle\&.hpp\&.
.PP
.nf
194     {
195         return radian_to_degree(std::acos(x));
196     }
.fi
.SS "\fBangle\fP scifir::acosh (float x)"

.PP
Calculates the acosh of some value x and returns the result as angle in degrees\&. 
.PP
Definition at line 396 of file angle\&.cpp\&.
.PP
.nf
397     {
398         return angle(radian_to_degree(std::acosh(x)));
399     }
.fi
.SS "float scifir::acosh_degree (float x)\fC [inline]\fP"

.PP
Calculates the acosh receiving x in degrees\&. It uses the \fBacosh()\fP function of the standard library of C++, but the difference is that the argument is in degrees, not in radians\&. 
.PP
Definition at line 208 of file angle\&.hpp\&.
.PP
.nf
209     {
210         return radian_to_degree(std::acosh(x));
211     }
.fi
.SS "\fBangle\fP scifir::angle_between (const \fBvector_unit_2d\fP & x, const \fBvector_unit_2d\fP & y)"

.PP
Returns the angle between two vectors x and y inside a 2D space\&. 
.PP
Definition at line 345 of file vector_unit_2d\&.cpp\&.
.PP
.nf
346     {
347         return angle(radian_to_degree(std::atan2(float(y\&.y_projection() * x\&.x_projection() - y\&.x_projection() * x\&.y_projection()),float(y\&.x_projection() * x\&.x_projection() + y\&.y_projection() * x\&.y_projection()))));
348     }
.fi
.SS "\fBangle\fP scifir::angle_between (const \fBvector_unit_3d\fP & x, const \fBvector_unit_3d\fP & y)"

.PP
Returns the angle between two vectors x and y inside a 3D space\&. 
.PP
Definition at line 472 of file vector_unit_3d\&.cpp\&.
.PP
.nf
473     {
474         return scifir::acos(float(dot_product(x,y)/(norm(x)*norm(y))));
475     }
.fi
.SS "\fBangle\fP scifir::angle_between (const \fBvector_unit_nd\fP & x, const \fBvector_unit_nd\fP & y)"

.PP
Returns the angle between two vectors x and y inside the ND space, which can be 2D or 3D, depending on the ND of the vectors\&. If the vectors have different ND, it returns an empty \fBvector_unit_nd\fP instead\&. 
.PP
Definition at line 799 of file vector_unit_nd\&.cpp\&.
.PP
.nf
800     {
801         return scifir::acos(float(dot_product(x,y)/(norm(x) * norm(y))));
802     }
.fi
.SS "scifir::area::area (const \fBsize_2d\fP< length > & x)\fC [explicit]\fP"

.PP
Definition at line 13 of file space_units\&.cpp\&.
.PP
.nf
13                                        : scalar_unit()
14     {
15         length x_height = x\&.height;
16         x_height\&.change_dimensions(x\&.width);
17         *this = x\&.width * x_height;
18     }
.fi
.SS "\fBangle\fP scifir::asin (float x)"

.PP
Calculates the asin of some value x and returns the result as angle in degrees\&. 
.PP
Definition at line 361 of file angle\&.cpp\&.
.PP
.nf
362     {
363         return angle(radian_to_degree(std::asin(x)));
364     }
.fi
.SS "float scifir::asin_degree (float x)\fC [inline]\fP"

.PP
Calculates the asin receiving x in degrees\&. It uses the \fBasin()\fP function of the standard library of C++, but the difference is that the argument is in degrees, not in radians\&. 
.PP
Definition at line 188 of file angle\&.hpp\&.
.PP
.nf
189     {
190         return radian_to_degree(std::asin(x));
191     }
.fi
.SS "\fBangle\fP scifir::asinh (float x)"

.PP
Calculates the asinh of some value x and returns the result as angle in degrees\&. 
.PP
Definition at line 391 of file angle\&.cpp\&.
.PP
.nf
392     {
393         return angle(radian_to_degree(std::asinh(x)));
394     }
.fi
.SS "float scifir::asinh_degree (float x)\fC [inline]\fP"

.PP
Calculates the asinh receiving x in degrees\&. It uses the \fBasinh()\fP function of the standard library of C++, but the difference is that the argument is in degrees, not in radians\&. 
.PP
Definition at line 203 of file angle\&.hpp\&.
.PP
.nf
204     {
205         return radian_to_degree(std::asinh(x));
206     }
.fi
.SS "\fBangle\fP scifir::atan (float x)"

.PP
Calculates the atan of some value x and returns the result as angle in degrees\&. 
.PP
Definition at line 371 of file angle\&.cpp\&.
.PP
.nf
372     {
373         return angle(radian_to_degree(std::atan(x)));
374     }
.fi
.SS "float scifir::atan_degree (float x)\fC [inline]\fP"

.PP
Calculates the atan receiving x in degrees\&. It uses the \fBatan()\fP function of the standard library of C++, but the difference is that the argument is in degrees, not in radians\&. 
.PP
Definition at line 198 of file angle\&.hpp\&.
.PP
.nf
199     {
200         return radian_to_degree(std::atan(x));
201     }
.fi
.SS "\fBangle\fP scifir::atanh (float x)"

.PP
Calculates the atanh of some value x and returns the result as angle in degrees\&. 
.PP
Definition at line 401 of file angle\&.cpp\&.
.PP
.nf
402     {
403         return angle(radian_to_degree(std::atanh(x)));
404     }
.fi
.SS "float scifir::atanh_degree (float x)\fC [inline]\fP"

.PP
Calculates the atanh receiving x in degrees\&. It uses the \fBatanh()\fP function of the standard library of C++, but the difference is that the argument is in degrees, not in radians\&. 
.PP
Definition at line 213 of file angle\&.hpp\&.
.PP
.nf
214     {
215         return radian_to_degree(std::atanh(x));
216     }
.fi
.SS "\fBscalar_unit\fP scifir::cartesian_2d_to_polar_p (const \fBscalar_unit\fP & x, \fBscalar_unit\fP y)\fC [inline]\fP"

.PP
Definition at line 374 of file coordinates_2d\&.hpp\&.
.PP
.nf
375     {
376         y\&.change_dimensions(x);
377         return scalar_unit(std::sqrt(std::pow(float(x),2) + std::pow(float(y),2)),x\&.get_dimensions());
378     }
.fi
.SS "float scifir::cartesian_2d_to_polar_p (float x, float y)\fC [inline]\fP"

.PP
Definition at line 396 of file coordinates_2d\&.hpp\&.
.PP
.nf
397     {
398         return float(std::sqrt(std::pow(x,2) + std::pow(y,2)));
399     }
.fi
.SS "\fBangle\fP scifir::cartesian_2d_to_polar_theta (const \fBscalar_unit\fP & x, \fBscalar_unit\fP y)\fC [inline]\fP"

.PP
Definition at line 380 of file coordinates_2d\&.hpp\&.
.PP
.nf
381     {
382         y\&.change_dimensions(x);
383         return scifir::angle(scifir::atan_degree(float(y)/float(x)));
384     }
.fi
.SS "\fBangle\fP scifir::cartesian_2d_to_polar_theta (float x, float y)\fC [inline]\fP"

.PP
Definition at line 401 of file coordinates_2d\&.hpp\&.
.PP
.nf
402     {
403         return scifir::angle(scifir::atan_degree(y/x));
404     }
.fi
.SS "\fBscalar_unit\fP scifir::cartesian_3d_to_cylindrical_p (const \fBscalar_unit\fP & x, \fBscalar_unit\fP y, const \fBscalar_unit\fP & z)\fC [inline]\fP"

.PP
Definition at line 616 of file coordinates_3d\&.hpp\&.
.PP
.nf
617     {
618         y\&.change_dimensions(x);
619         return scalar_unit(std::sqrt(std::pow(float(x),2) + std::pow(float(y),2)),x\&.get_dimensions());
620     }
.fi
.SS "float scifir::cartesian_3d_to_cylindrical_p (float x, float y, float z)\fC [inline]\fP"

.PP
Definition at line 715 of file coordinates_3d\&.hpp\&.
.PP
.nf
716     {
717         return float(std::sqrt(std::pow(x,2) + std::pow(y,2)));
718     }
.fi
.SS "\fBangle\fP scifir::cartesian_3d_to_cylindrical_theta (const \fBscalar_unit\fP & x, \fBscalar_unit\fP y, const \fBscalar_unit\fP & z)\fC [inline]\fP"

.PP
Definition at line 622 of file coordinates_3d\&.hpp\&.
.PP
.nf
623     {
624         y\&.change_dimensions(x);
625         return angle(scifir::atan_degree(float(y) / float(x)));
626     }
.fi
.SS "\fBangle\fP scifir::cartesian_3d_to_cylindrical_theta (float x, float y, float z)\fC [inline]\fP"

.PP
Definition at line 720 of file coordinates_3d\&.hpp\&.
.PP
.nf
721     {
722         return angle(scifir::atan_degree(y / x));
723     }
.fi
.SS "\fBscalar_unit\fP scifir::cartesian_3d_to_cylindrical_z (const \fBscalar_unit\fP & x, const \fBscalar_unit\fP & y, const \fBscalar_unit\fP & z)\fC [inline]\fP"

.PP
Definition at line 628 of file coordinates_3d\&.hpp\&.
.PP
.nf
629     {
630         return z;
631     }
.fi
.SS "float scifir::cartesian_3d_to_cylindrical_z (float x, float y, float z)\fC [inline]\fP"

.PP
Definition at line 725 of file coordinates_3d\&.hpp\&.
.PP
.nf
726     {
727         return z;
728     }
.fi
.SS "\fBangle\fP scifir::cartesian_3d_to_spherical_phi (const \fBscalar_unit\fP & x, \fBscalar_unit\fP y, \fBscalar_unit\fP z)\fC [inline]\fP"

.PP
Definition at line 646 of file coordinates_3d\&.hpp\&.
.PP
.nf
647     {
648         y\&.change_dimensions(x);
649         z\&.change_dimensions(x);
650         return angle(scifir::acos_degree(float(z) / float(std::sqrt(std::pow(float(x),2) + std::pow(float(y),2) + std::pow(float(z),2)))));
651     }
.fi
.SS "\fBangle\fP scifir::cartesian_3d_to_spherical_phi (float x, float y, float z)\fC [inline]\fP"

.PP
Definition at line 740 of file coordinates_3d\&.hpp\&.
.PP
.nf
741     {
742         return angle(scifir::acos_degree(z / float(std::sqrt(std::pow(x,2) + std::pow(y,2) + std::pow(z,2)))));
743     }
.fi
.SS "\fBscalar_unit\fP scifir::cartesian_3d_to_spherical_r (const \fBscalar_unit\fP & x, \fBscalar_unit\fP y, \fBscalar_unit\fP z)\fC [inline]\fP"

.PP
Definition at line 633 of file coordinates_3d\&.hpp\&.
.PP
.nf
634     {
635         y\&.change_dimensions(x);
636         z\&.change_dimensions(x);
637         return scalar_unit(std::sqrt(std::pow(float(x),2) + std::pow(float(y),2) + std::pow(float(z),2)),x\&.get_dimensions());
638     }
.fi
.SS "float scifir::cartesian_3d_to_spherical_r (float x, float y, float z)\fC [inline]\fP"

.PP
Definition at line 730 of file coordinates_3d\&.hpp\&.
.PP
.nf
731     {
732         return float(std::sqrt(std::pow(x,2) + std::pow(y,2) + std::pow(z,2)));
733     }
.fi
.SS "\fBangle\fP scifir::cartesian_3d_to_spherical_theta (const \fBscalar_unit\fP & x, \fBscalar_unit\fP y, const \fBscalar_unit\fP & z)\fC [inline]\fP"

.PP
Definition at line 640 of file coordinates_3d\&.hpp\&.
.PP
.nf
641     {
642         y\&.change_dimensions(x);
643         return angle(scifir::atan_degree(float(y) / float(x)));
644     }
.fi
.SS "\fBangle\fP scifir::cartesian_3d_to_spherical_theta (float x, float y, float z)\fC [inline]\fP"

.PP
Definition at line 735 of file coordinates_3d\&.hpp\&.
.PP
.nf
736     {
737         return angle(scifir::atan_degree(y / x));
738     }
.fi
.SS "\fBprefix\fP scifir::closest_prefix (const \fBprefix\fP & actual_prefix, int actual_scale)"

.PP
Returns the closes prefix related to the scale of the current value\&. It is used when displaying a \fBscalar_unit\fP to the most close prefix available\&. 
.PP
Definition at line 323 of file prefix\&.cpp\&.
.PP
.nf
324     {
325         int factor_difference = actual_scale + actual_prefix\&.get_conversion_factor();
326         return create_prefix_by_factor(factor_difference);
327         
328     }
.fi
.SS "bool scifir::common_dimension (const \fBdimension\fP & x, const \fBdimension\fP & y)"

.PP
Checks if there's an equal basic dimension between the basic dimensions of those two dimensions\&. 
.PP
Definition at line 1614 of file dimension\&.cpp\&.
.PP
.nf
1615     {
1616         for (const dimension& x_dimension : x\&.get_basic_dimensions())
1617         {
1618             for (const dimension& y_dimension : y\&.get_basic_dimensions())
1619             {
1620                 if (x_dimension == y_dimension)
1621                 {
1622                     return true;
1623                 }
1624             }
1625         }
1626         return false;
1627     }
.fi
.SS "float scifir::cos (const \fBangle\fP & x)"

.PP
Calculates the cos of angle x\&. It uses the \fBcos()\fP function of the standard library of C++, the difference is that angle is in degrees, not in radians\&. 
.PP
Definition at line 351 of file angle\&.cpp\&.
.PP
.nf
352     {
353         return std::cos(x\&.get_radian());
354     }
.fi
.SS "float scifir::cosh (const \fBangle\fP & x)"

.PP
Calculates the cosh of angle x\&. It uses the \fBcosh()\fP function of the standard library of C++, the difference is that angle is in degrees, not in radians\&. 
.PP
Definition at line 381 of file angle\&.cpp\&.
.PP
.nf
382     {
383         return std::cosh(x\&.get_radian());
384     }
.fi
.SS "\fBaid::type\fP scifir::create_astronomical_type (const string & astronomical_type_abbreviation)"

.PP
Definition at line 501 of file aid\&.cpp\&.
.PP
.nf
502     {
503         if (astronomical_type_abbreviation == "U")
504         {
505             return aid::UNIVERSE;
506         }
507         else if (astronomical_type_abbreviation == "G")
508         {
509             return aid::GALAXY;
510         }
511         else if (astronomical_type_abbreviation == "SS")
512         {
513             return aid::SOLAR_SYSTEM;
514         }
515         else if (astronomical_type_abbreviation == "P")
516         {
517             return aid::PLANET;
518         }
519         else if (astronomical_type_abbreviation == "ST")
520         {
521             return aid::STAR;
522         }
523         else if (astronomical_type_abbreviation == "A")
524         {
525             return aid::ASTEROID;
526         }
527         else if (astronomical_type_abbreviation == "MN")
528         {
529             return aid::MOON;
530         }
531         else if (astronomical_type_abbreviation == "MT")
532         {
533             return aid::METEOR;
534         }
535         else
536         {
537             return aid::NONE;
538         }
539     }
.fi
.SS "vector< \fBdimension\fP > scifir::create_derived_dimensions (const string & init_dimensions)"

.PP
Creates the derived dimensions from an initialization string of dimensions\&. 
.PP
Definition at line 1327 of file dimension\&.cpp\&.
.PP
.nf
1328     {
1329         vector<dimension> new_dimensions = create_dimensions(init_dimensions);
1330         return create_derived_dimensions(new_dimensions);
1331     }
.fi
.SS "vector< \fBdimension\fP > scifir::create_derived_dimensions (const vector< \fBdimension\fP > & x)"

.PP
Creates all the derived dimensions from a vector of dimensions\&. 
.PP
Definition at line 1333 of file dimension\&.cpp\&.
.PP
.nf
1334     {
1335         vector<dimension> new_x = vector<dimension>();
1336         for(unsigned int i = 0; i < x\&.size(); i++)
1337         {
1338             vector<dimension> x_subdimensions = x[i]\&.get_basic_dimensions();
1339             for (dimension& x_subdimension : x_subdimensions)
1340             {
1341                 if (x[i]\&.dimension_position == dimension::DENOMINATOR)
1342                 {
1343                     x_subdimension\&.invert();
1344                 }
1345                 new_x\&.push_back(x_subdimension);
1346             }
1347         }
1348         return new_x;
1349     }
.fi
.SS "vector< \fBdimension\fP > scifir::create_derived_dimensions (const vector< \fBdimension\fP > & x, long double & value)"

.PP
Creates all the derived dimensions from a vector of dimensions, updating also the associated value related to those dimensions based on the prefix math and the conversion factor of the dimension, if that conversion factor is different than one\&. 
.PP
Definition at line 1351 of file dimension\&.cpp\&.
.PP
.nf
1352     {
1353         vector<dimension> new_x = vector<dimension>();
1354         for(unsigned int i = 0; i < x\&.size(); i++)
1355         {
1356             if (x[i]\&.dimension_position == dimension::NUMERATOR)
1357             {
1358                 value *= x[i]\&.get_conversion_factor();
1359                 value *= x[i]\&.prefix_math();
1360             }
1361             else if (x[i]\&.dimension_position == dimension::DENOMINATOR)
1362             {
1363                 value /= x[i]\&.get_conversion_factor();
1364                 value /= x[i]\&.prefix_math();
1365             }
1366             vector<dimension> x_subdimensions = x[i]\&.get_basic_dimensions();
1367             for (dimension& x_subdimension : x_subdimensions)
1368             {
1369                 if (x[i]\&.dimension_position == dimension::DENOMINATOR)
1370                 {
1371                     x_subdimension\&.invert();
1372                 }
1373                 new_x\&.push_back(x_subdimension);
1374             }
1375         }
1376         return new_x;
1377     }
.fi
.SS "vector< \fBdimension\fP > scifir::create_dimensions (string init_dimensions)"

.PP
Creates the dimensions from an initialization string of dimensions\&. 
.PP
Definition at line 1277 of file dimension\&.cpp\&.
.PP
.nf
1278     {
1279         boost::algorithm::erase_all(init_dimensions, " ");
1280         dimension::position new_sign = dimension::NUMERATOR;
1281         int new_scale = 1;
1282         int new_size = 1;
1283         int new_start = 0;
1284         string new_dimension_str;
1285         vector<dimension> dimensions = vector<dimension>();
1286         for(unsigned int j = 0; j < init_dimensions\&.size(); j++)
1287         {
1288             if(init_dimensions[j] == '1' and init_dimensions[j + 1] == '/')
1289             {
1290                 new_sign = dimension::DENOMINATOR;
1291             }
1292             if(isalpha(init_dimensions[j]) and (!isalpha(init_dimensions[j + 1]) or (j + 1) == init_dimensions\&.size()))
1293             {
1294                 new_dimension_str = init_dimensions\&.substr(new_start, new_size);
1295                 if(isdigit(init_dimensions[j + 1]))
1296                 {
1297                     new_scale = stoi(init_dimensions\&.substr(j + 1, 1));
1298                 }
1299             }
1300             if(init_dimensions[j] == '*')
1301             {
1302                 new_size = 0;
1303                 new_start = j + 1;
1304             }
1305             else if(init_dimensions[j] == '/')
1306             {
1307                 new_sign = dimension::DENOMINATOR;
1308                 new_size = 0;
1309                 new_start = j + 1;
1310             }
1311             if(!new_dimension_str\&.empty())
1312             {
1313                 dimension new_dimension = dimension(new_dimension_str,new_sign);
1314                 for (int k = 0; k < new_scale; k++)
1315                 {
1316                     dimensions\&.push_back(new_dimension);
1317                 }
1318                 new_dimension_str\&.clear();
1319                 new_scale = 1;
1320                 new_size = 0;
1321             }
1322             new_size++;
1323         }
1324         return dimensions;
1325     }
.fi
.SS "\fBdirection::name\fP scifir::create_direction (const string & x)"

.PP
Definition at line 55 of file direction\&.cpp\&.
.PP
.nf
56     {
57         if (x == "left")
58         {
59             return direction::LEFT;
60         }
61         else if (x == "right")
62         {
63             return direction::RIGHT;
64         }
65         else if (x == "top")
66         {
67             return direction::TOP;
68         }
69         else if (x == "bottom")
70         {
71             return direction::BOTTOM;
72         }
73         else if (x == "front")
74         {
75             return direction::FRONT;
76         }
77         else if (x == "back")
78         {
79             return direction::BACK;
80         }
81         else if (x == "left-top")
82         {
83             return direction::LEFT_TOP;
84         }
85         else if (x == "left-bottom")
86         {
87             return direction::LEFT_BOTTOM;
88         }
89         else if (x == "right-top")
90         {
91             return direction::RIGHT_TOP;
92         }
93         else if (x == "right-bottom")
94         {
95             return direction::RIGHT_BOTTOM;
96         }
97         else if (x == "left-front")
98         {
99             return direction::LEFT_FRONT;
100         }
101         else if (x == "left-back")
102         {
103             return direction::LEFT_BACK;
104         }
105         else if (x == "right-front")
106         {
107             return direction::RIGHT_FRONT;
108         }
109         else if (x == "right-back")
110         {
111             return direction::RIGHT_BACK;
112         }
113         else if (x == "top-front")
114         {
115             return direction::TOP_FRONT;
116         }
117         else if (x == "top-back")
118         {
119             return direction::TOP_BACK;
120         }
121         else if (x == "bottom-front")
122         {
123             return direction::BOTTOM_FRONT;
124         }
125         else if (x == "bottom-back")
126         {
127             return direction::BOTTOM_BACK;
128         }
129         else if (x == "left-top-front")
130         {
131             return direction::LEFT_TOP_FRONT;
132         }
133         else if (x == "left-top-back")
134         {
135             return direction::LEFT_TOP_BACK;
136         }
137         else if (x == "left-bottom-front")
138         {
139             return direction::LEFT_BOTTOM_FRONT;
140         }
141         else if (x == "left-bottom-back")
142         {
143             return direction::LEFT_BOTTOM_BACK;
144         }
145         else if (x == "right-top-front")
146         {
147             return direction::RIGHT_TOP_FRONT;
148         }
149         else if (x == "right-top-back")
150         {
151             return direction::RIGHT_TOP_BACK;
152         }
153         else if (x == "right-bottom-front")
154         {
155             return direction::RIGHT_BOTTOM_FRONT;
156         }
157         else if (x == "right-bottom-back")
158         {
159             return direction::RIGHT_BOTTOM_BACK;
160         }
161         else
162         {
163             return direction::NONE;
164         }
165     }
.fi
.SS "\fBprefix\fP scifir::create_prefix_by_factor (int factor)"

.PP
Creates the prefix of the factor given, which is always between a range\&. 
.PP
Definition at line 330 of file prefix\&.cpp\&.
.PP
.nf
331     {
332         if (factor == 0)
333         {
334             return prefix(prefix::NONE);
335         }
336         else if (factor == 1)
337         {
338             return prefix(prefix::DECA);
339         }
340         else if (factor == 2)
341         {
342             return prefix(prefix::HECTO);
343         }
344         else if (factor == -1)
345         {
346             return prefix(prefix::DECI);
347         }
348         else if (factor == -2)
349         {
350             return prefix(prefix::CENTI);
351         }
352         else if (factor >= 3 and factor < 6)
353         {
354             return prefix(prefix::KILO);
355         }
356         else if (factor >= 6 and factor < 9)
357         {
358             return prefix(prefix::MEGA);
359         }
360         else if (factor >= 9 and factor < 12)
361         {
362             return prefix(prefix::GIGA);
363         }
364         else if (factor >= 12 and factor < 15)
365         {
366             return prefix(prefix::TERA);
367         }
368         else if (factor >= 15 and factor < 18)
369         {
370             return prefix(prefix::PETA);
371         }
372         else if (factor >= 18 and factor < 21)
373         {
374             return prefix(prefix::EXA);
375         }
376         else if (factor >= 21 and factor < 24)
377         {
378             return prefix(prefix::ZETTA);
379         }
380         else if (factor >= 24 and factor < 27)
381         {
382             return prefix(prefix::YOTTA);
383         }
384         else if (factor >= 27 and factor < 30)
385         {
386             return prefix(prefix::RONNA);
387         }
388         else if (factor >= 30)
389         {
390             return prefix(prefix::QUETTA);
391         }
392         else if (factor <= -3 and factor > -6)
393         {
394             return prefix(prefix::MILLI);
395         }
396         else if (factor <= -6 and factor > -9)
397         {
398             return prefix(prefix::MICRO);
399         }
400         else if (factor <= -9 and factor > -12)
401         {
402             return prefix(prefix::NANO);
403         }
404         else if (factor <= -12 and factor > -15)
405         {
406             return prefix(prefix::PICO);
407         }
408         else if (factor <= -15 and factor > -18)
409         {
410             return prefix(prefix::FEMTO);
411         }
412         else if (factor <= -18 and factor > -21)
413         {
414             return prefix(prefix::ATTO);
415         }
416         else if (factor <= -21 and factor > -24)
417         {
418             return prefix(prefix::ZEPTO);
419         }
420         else if (factor <= -24 and factor > -27)
421         {
422             return prefix(prefix::YOCTO);
423         }
424         else if (factor <= -27 and factor > -30)
425         {
426             return prefix(prefix::RONTO);
427         }
428         else if (factor <= -30)
429         {
430             return prefix(prefix::QUECTO);
431         }
432         return prefix();
433     }
.fi
.SS "\fBvector_unit_3d\fP scifir::cross_product (const \fBvector_unit_3d\fP & x, const \fBvector_unit_3d\fP & y)"

.PP
Creates a \fBvector_unit_3d\fP as the cross product of the two vectors x and y\&. 
.PP
Definition at line 450 of file vector_unit_3d\&.cpp\&.
.PP
.nf
451     {
452         long double new_value;
453         angle new_theta;
454         angle new_phi;
455         if(y\&.theta == x\&.theta and y\&.phi == x\&.phi)
456         {
457             new_value = 0\&.0l;
458         }
459         else
460         {
461             float new_x = float(x\&.y_projection() * y\&.z_projection() - x\&.z_projection() * y\&.y_projection());
462             float new_y = float(x\&.z_projection() * y\&.x_projection() - x\&.x_projection() * y\&.z_projection());
463             float new_z = float(x\&.x_projection() * y\&.y_projection() - x\&.y_projection() * y\&.x_projection());
464             new_value = cartesian_3d_to_spherical_r(new_x, new_y, new_z);
465             new_theta = cartesian_3d_to_spherical_theta(new_x, new_y, new_z);
466             new_phi = cartesian_3d_to_spherical_phi(new_x, new_y, new_z);
467         }
468         vector<dimension> new_dimensions = multiply_dimensions(x\&.get_dimensions(), y\&.get_dimensions(),new_value);
469         return vector_unit_3d(float(new_value), new_dimensions, new_theta, new_phi);
470     }
.fi
.SS "\fBvector_unit_nd\fP scifir::cross_product (const \fBvector_unit_nd\fP & x, const \fBvector_unit_nd\fP & y)"

.PP
Creates a \fBvector_unit_nd\fP as the cross product of the two vectors x and y\&. If both vectors aren't in 3D, it returns an empty \fBvector_unit_nd\fP, because the cross product doesn't exists outside 3D\&. 
.PP
Definition at line 766 of file vector_unit_nd\&.cpp\&.
.PP
.nf
767     {
768         if(x\&.is_nd(3) and y\&.is_nd(3))
769         {
770             long double new_value;
771             angle new_theta;
772             angle new_phi;
773             if(y\&.angles[0] == x\&.angles[0] and y\&.angles[1] == x\&.angles[1])
774             {
775                 new_value = 0\&.0l;
776             }
777             else
778             {
779                 float new_x = float(x\&.y_projection() * y\&.z_projection() - x\&.z_projection() * y\&.y_projection());
780                 float new_y = float(x\&.z_projection() * y\&.x_projection() - x\&.x_projection() * y\&.z_projection());
781                 float new_z = float(x\&.x_projection() * y\&.y_projection() - x\&.y_projection() * y\&.x_projection());
782                 new_value = cartesian_3d_to_spherical_r(new_x, new_y, new_z);
783                 new_theta = cartesian_3d_to_spherical_theta(new_x, new_y, new_z);
784                 new_phi = cartesian_3d_to_spherical_phi(new_x, new_y, new_z);
785             }
786             vector<dimension> new_dimensions = multiply_dimensions(x\&.get_dimensions(), y\&.get_dimensions(),new_value);
787             scalar_unit new_unit = scalar_unit(float(new_value), new_dimensions);
788             vector<angle> angles;
789             angles\&.push_back(new_theta);
790             angles\&.push_back(new_phi);
791             return vector_unit_nd(new_unit, angles);
792         }
793         else
794         {
795             return vector_unit_nd();
796         }
797     }
.fi
.SS "\fBscalar_unit\fP scifir::cylindrical_to_cartesian_3d_x (const \fBscalar_unit\fP & p, const \fBangle\fP & theta, const \fBscalar_unit\fP & z)\fC [inline]\fP"

.PP
Definition at line 683 of file coordinates_3d\&.hpp\&.
.PP
.nf
684     {
685         return p * scifir::cos(theta);
686     }
.fi
.SS "float scifir::cylindrical_to_cartesian_3d_x (float p, const \fBangle\fP & theta, float z)\fC [inline]\fP"

.PP
Definition at line 775 of file coordinates_3d\&.hpp\&.
.PP
.nf
776     {
777         return p * scifir::cos(theta);
778     }
.fi
.SS "\fBscalar_unit\fP scifir::cylindrical_to_cartesian_3d_y (const \fBscalar_unit\fP & p, const \fBangle\fP & theta, const \fBscalar_unit\fP & z)\fC [inline]\fP"

.PP
Definition at line 688 of file coordinates_3d\&.hpp\&.
.PP
.nf
689     {
690         return p * scifir::sin(theta);
691     }
.fi
.SS "float scifir::cylindrical_to_cartesian_3d_y (float p, const \fBangle\fP & theta, float z)\fC [inline]\fP"

.PP
Definition at line 780 of file coordinates_3d\&.hpp\&.
.PP
.nf
781     {
782         return p * scifir::sin(theta);
783     }
.fi
.SS "\fBscalar_unit\fP scifir::cylindrical_to_cartesian_3d_z (const \fBscalar_unit\fP & p, const \fBangle\fP & theta, const \fBscalar_unit\fP & z)\fC [inline]\fP"

.PP
Definition at line 693 of file coordinates_3d\&.hpp\&.
.PP
.nf
694     {
695         return z;
696     }
.fi
.SS "float scifir::cylindrical_to_cartesian_3d_z (float p, const \fBangle\fP & theta, float z)\fC [inline]\fP"

.PP
Definition at line 785 of file coordinates_3d\&.hpp\&.
.PP
.nf
786     {
787         return z;
788     }
.fi
.SS "\fBangle\fP scifir::cylindrical_to_spherical_phi (const \fBscalar_unit\fP & p, const \fBangle\fP & theta, \fBscalar_unit\fP z)\fC [inline]\fP"

.PP
Definition at line 709 of file coordinates_3d\&.hpp\&.
.PP
.nf
710     {
711         z\&.change_dimensions(p);
712         return angle(scifir::atan_degree(float(p) / float(z)));
713     }
.fi
.SS "\fBangle\fP scifir::cylindrical_to_spherical_phi (float p, const \fBangle\fP & theta, float z)\fC [inline]\fP"

.PP
Definition at line 800 of file coordinates_3d\&.hpp\&.
.PP
.nf
801     {
802         return angle(scifir::atan_degree(p / z));
803     }
.fi
.SS "\fBscalar_unit\fP scifir::cylindrical_to_spherical_r (const \fBscalar_unit\fP & p, const \fBangle\fP & theta, \fBscalar_unit\fP z)\fC [inline]\fP"

.PP
Definition at line 698 of file coordinates_3d\&.hpp\&.
.PP
.nf
699     {
700         z\&.change_dimensions(p);
701         return scalar_unit(std::sqrt(std::pow(float(p),2) + std::pow(float(z),2)),p\&.get_dimensions());
702     }
.fi
.SS "float scifir::cylindrical_to_spherical_r (float p, const \fBangle\fP & theta, float z)\fC [inline]\fP"

.PP
Definition at line 790 of file coordinates_3d\&.hpp\&.
.PP
.nf
791     {
792         return float(std::sqrt(std::pow(p,2) + std::pow(z,2)));
793     }
.fi
.SS "\fBangle\fP scifir::cylindrical_to_spherical_theta (const \fBscalar_unit\fP & p, const \fBangle\fP & theta, const \fBscalar_unit\fP & z)\fC [inline]\fP"

.PP
Definition at line 704 of file coordinates_3d\&.hpp\&.
.PP
.nf
705     {
706         return theta;
707     }
.fi
.SS "\fBangle\fP scifir::cylindrical_to_spherical_theta (float p, const \fBangle\fP & theta, float z)\fC [inline]\fP"

.PP
Definition at line 795 of file coordinates_3d\&.hpp\&.
.PP
.nf
796     {
797         return theta;
798     }
.fi
.SS "float scifir::degree_to_radian (float x)\fC [inline]\fP"

.PP
Converts a degree to a radian\&. 
.PP
Definition at line 22 of file angle\&.hpp\&.
.PP
.nf
23     {
24         return x * PI / 180\&.0f;
25     }
.fi
.SS "string scifir::time_duration::display_as_time () const"

.PP
Definition at line 208 of file unit_basic\&.cpp\&.
.PP
.nf
209     {
210         ostringstream output;
211         scifir::time_duration remaining_time = *this;
212         scifir::time_duration one_year ("365d");
213         if (*this >= one_year)
214         {
215             int total_of_years = int(trunc((*this / one_year)\&.get_value()));
216             output << total_of_years << "y ";
217             remaining_time -= scifir::time_duration(float(total_of_years) * 365,"d");
218         }
219         scifir::time_duration one_month("30d");
220         if (remaining_time >= one_month)
221         {
222             int total_of_months = int(trunc((remaining_time / one_month)\&.get_value()));
223             output << total_of_months << "m ";
224             remaining_time -= scifir::time_duration(float(total_of_months) * 30,"d");
225         }
226         scifir::time_duration one_day("1d");
227         if (remaining_time >= one_day)
228         {
229             int total_of_days = int(trunc((remaining_time / one_day)\&.get_value()));
230             output << total_of_days << "d ";
231             remaining_time -= scifir::time_duration(float(total_of_days),"d");
232         }
233         scifir::time_duration one_hour("1h");
234         if (remaining_time >= one_hour)
235         {
236             int total_of_hours = int(trunc((remaining_time / one_hour)\&.get_value()));
237             output << total_of_hours << "h ";
238             remaining_time -= scifir::time_duration(float(total_of_hours),"h");
239         }
240         scifir::time_duration one_minute("1min");
241         if (remaining_time >= one_minute)
242         {
243             int total_of_minutes = int(trunc((remaining_time / one_minute)\&.get_value()));
244             output << total_of_minutes << "min ";
245             remaining_time -= scifir::time_duration(float(total_of_minutes),"min");
246         }
247         scifir::time_duration one_second("1s");
248         if (remaining_time >= one_second)
249         {
250             remaining_time\&.change_dimensions("s");
251             float total_of_seconds = float(remaining_time\&.get_value());
252             output << total_of_seconds << "s";
253         }
254         return output\&.str();
255     }
.fi
.SS "string scifir::time_duration::display_days () const"

.PP
Definition at line 278 of file unit_basic\&.cpp\&.
.PP
.nf
279     {
280         ostringstream out;
281         out << get_days() << " d";
282         return out\&.str();
283     }
.fi
.SS "string scifir::display_double (const double & value, int number_of_decimals)"

.PP
Definition at line 57 of file types\&.cpp\&.
.PP
.nf
58     {
59         ostringstream output;
60         if (number_of_decimals > 0)
61         {
62             output << (value*std::pow(10,number_of_decimals) / std::pow(10,number_of_decimals));
63         }
64         else
65         {
66             output << value;
67         }
68         if (output\&.str() == "-0")
69         {
70             return "0";
71         }
72         else
73         {
74             return output\&.str();
75         }
76     }
.fi
.SS "string scifir::display_float (const float & value, int number_of_decimals)"

.PP
Definition at line 36 of file types\&.cpp\&.
.PP
.nf
37     {
38         ostringstream output;
39         if (number_of_decimals > 0)
40         {
41             output << (std::trunc(value*std::pow(10,number_of_decimals)) / std::pow(10,number_of_decimals));
42         }
43         else
44         {
45             output << value;
46         }
47         if (output\&.str() == "-0")
48         {
49             return "0";
50         }
51         else
52         {
53             return output\&.str();
54         }
55     }
.fi
.SS "string scifir::time_duration::display_hours () const"

.PP
Definition at line 285 of file unit_basic\&.cpp\&.
.PP
.nf
286     {
287         ostringstream out;
288         out << get_hours() << " h";
289         return out\&.str();
290     }
.fi
.SS "string scifir::display_long_double (const long double & value, int number_of_decimals)"

.PP
Definition at line 78 of file types\&.cpp\&.
.PP
.nf
79     {
80         ostringstream output;
81         if (number_of_decimals > 0)
82         {
83             output << (std::trunc(value*std::pow(10\&.0l,number_of_decimals)) / std::pow(10\&.0l,number_of_decimals));
84         }
85         else
86         {
87             output << value;
88         }
89         if (output\&.str() == "-0")
90         {
91             return "0";
92         }
93         else
94         {
95             return output\&.str();
96         }
97     }
.fi
.SS "string scifir::time_duration::display_minutes () const"

.PP
Definition at line 292 of file unit_basic\&.cpp\&.
.PP
.nf
293     {
294         ostringstream out;
295         out << get_minutes() << " min";
296         return out\&.str();
297     }
.fi
.SS "string scifir::time_duration::display_months () const"

.PP
Definition at line 264 of file unit_basic\&.cpp\&.
.PP
.nf
265     {
266         ostringstream out;
267         out << get_months() << " months";
268         return out\&.str();
269     }
.fi
.SS "string scifir::time_duration::display_seconds () const"

.PP
Definition at line 299 of file unit_basic\&.cpp\&.
.PP
.nf
300     {
301         ostringstream out;
302         out << get_seconds() << " s";
303         return out\&.str();
304     }
.fi
.SS "string scifir::time_duration::display_weeks () const"

.PP
Definition at line 271 of file unit_basic\&.cpp\&.
.PP
.nf
272     {
273         ostringstream out;
274         out << get_weeks() << " weeks";
275         return out\&.str();
276     }
.fi
.SS "string scifir::time_duration::display_years () const"

.PP
Definition at line 257 of file unit_basic\&.cpp\&.
.PP
.nf
258     {
259         ostringstream out;
260         out << get_years() << " y";
261         return out\&.str();
262     }
.fi
.SS "float scifir::distance (const \fBcoordinates_1d\fP< float > & x, const \fBcoordinates_1d\fP< float > & y)"

.PP
Definition at line 13 of file coordinates_1d\&.cpp\&.
.PP
.nf
14     {
15         return float(std::sqrt(std::pow(x\&.x - y\&.x,2)));
16     }
.fi
.SS "float scifir::distance (const \fBcoordinates_1d\fP< float > & x, const \fBpoint_1d\fP< float > & y)"

.PP
Definition at line 18 of file coordinates_1d\&.cpp\&.
.PP
.nf
19     {
20         return float(std::sqrt(std::pow(x\&.x - y\&.x,2)));
21     }
.fi
.SS "template<typename T , typename U > T scifir::distance (const \fBcoordinates_1d\fP< T > & x, const \fBcoordinates_1d\fP< U > & y)"

.PP
Definition at line 217 of file coordinates_1d\&.hpp\&.
.PP
.nf
218     {
219         return scifir::sqrt(scifir::pow(x\&.x - y\&.x,2));
220     }
.fi
.SS "template<typename T , typename U > T scifir::distance (const \fBcoordinates_1d\fP< T > & x, const \fBpoint_1d\fP< U > & y)"

.PP
Definition at line 225 of file coordinates_1d\&.hpp\&.
.PP
.nf
226     {
227         return scifir::sqrt(scifir::pow(x\&.x - y\&.x,2));
228     }
.fi
.SS "float scifir::distance (const \fBcoordinates_2d\fP< float > & x, const \fBcoordinates_2d\fP< float > & y)"

.PP
Definition at line 14 of file coordinates_2d\&.cpp\&.
.PP
.nf
15     {
16         return float(std::sqrt(std::pow(x\&.x - y\&.x,2) + std::pow(x\&.y - y\&.y,2)));
17     }
.fi
.SS "float scifir::distance (const \fBcoordinates_2d\fP< float > & x, const \fBcoordinates_2dr\fP< float > & y)"

.PP
Definition at line 22 of file coordinates_2dr\&.cpp\&.
.PP
.nf
23     {
24         return float(std::sqrt(std::pow(x\&.x - y\&.x,2) + std::pow(x\&.y - y\&.y,2)));
25     }
.fi
.SS "float scifir::distance (const \fBcoordinates_2d\fP< float > & x, const \fBpoint_2d\fP< float > & y)"

.PP
Definition at line 19 of file coordinates_2d\&.cpp\&.
.PP
.nf
20     {
21         return float(std::sqrt(std::pow(x\&.x - y\&.x,2) + std::pow(x\&.y - y\&.y,2)));
22     }
.fi
.SS "template<typename T , typename U > T scifir::distance (const \fBcoordinates_2d\fP< T > & x, const \fBcoordinates_2d\fP< U > & y)"

.PP
Definition at line 351 of file coordinates_2d\&.hpp\&.
.PP
.nf
352     {
353         return scifir::sqrt(scifir::pow(x\&.x - y\&.x,2) + scifir::pow(x\&.y - y\&.y,2));
354     }
.fi
.SS "template<typename T , typename U > T scifir::distance (const \fBcoordinates_2d\fP< T > & x, const \fBcoordinates_2dr\fP< U > & y)"

.PP
Definition at line 508 of file coordinates_2dr\&.hpp\&.
.PP
.nf
509     {
510         return scifir::sqrt(scifir::pow(x\&.x - y\&.x,2) + scifir::pow(x\&.y - y\&.y,2));
511     }
.fi
.SS "template<typename T , typename U > T scifir::distance (const \fBcoordinates_2d\fP< T > & x, const \fBpoint_2d\fP< U > & y)"

.PP
Definition at line 359 of file coordinates_2d\&.hpp\&.
.PP
.nf
360     {
361         return scifir::sqrt(scifir::pow(x\&.x - y\&.x,2) + scifir::pow(x\&.y - y\&.y,2));
362     }
.fi
.SS "float scifir::distance (const \fBcoordinates_2dr\fP< float > & x, const \fBcoordinates_2d\fP< float > & y)"

.PP
Definition at line 17 of file coordinates_2dr\&.cpp\&.
.PP
.nf
18     {
19         return float(std::sqrt(std::pow(x\&.x - y\&.x,2) + std::pow(x\&.y - y\&.y,2)));
20     }
.fi
.SS "float scifir::distance (const \fBcoordinates_2dr\fP< float > & x, const \fBcoordinates_2dr\fP< float > & y)"

.PP
Definition at line 12 of file coordinates_2dr\&.cpp\&.
.PP
.nf
13     {
14         return float(std::sqrt(std::pow(x\&.x - y\&.x,2) + std::pow(x\&.y - y\&.y,2)));
15     }
.fi
.SS "float scifir::distance (const \fBcoordinates_2dr\fP< float > & x, const \fBpoint_2d\fP< float > & y)"

.PP
Definition at line 27 of file coordinates_2dr\&.cpp\&.
.PP
.nf
28     {
29         return float(std::sqrt(std::pow(x\&.x - y\&.x,2) + std::pow(x\&.y - y\&.y,2)));
30     }
.fi
.SS "template<typename T , typename U > T scifir::distance (const \fBcoordinates_2dr\fP< T > & x, const \fBcoordinates_2d\fP< U > & y)"

.PP
Definition at line 500 of file coordinates_2dr\&.hpp\&.
.PP
.nf
501     {
502         return scifir::sqrt(scifir::pow(x\&.x - y\&.x,2) + scifir::pow(x\&.y - y\&.y,2));
503     }
.fi
.SS "template<typename T , typename U > T scifir::distance (const \fBcoordinates_2dr\fP< T > & x, const \fBcoordinates_2dr\fP< U > & y)"

.PP
Definition at line 492 of file coordinates_2dr\&.hpp\&.
.PP
.nf
493     {
494         return scifir::sqrt(scifir::pow(x\&.x - y\&.x,2) + scifir::pow(x\&.y - y\&.y,2));
495     }
.fi
.SS "template<typename T , typename U > T scifir::distance (const \fBcoordinates_2dr\fP< T > & x, const \fBpoint_2d\fP< U > & y)"

.PP
Definition at line 516 of file coordinates_2dr\&.hpp\&.
.PP
.nf
517     {
518         return scifir::sqrt(scifir::pow(x\&.x - y\&.x,2) + scifir::pow(x\&.y - y\&.y,2));
519     }
.fi
.SS "float scifir::distance (const \fBcoordinates_3d\fP< float > & x, const \fBcoordinates_3d\fP< float > & y)"

.PP
Definition at line 12 of file coordinates_3d\&.cpp\&.
.PP
.nf
13     {
14         return float(std::sqrt(std::pow(x\&.x - y\&.x,2) + std::pow(x\&.y - y\&.y,2) + std::pow(x\&.z - y\&.z,2)));
15     }
.fi
.SS "float scifir::distance (const \fBcoordinates_3d\fP< float > & x, const \fBcoordinates_3dr\fP< float > & y)"

.PP
Definition at line 22 of file coordinates_3dr\&.cpp\&.
.PP
.nf
23     {
24         return float(std::sqrt(std::pow(x\&.x - y\&.x,2) + std::pow(x\&.y - y\&.y,2) + std::pow(x\&.z - y\&.z,2)));
25     }
.fi
.SS "float scifir::distance (const \fBcoordinates_3d\fP< float > & x, const \fBpoint_3d\fP< float > & y)"

.PP
Definition at line 17 of file coordinates_3d\&.cpp\&.
.PP
.nf
18     {
19         return float(std::sqrt(std::pow(x\&.x - y\&.x,2) + std::pow(x\&.y - y\&.y,2) + std::pow(x\&.z - y\&.z,2)));
20     }
.fi
.SS "template<typename T , typename U > T scifir::distance (const \fBcoordinates_3d\fP< T > & x, const \fBcoordinates_3d\fP< U > & y)"

.PP
Definition at line 593 of file coordinates_3d\&.hpp\&.
.PP
.nf
594     {
595         return scifir::sqrt(scifir::pow(x\&.x - y\&.x,2) + scifir::pow(x\&.y - y\&.y,2) + scifir::pow(x\&.z - y\&.z,2));
596     }
.fi
.SS "template<typename T , typename U > T scifir::distance (const \fBcoordinates_3d\fP< T > & x, const \fBcoordinates_3dr\fP< U > & y)"

.PP
Definition at line 956 of file coordinates_3dr\&.hpp\&.
.PP
.nf
957     {
958         return scifir::sqrt(scifir::pow(x\&.x - y\&.x,2) + scifir::pow(x\&.y - y\&.y,2) + scifir::pow(x\&.z - y\&.z,2));
959     }
.fi
.SS "template<typename T , typename U > T scifir::distance (const \fBcoordinates_3d\fP< T > & x, const \fBpoint_3d\fP< U > & y)"

.PP
Definition at line 601 of file coordinates_3d\&.hpp\&.
.PP
.nf
602     {
603         return scifir::sqrt(scifir::pow(x\&.x - y\&.x,2) + scifir::pow(x\&.y - y\&.y,2) + scifir::pow(x\&.z - y\&.z,2));
604     }
.fi
.SS "float scifir::distance (const \fBcoordinates_3dr\fP< float > & x, const \fBcoordinates_3d\fP< float > & y)"

.PP
Definition at line 17 of file coordinates_3dr\&.cpp\&.
.PP
.nf
18     {
19         return float(std::sqrt(std::pow(x\&.x - y\&.x,2) + std::pow(x\&.y - y\&.y,2) + std::pow(x\&.z - y\&.z,2)));
20     }
.fi
.SS "float scifir::distance (const \fBcoordinates_3dr\fP< float > & x, const \fBcoordinates_3dr\fP< float > & y)"

.PP
Definition at line 12 of file coordinates_3dr\&.cpp\&.
.PP
.nf
13     {
14         return float(std::sqrt(std::pow(x\&.x - y\&.x,2) + std::pow(x\&.y - y\&.y,2) + std::pow(x\&.z - y\&.z,2)));
15     }
.fi
.SS "float scifir::distance (const \fBcoordinates_3dr\fP< float > & x, const \fBpoint_3d\fP< float > & y)"

.PP
Definition at line 27 of file coordinates_3dr\&.cpp\&.
.PP
.nf
28     {
29         return float(std::sqrt(std::pow(x\&.x - y\&.x,2) + std::pow(x\&.y - y\&.y,2) + std::pow(x\&.z - y\&.z,2)));
30     }
.fi
.SS "template<typename T , typename U > T scifir::distance (const \fBcoordinates_3dr\fP< T > & x, const \fBcoordinates_3d\fP< U > & y)"

.PP
Definition at line 948 of file coordinates_3dr\&.hpp\&.
.PP
.nf
949     {
950         return scifir::sqrt(scifir::pow(x\&.x - y\&.x,2) + scifir::pow(x\&.y - y\&.y,2) + scifir::pow(x\&.z - y\&.z,2));
951     }
.fi
.SS "template<typename T , typename U > T scifir::distance (const \fBcoordinates_3dr\fP< T > & x, const \fBcoordinates_3dr\fP< U > & y)"

.PP
Definition at line 940 of file coordinates_3dr\&.hpp\&.
.PP
.nf
941     {
942         return scifir::sqrt(scifir::pow(x\&.x - y\&.x,2) + scifir::pow(x\&.y - y\&.y,2) + scifir::pow(x\&.z - y\&.z,2));
943     }
.fi
.SS "template<typename T , typename U > T scifir::distance (const \fBcoordinates_3dr\fP< T > & x, const \fBpoint_3d\fP< U > & y)"

.PP
Definition at line 964 of file coordinates_3dr\&.hpp\&.
.PP
.nf
965     {
966         return scifir::sqrt(scifir::pow(x\&.x - y\&.x,2) + scifir::pow(x\&.y - y\&.y,2) + scifir::pow(x\&.z - y\&.z,2));
967     }
.fi
.SS "float scifir::distance (const \fBcoordinates_nd\fP< float > & x, const \fBcoordinates_nd\fP< float > & y)"

.PP
Definition at line 30 of file coordinates_nd\&.cpp\&.
.PP
.nf
31     {
32         if (x\&.get_nd() == y\&.get_nd())
33         {
34             float x_length = 0;
35             for (unsigned int i = 0; i < x\&.values\&.size(); i++)
36             {
37                 x_length += float(std::pow(x\&.values[i] - y\&.values[i],2));
38             }
39             return std::sqrt(x_length);
40         }
41         else
42         {
43             return 0\&.0f;
44         }
45     }
.fi
.SS "float scifir::distance (const \fBcoordinates_nd\fP< float > & x, const \fBcoordinates_ndr\fP< float > & y)"

.PP
Definition at line 82 of file coordinates_ndr\&.cpp\&.
.PP
.nf
83     {
84         if (x\&.get_nd() == y\&.get_nd())
85         {
86             float x_length = 0;
87             for (unsigned int i = 0; i < x\&.values\&.size(); i++)
88             {
89                 x_length += float(std::pow(x\&.values[i] - y\&.get_value(i),2));
90             }
91             return std::sqrt(x_length);
92         }
93         else
94         {
95             return 0\&.0f;
96         }
97     }
.fi
.SS "float scifir::distance (const \fBcoordinates_nd\fP< float > & x, const \fBpoint_nd\fP< float > & y)"

.PP
Definition at line 47 of file coordinates_nd\&.cpp\&.
.PP
.nf
48     {
49         if (x\&.get_nd() == y\&.get_nd())
50         {
51             float x_length = 0;
52             for (unsigned int i = 0; i < x\&.values\&.size(); i++)
53             {
54                 x_length += float(std::pow(x\&.values[i] - y\&.values[i],2));
55             }
56             return std::sqrt(x_length);
57         }
58         else
59         {
60             return 0\&.0f;
61         }
62     }
.fi
.SS "template<typename T , typename U > T scifir::distance (const \fBcoordinates_nd\fP< T > & x, const \fBcoordinates_nd\fP< U > & y)"

.PP
Definition at line 1088 of file coordinates_nd\&.hpp\&.
.PP
.nf
1089     {
1090         if (x\&.get_nd() == y\&.get_nd())
1091         {
1092             scalar_unit x_length = scalar_unit(0\&.0f,"m2");
1093             for (int i = 0; i < x\&.values\&.size(); i++)
1094             {
1095                 x_length += scifir::pow(x\&.values[i] - y\&.values[i],2);
1096             }
1097             return scifir::sqrt(x_length);
1098         }
1099         else
1100         {
1101             return T();
1102         }
1103     }
.fi
.SS "template<typename T , typename U > T scifir::distance (const \fBcoordinates_nd\fP< T > & x, const \fBcoordinates_ndr\fP< U > & y)"

.PP
Definition at line 2226 of file coordinates_ndr\&.hpp\&.
.PP
.nf
2227     {
2228         if (x\&.get_nd() == y\&.get_nd())
2229         {
2230             scalar_unit x_length = scalar_unit(0\&.0f,"m2");
2231             for (int i = 0; i < x\&.values\&.size(); i++)
2232             {
2233                 x_length += scifir::pow(x\&.values[i] - y\&.get_value(i),2);
2234             }
2235             return scifir::sqrt(x_length);
2236         }
2237         else
2238         {
2239             return T();
2240         }
2241     }
.fi
.SS "template<typename T , typename U > T scifir::distance (const \fBcoordinates_nd\fP< T > & x, const \fBpoint_nd\fP< U > & y)"

.PP
Definition at line 1108 of file coordinates_nd\&.hpp\&.
.PP
.nf
1109     {
1110         if (x\&.get_nd() == y\&.get_nd())
1111         {
1112             scalar_unit x_length = scalar_unit(0\&.0f,"m2");
1113             for (int i = 0; i < x\&.values\&.size(); i++)
1114             {
1115                 x_length += scifir::pow(x\&.values[i] - y\&.values[i],2);
1116             }
1117             return scifir::sqrt(x_length);
1118         }
1119         else
1120         {
1121             return T();
1122         }
1123     }
.fi
.SS "float scifir::distance (const \fBcoordinates_ndr\fP< float > & x, const \fBcoordinates_nd\fP< float > & y)"

.PP
Definition at line 65 of file coordinates_ndr\&.cpp\&.
.PP
.nf
66     {
67         if (x\&.get_nd() == y\&.get_nd())
68         {
69             float x_length = 0;
70             for (unsigned int i = 0; i < x\&.get_values()\&.size(); i++)
71             {
72                 x_length += float(std::pow(x\&.get_value(i) - y\&.values[i],2));
73             }
74             return std::sqrt(x_length);
75         }
76         else
77         {
78             return 0\&.0f;
79         }
80     }
.fi
.SS "float scifir::distance (const \fBcoordinates_ndr\fP< float > & x, const \fBcoordinates_ndr\fP< float > & y)"

.PP
Definition at line 48 of file coordinates_ndr\&.cpp\&.
.PP
.nf
49     {
50         if (x\&.get_nd() == y\&.get_nd())
51         {
52             float x_length = 0;
53             for (unsigned int i = 0; i < x\&.get_values()\&.size(); i++)
54             {
55                 x_length += float(std::pow(x\&.get_value(i) - y\&.get_value(i),2));
56             }
57             return std::sqrt(x_length);
58         }
59         else
60         {
61             return 0\&.0f;
62         }
63     }
.fi
.SS "float scifir::distance (const \fBcoordinates_ndr\fP< float > & x, const \fBpoint_nd\fP< float > & y)"

.PP
Definition at line 99 of file coordinates_ndr\&.cpp\&.
.PP
.nf
100     {
101         if (x\&.get_nd() == y\&.get_nd())
102         {
103             float x_length = 0;
104             for (unsigned int i = 0; i < x\&.get_values()\&.size(); i++)
105             {
106                 x_length += float(std::pow(x\&.get_value(i) - y\&.values[i],2));
107             }
108             return std::sqrt(x_length);
109         }
110         else
111         {
112             return 0\&.0f;
113         }
114     }
.fi
.SS "template<typename T , typename U > T scifir::distance (const \fBcoordinates_ndr\fP< T > & x, const \fBcoordinates_nd\fP< U > & y)"

.PP
Definition at line 2206 of file coordinates_ndr\&.hpp\&.
.PP
.nf
2207     {
2208         if (x\&.get_nd() == y\&.get_nd())
2209         {
2210             scalar_unit x_length = scalar_unit(0\&.0f,"m2");
2211             for (int i = 0; i < x\&.get_values()\&.size(); i++)
2212             {
2213                 x_length += scifir::pow(x\&.get_value(i) - y\&.values[i],2);
2214             }
2215             return scifir::sqrt(x_length);
2216         }
2217         else
2218         {
2219             return T();
2220         }
2221     }
.fi
.SS "template<typename T , typename U > T scifir::distance (const \fBcoordinates_ndr\fP< T > & x, const \fBcoordinates_ndr\fP< U > & y)"

.PP
Definition at line 2186 of file coordinates_ndr\&.hpp\&.
.PP
.nf
2187     {
2188         if (x\&.get_nd() == y\&.get_nd())
2189         {
2190             scalar_unit x_length = scalar_unit(0\&.0f,"m2");
2191             for (int i = 0; i < x\&.get_values()\&.size(); i++)
2192             {
2193                 x_length += scifir::pow(x\&.get_value(i) - y\&.get_value(i),2);
2194             }
2195             return scifir::sqrt(x_length);
2196         }
2197         else
2198         {
2199             return T();
2200         }
2201     }
.fi
.SS "template<typename T , typename U > T scifir::distance (const \fBcoordinates_ndr\fP< T > & x, const \fBpoint_nd\fP< U > & y)"

.PP
Definition at line 2246 of file coordinates_ndr\&.hpp\&.
.PP
.nf
2247     {
2248         if (x\&.get_nd() == y\&.get_nd())
2249         {
2250             scalar_unit x_length = scalar_unit(0\&.0f,"m2");
2251             for (int i = 0; i < x\&.get_values()\&.size(); i++)
2252             {
2253                 x_length += scifir::pow(x\&.get_value(i) - y\&.values[i],2);
2254             }
2255             return scifir::sqrt(x_length);
2256         }
2257         else
2258         {
2259             return T();
2260         }
2261     }
.fi
.SS "float scifir::distance (const \fBpoint_1d\fP< float > & x, const \fBcoordinates_1d\fP< float > & y)"

.PP
Definition at line 23 of file coordinates_1d\&.cpp\&.
.PP
.nf
24     {
25         return float(std::sqrt(std::pow(x\&.x - y\&.x,2)));
26     }
.fi
.SS "float scifir::distance (const \fBpoint_1d\fP< float > & x, const \fBpoint_1d\fP< float > & y)"

.PP
Definition at line 33 of file point_1d\&.cpp\&.
.PP
.nf
34     {
35         return float(std::sqrt(std::pow(x\&.x - y\&.x,2)));
36     }
.fi
.SS "template<typename T , typename U > T scifir::distance (const \fBpoint_1d\fP< T > & x, const \fBcoordinates_1d\fP< U > & y)"

.PP
Definition at line 233 of file coordinates_1d\&.hpp\&.
.PP
.nf
234     {
235         return scifir::sqrt(scifir::pow(x\&.x - y\&.x,2));
236     }
.fi
.SS "template<typename T , typename U > T scifir::distance (const \fBpoint_1d\fP< T > & x, const \fBpoint_1d\fP< U > & y)"

.PP
Definition at line 199 of file point_1d\&.hpp\&.
.PP
.nf
200     {
201         return scifir::sqrt(scifir::pow(x\&.x - y\&.x,2));
202     }
.fi
.SS "float scifir::distance (const \fBpoint_2d\fP< float > & x, const \fBcoordinates_2d\fP< float > & y)"

.PP
Definition at line 24 of file coordinates_2d\&.cpp\&.
.PP
.nf
25     {
26         return float(std::sqrt(std::pow(x\&.x - y\&.x,2) + std::pow(x\&.y - y\&.y,2)));
27     }
.fi
.SS "float scifir::distance (const \fBpoint_2d\fP< float > & x, const \fBcoordinates_2dr\fP< float > & y)"

.PP
Definition at line 32 of file coordinates_2dr\&.cpp\&.
.PP
.nf
33     {
34         return float(std::sqrt(std::pow(x\&.x - y\&.x,2) + std::pow(x\&.y - y\&.y,2)));
35     }
.fi
.SS "float scifir::distance (const \fBpoint_2d\fP< float > & x, const \fBpoint_2d\fP< float > & y)"

.PP
Definition at line 35 of file point_2d\&.cpp\&.
.PP
.nf
36     {
37         return float(std::sqrt(std::pow(x\&.x - y\&.x,2) + std::pow(x\&.y - y\&.y,2)));
38     }
.fi
.SS "template<typename T , typename U > T scifir::distance (const \fBpoint_2d\fP< T > & x, const \fBcoordinates_2d\fP< U > & y)"

.PP
Definition at line 367 of file coordinates_2d\&.hpp\&.
.PP
.nf
368     {
369         return scifir::sqrt(scifir::pow(x\&.x - y\&.x,2) + scifir::pow(x\&.y - y\&.y,2));
370     }
.fi
.SS "template<typename T , typename U > T scifir::distance (const \fBpoint_2d\fP< T > & x, const \fBcoordinates_2dr\fP< U > & y)"

.PP
Definition at line 524 of file coordinates_2dr\&.hpp\&.
.PP
.nf
525     {
526         return scifir::sqrt(scifir::pow(x\&.x - y\&.x,2) + scifir::pow(x\&.y - y\&.y,2));
527     }
.fi
.SS "template<typename T , typename U > T scifir::distance (const \fBpoint_2d\fP< T > & x, const \fBpoint_2d\fP< U > & y)"

.PP
Definition at line 328 of file point_2d\&.hpp\&.
.PP
.nf
329     {
330         return scifir::sqrt(scifir::pow(x\&.x - y\&.x,2) + scifir::pow(x\&.y - y\&.y,2));
331     }
.fi
.SS "float scifir::distance (const \fBpoint_3d\fP< float > & x, const \fBcoordinates_3d\fP< float > & y)"

.PP
Definition at line 22 of file coordinates_3d\&.cpp\&.
.PP
.nf
23     {
24         return float(std::sqrt(std::pow(x\&.x - y\&.x,2) + std::pow(x\&.y - y\&.y,2) + std::pow(x\&.z - y\&.z,2)));
25     }
.fi
.SS "float scifir::distance (const \fBpoint_3d\fP< float > & x, const \fBcoordinates_3dr\fP< float > & y)"

.PP
Definition at line 32 of file coordinates_3dr\&.cpp\&.
.PP
.nf
33     {
34         return float(std::sqrt(std::pow(x\&.x - y\&.x,2) + std::pow(x\&.y - y\&.y,2) + std::pow(x\&.z - y\&.z,2)));
35     }
.fi
.SS "float scifir::distance (const \fBpoint_3d\fP< float > & x, const \fBpoint_3d\fP< float > & y)"

.PP
Definition at line 37 of file point_3d\&.cpp\&.
.PP
.nf
38     {
39         return float(std::sqrt(std::pow(x\&.x - y\&.x,2) + std::pow(x\&.y - y\&.y,2) + std::pow(x\&.z - y\&.z,2)));
40     }
.fi
.SS "template<typename T , typename U > T scifir::distance (const \fBpoint_3d\fP< T > & x, const \fBcoordinates_3d\fP< U > & y)"

.PP
Definition at line 609 of file coordinates_3d\&.hpp\&.
.PP
.nf
610     {
611         return scifir::sqrt(scifir::pow(x\&.x - y\&.x,2) + scifir::pow(x\&.y - y\&.y,2) + scifir::pow(x\&.z - y\&.z,2));
612     }
.fi
.SS "template<typename T , typename U > T scifir::distance (const \fBpoint_3d\fP< T > & x, const \fBcoordinates_3dr\fP< U > & y)"

.PP
Definition at line 972 of file coordinates_3dr\&.hpp\&.
.PP
.nf
973     {
974         return scifir::sqrt(scifir::pow(x\&.x - y\&.x,2) + scifir::pow(x\&.y - y\&.y,2) + scifir::pow(x\&.z - y\&.z,2));
975     }
.fi
.SS "template<typename T , typename U > T scifir::distance (const \fBpoint_3d\fP< T > & x, const \fBpoint_3d\fP< U > & y)"

.PP
Definition at line 565 of file point_3d\&.hpp\&.
.PP
.nf
566     {
567         return scifir::sqrt(scifir::pow(x\&.x - y\&.x,2) + scifir::pow(x\&.y - y\&.y,2) + scifir::pow(x\&.z - y\&.z,2));
568     }
.fi
.SS "float scifir::distance (const \fBpoint_nd\fP< float > & x, const \fBcoordinates_nd\fP< float > & y)"

.PP
Definition at line 64 of file coordinates_nd\&.cpp\&.
.PP
.nf
65     {
66         if (x\&.get_nd() == y\&.get_nd())
67         {
68             float x_length = 0;
69             for (unsigned int i = 0; i < x\&.values\&.size(); i++)
70             {
71                 x_length += float(std::pow(x\&.values[i] - y\&.values[i],2));
72             }
73             return std::sqrt(x_length);
74         }
75         else
76         {
77             return 0\&.0f;
78         }
79     }
.fi
.SS "float scifir::distance (const \fBpoint_nd\fP< float > & x, const \fBcoordinates_ndr\fP< float > & y)"

.PP
Definition at line 116 of file coordinates_ndr\&.cpp\&.
.PP
.nf
117     {
118         if (x\&.get_nd() == y\&.get_nd())
119         {
120             float x_length = 0;
121             for (unsigned int i = 0; i < x\&.values\&.size(); i++)
122             {
123                 x_length += float(std::pow(x\&.values[i] - y\&.get_value(i),2));
124             }
125             return std::sqrt(x_length);
126         }
127         else
128         {
129             return 0\&.0f;
130         }
131     }
.fi
.SS "float scifir::distance (const \fBpoint_nd\fP< float > & x, const \fBpoint_nd\fP< float > & y)"

.PP
Definition at line 51 of file point_nd\&.cpp\&.
.PP
.nf
52     {
53         if (x\&.get_nd() == y\&.get_nd())
54         {
55             float x_length = 0;
56             for (unsigned int i = 0; i < x\&.values\&.size(); i++)
57             {
58                 x_length += float(std::pow(x\&.values[i] - y\&.values[i],2));
59             }
60             return std::sqrt(x_length);
61         }
62         else
63         {
64             return float();
65         }
66     }
.fi
.SS "template<typename T , typename U > T scifir::distance (const \fBpoint_nd\fP< T > & x, const \fBcoordinates_nd\fP< U > & y)"

.PP
Definition at line 1128 of file coordinates_nd\&.hpp\&.
.PP
.nf
1129     {
1130         if (x\&.get_nd() == y\&.get_nd())
1131         {
1132             scalar_unit x_length = scalar_unit(0\&.0f,"m2");
1133             for (int i = 0; i < x\&.values\&.size(); i++)
1134             {
1135                 x_length += scifir::pow(x\&.values[i] - y\&.values[i],2);
1136             }
1137             return scifir::sqrt(x_length);
1138         }
1139         else
1140         {
1141             return T();
1142         }
1143     }
.fi
.SS "template<typename T , typename U > T scifir::distance (const \fBpoint_nd\fP< T > & x, const \fBcoordinates_ndr\fP< U > & y)"

.PP
Definition at line 2266 of file coordinates_ndr\&.hpp\&.
.PP
.nf
2267     {
2268         if (x\&.get_nd() == y\&.get_nd())
2269         {
2270             scalar_unit x_length = scalar_unit(0\&.0f,"m2");
2271             for (int i = 0; i < x\&.values\&.size(); i++)
2272             {
2273                 x_length += scifir::pow(x\&.values[i] - y\&.get_value(i),2);
2274             }
2275             return scifir::sqrt(x_length);
2276         }
2277         else
2278         {
2279             return T();
2280         }
2281     }
.fi
.SS "template<typename T , typename U > T scifir::distance (const \fBpoint_nd\fP< T > & x1, const \fBpoint_nd\fP< U > & x2)"

.PP
Definition at line 1072 of file point_nd\&.hpp\&.
.PP
.nf
1073     {
1074         if (x1\&.get_nd() == x2\&.get_nd())
1075         {
1076             scalar_unit x_length = scalar_unit(0\&.0f,"m2");
1077             for (int i = 0; i < x1\&.values\&.size(); i++)
1078             {
1079                 x_length += scifir::pow(x1\&.values[i] - x2\&.values[i],2);
1080             }
1081             return scifir::sqrt(x_length);
1082         }
1083         else
1084         {
1085             return T();
1086         }
1087     }
.fi
.SS "vector< \fBdimension\fP > scifir::divide_dimensions (vector< \fBdimension\fP > x, const vector< \fBdimension\fP > & y, long double & value)"

.PP
Divides the first vector of dimensions with the other\&. The result is normalized after, which means that equal dimensions at the numerator and at the denominator are cancelled\&. It also updates the value associated with those two vectors of dimensions with the prefix m ath and the conversion factor of those dimensions\&. 
.PP
Definition at line 1398 of file dimension\&.cpp\&.
.PP
.nf
1399     {
1400         for(dimension y_dimension : y)
1401         {
1402             y_dimension\&.invert();
1403             x\&.push_back(y_dimension);
1404         }
1405         return normalize_dimensions(x,value);
1406     }
.fi
.SS "\fBscalar_unit\fP scifir::dot_product (const \fBvector_unit_2d\fP & x, const \fBvector_unit_2d\fP & y)"

.PP
Creates a \fBscalar_unit\fP as the dot product of the two vectors x and y\&. 
.PP
Definition at line 338 of file vector_unit_2d\&.cpp\&.
.PP
.nf
339     {
340         long double new_value = (x\&.x_projection() * y\&.x_projection() + x\&.y_projection() * y\&.y_projection())\&.get_value();
341         vector<dimension> new_dimensions = multiply_dimensions(x\&.get_dimensions(), y\&.get_dimensions(),new_value);
342         return scalar_unit(new_value,new_dimensions);
343     }
.fi
.SS "\fBscalar_unit\fP scifir::dot_product (const \fBvector_unit_3d\fP & x, const \fBvector_unit_3d\fP & y)"

.PP
Creates a \fBscalar_unit\fP as the dot product of the two vectors x and y\&. 
.PP
Definition at line 443 of file vector_unit_3d\&.cpp\&.
.PP
.nf
444     {
445         long double new_value = float(x\&.x_projection()*y\&.x_projection() + x\&.y_projection()*y\&.y_projection() + x\&.z_projection()*y\&.z_projection());
446         vector<dimension> new_dimensions = multiply_dimensions(x\&.get_dimensions(), y\&.get_dimensions(),new_value);
447         return scalar_unit(float(new_value),new_dimensions);
448     }
.fi
.SS "\fBscalar_unit\fP scifir::dot_product (const \fBvector_unit_nd\fP & x, const \fBvector_unit_nd\fP & y)"

.PP
Creates a \fBscalar_unit\fP as the dot product of the two vectors x and y\&. 
.PP
Definition at line 759 of file vector_unit_nd\&.cpp\&.
.PP
.nf
760     {
761         long double new_value = float(x\&.x_projection()*y\&.x_projection() + x\&.y_projection()*y\&.y_projection() + x\&.z_projection()*y\&.z_projection());
762         vector<dimension> new_dimensions = multiply_dimensions(x\&.get_dimensions(), y\&.get_dimensions(),new_value);
763         return scalar_unit(float(new_value),new_dimensions);
764     }
.fi
.SS "bool scifir::equal_dimensions (const string & init_dimensions_x, const string & init_dimensions_y)"

.PP
Checks if two initialization strings of dimensions initialize the same basic dimensions\&. 
.PP
Definition at line 1629 of file dimension\&.cpp\&.
.PP
.nf
1630     {
1631         vector<dimension> x_dimensions = create_dimensions(init_dimensions_x);
1632         vector<dimension> y_dimensions = create_dimensions(init_dimensions_y);
1633         return equal_dimensions(x_dimensions,y_dimensions);
1634     }
.fi
.SS "bool scifir::equal_dimensions (const vector< \fBdimension\fP > & x, const vector< \fBdimension\fP > & y)"
brief Checks if the derived dimensions of two vectors of dimensions are equal\&. 
.PP
Definition at line 1636 of file dimension\&.cpp\&.
.PP
.nf
1637     {
1638         vector<dimension> x_derived_dimensions = create_derived_dimensions(x);
1639         vector<dimension> y_derived_dimensions = create_derived_dimensions(y);
1640         if (x_derived_dimensions\&.size() == y_derived_dimensions\&.size())
1641         {
1642             vector<unsigned int> skip = vector<unsigned int>();
1643             for (const dimension& x_dimension: x_derived_dimensions)
1644             {
1645                 bool is_equal = false;
1646                 for (unsigned int j = 0; j < y_derived_dimensions\&.size(); j++)
1647                 {
1648                     bool skip_j = false;
1649                     if (skip\&.size() > 0)
1650                     {
1651                         for (unsigned int k = 0; k < skip\&.size(); k++)
1652                         {
1653                             if (j == skip[k])
1654                             {
1655                                 skip_j = true;
1656                             }
1657                         }
1658                     }
1659                     if (skip_j)
1660                     {
1661                         continue;
1662                     }
1663                     if (x_dimension == y_derived_dimensions[j])
1664                     {
1665                         skip\&.push_back(j);
1666                         is_equal = true;
1667                         break;
1668                     }
1669                 }
1670                 if (!is_equal)
1671                 {
1672                     return false;
1673                 }
1674             }
1675             return true;
1676         }
1677         else
1678         {
1679             return false;
1680         }
1681     }
.fi
.SS "bool scifir::equal_dimensions_and_prefixes (const vector< \fBdimension\fP > & x, const vector< \fBdimension\fP > & y)"

.PP
Checks if the derived dimensions of two vectors of dimensions are equal, and if they have also the same prefixes\&. 
.PP
Definition at line 1683 of file dimension\&.cpp\&.
.PP
.nf
1684     {
1685         vector<unsigned int> skip = vector<unsigned int>();
1686         if (x\&.size() == y\&.size())
1687         {
1688             for (const dimension& x_dimension: x)
1689             {
1690                 bool is_equal = false;
1691                 for (unsigned int j = 0; j < y\&.size(); j++)
1692                 {
1693                     bool skip_j = false;
1694                     if (skip\&.size() > 0)
1695                     {
1696                         for (unsigned int k = 0; k < skip\&.size(); k++)
1697                         {
1698                             if (j == skip[k])
1699                             {
1700                                 skip_j = true;
1701                             }
1702                         }
1703                     }
1704                     if (skip_j)
1705                     {
1706                         continue;
1707                     }
1708                     if (x_dimension == y[j] and x_dimension\&.prefix == y[j]\&.prefix)
1709                     {
1710                         skip\&.push_back(j);
1711                         is_equal = true;
1712                         break;
1713                     }
1714                 }
1715                 if (!is_equal)
1716                 {
1717                     return false;
1718                 }
1719             }
1720             return true;
1721         }
1722         else
1723         {
1724             return false;
1725         }
1726     }
.fi
.SS "int scifir::time_duration::get_days () const"

.PP
Definition at line 132 of file unit_basic\&.cpp\&.
.PP
.nf
133     {
134         scifir::time_duration one_day("1d");
135         if (*this >= one_day)
136         {
137             return int(trunc((*this / one_day)\&.get_value()));
138         }
139         else
140         {
141             return 0;
142         }
143     }
.fi
.SS "string scifir::get_finish_date () const"

.SS "int scifir::time_duration::get_hours () const"

.PP
Definition at line 145 of file unit_basic\&.cpp\&.
.PP
.nf
146     {
147         scifir::time_duration one_hour("1h");
148         if (*this >= one_hour)
149         {
150             return int(trunc((*this / one_hour)\&.get_value()));
151         }
152         else
153         {
154             return 0;
155         }
156     }
.fi
.SS "int scifir::time_duration::get_minutes () const"

.PP
Definition at line 158 of file unit_basic\&.cpp\&.
.PP
.nf
159     {
160         scifir::time_duration one_minute = scifir::time_duration("1min");
161         if (*this >= one_minute)
162         {
163             return int(trunc((*this / one_minute)\&.get_value()));
164         }
165         else
166         {
167             return 0;
168         }
169     }
.fi
.SS "int scifir::time_duration::get_months () const"

.PP
Definition at line 106 of file unit_basic\&.cpp\&.
.PP
.nf
107     {
108         scifir::time_duration one_month("30d");
109         if (*this >= one_month)
110         {
111             return int(trunc((*this / one_month)\&.get_value()));
112         }
113         else
114         {
115             return 0;
116         }
117     }
.fi
.SS "int scifir::time_duration::get_seconds () const"

.PP
Definition at line 171 of file unit_basic\&.cpp\&.
.PP
.nf
172     {
173         scifir::time_duration one_second("1s");
174         if (*this >= one_second)
175         {
176             return int(trunc((*this / one_second)\&.get_value()));
177         }
178         else
179         {
180             return 0;
181         }
182     }
.fi
.SS "int scifir::time_duration::get_weeks () const"

.PP
Definition at line 119 of file unit_basic\&.cpp\&.
.PP
.nf
120     {
121         scifir::time_duration one_week("7d");
122         if (*this >= one_week)
123         {
124             return int(trunc((*this / one_week)\&.get_value()));
125         }
126         else
127         {
128             return 0;
129         }
130     }
.fi
.SS "int scifir::time_duration::get_years () const"

.PP
Definition at line 93 of file unit_basic\&.cpp\&.
.PP
.nf
94     {
95         scifir::time_duration one_year ("365d");
96         if (*this >= one_year)
97         {
98             return int(trunc((*this / one_year)\&.get_value()));
99         }
100         else
101         {
102             return 0;
103         }
104     }
.fi
.SS "\fBdirection::name\fP scifir::invert (\fBdirection::name\fP x)"

.PP
Definition at line 167 of file direction\&.cpp\&.
.PP
.nf
168     {
169         if (x == direction::LEFT)
170         {
171             return direction::RIGHT;
172         }
173         else if (x == direction::RIGHT)
174         {
175             return direction::LEFT;
176         }
177         else if (x == direction::TOP)
178         {
179             return direction::BOTTOM;
180         }
181         else if (x == direction::BOTTOM)
182         {
183             return direction::TOP;
184         }
185         else if (x == direction::FRONT)
186         {
187             return direction::BACK;
188         }
189         else if (x == direction::BACK)
190         {
191             return direction::FRONT;
192         }
193         else if (x == direction::LEFT_TOP)
194         {
195             return direction::RIGHT_BOTTOM;
196         }
197         else if (x == direction::LEFT_BOTTOM)
198         {
199             return direction::RIGHT_TOP;
200         }
201         else if (x == direction::RIGHT_TOP)
202         {
203             return direction::LEFT_BOTTOM;
204         }
205         else if (x == direction::RIGHT_BOTTOM)
206         {
207             return direction::LEFT_TOP;
208         }
209         else if (x == direction::LEFT_FRONT)
210         {
211             return direction::RIGHT_BACK;
212         }
213         else if (x == direction::LEFT_BACK)
214         {
215             return direction::RIGHT_FRONT;
216         }
217         else if (x == direction::RIGHT_FRONT)
218         {
219             return direction::LEFT_BACK;
220         }
221         else if (x == direction::RIGHT_BACK)
222         {
223             return direction::LEFT_FRONT;
224         }
225         else if (x == direction::TOP_FRONT)
226         {
227             return direction::BOTTOM_BACK;
228         }
229         else if (x == direction::TOP_BACK)
230         {
231             return direction::BOTTOM_FRONT;
232         }
233         else if (x == direction::BOTTOM_FRONT)
234         {
235             return direction::TOP_BACK;
236         }
237         else if (x == direction::BOTTOM_BACK)
238         {
239             return direction::TOP_FRONT;
240         }
241         else if (x == direction::LEFT_TOP_FRONT)
242         {
243             return direction::RIGHT_BOTTOM_BACK;
244         }
245         else if (x == direction::LEFT_TOP_BACK)
246         {
247             return direction::RIGHT_BOTTOM_FRONT;
248         }
249         else if (x == direction::LEFT_BOTTOM_FRONT)
250         {
251             return direction::RIGHT_TOP_BACK;
252         }
253         else if (x == direction::LEFT_BOTTOM_BACK)
254         {
255             return direction::RIGHT_TOP_FRONT;
256         }
257         else if (x == direction::RIGHT_TOP_FRONT)
258         {
259             return direction::LEFT_BOTTOM_BACK;
260         }
261         else if (x == direction::RIGHT_TOP_BACK)
262         {
263             return direction::LEFT_BOTTOM_FRONT;
264         }
265         else if (x == direction::RIGHT_BOTTOM_FRONT)
266         {
267             return direction::LEFT_TOP_BACK;
268         }
269         else if (x == direction::RIGHT_BOTTOM_BACK)
270         {
271             return direction::LEFT_TOP_FRONT;
272         }
273         else
274         {
275             return direction::NONE;
276         }
277     }
.fi
.SS "bool scifir::is_angle (const string & init_angle)"

.PP
Checks if some string is an initialization string of an angle\&. 
.PP
Definition at line 278 of file angle\&.cpp\&.
.PP
.nf
279     {
280         icu::UnicodeString x_unicode = icu::UnicodeString(init_angle\&.c_str());
281         int total_chars = x_unicode\&.countChar32();
282         if (x_unicode[total_chars - 1] == 0x00B0 || x_unicode[total_chars - 1] == 0x00BA)
283         {
284             bool dot_present = false;
285             for (int i = 0; i < (total_chars - 1); i++)
286             {
287                 if (x_unicode[i] == '\&.')
288                 {
289                     if (dot_present)
290                     {
291                         return false;
292                     }
293                     else
294                     {
295                         dot_present = true;
296                     }
297                 }
298                 else if (!u_isdigit(x_unicode[i]))
299                 {
300                     return false;
301                 }
302             }
303             return true;
304         }
305         else
306         {
307             return false;
308         }
309     }
.fi
.SS "bool scifir::is_complex (const string & init_complex_number)"

.PP
Definition at line 7 of file complex_number\&.cpp\&.
.PP
.nf
8     {
9         if ((init_complex_number\&.find("+") != string::npos or init_complex_number\&.find("-") != string::npos) and init_complex_number\&.length() > 1)
10         {
11             vector<string> numbers;
12             boost::split(numbers,init_complex_number,boost::is_any_of("+-"));
13             if (numbers\&.size() != 2)
14             {
15                 return false;
16             }
17             int imaginary_length = int(numbers[1]\&.length()) - 3;
18             if (imaginary_length <= 0)
19             {
20                 return false;
21             }
22             if (numbers[1]\&.substr(imaginary_length) == "(i)")
23             {
24                 bool dot_present = false;
25                 bool after_whitespace = false;
26                 bool after_alpha = false;
27                 boost::trim(numbers[0]);
28                 boost::trim(numbers[1]);
29                 for (unsigned int i = 0; i < numbers[0]\&.length(); i++)
30                 {
31                     if (numbers[0][i] == '\&.')
32                     {
33                         if (dot_present)
34                         {
35                             return false;
36                         }
37                         else
38                         {
39                             dot_present = true;
40                             continue;
41                         }
42                     }
43                     else if (numbers[0][i] == ' ')
44                     {
45                         after_whitespace = true;
46                         continue;
47                     }
48                     else if (!std::isdigit(numbers[0][i]) and after_whitespace == false)
49                     {
50                         return false;
51                     }
52                     else if (after_whitespace == true)
53                     {
54                         if (after_alpha == true and std::isalpha(numbers[0][i]))
55                         {
56                             return false;
57                         }
58                         else if (std::isalpha(numbers[0][i]))
59                         {
60                             continue;
61                         }
62                         else if (std::isdigit(numbers[0][i]))
63                         {
64                             after_alpha = true;
65                         }
66                     }
67                 }
68                 dot_present = false;
69                 after_whitespace = false;
70                 after_alpha = false;
71                 for (unsigned int i = 0; i < imaginary_length; i++)
72                 {
73                     if (numbers[1][i] == '\&.')
74                     {
75                         if (dot_present)
76                         {
77                             return false;
78                         }
79                         else
80                         {
81                             dot_present = true;
82                             continue;
83                         }
84                     }
85                     else if (numbers[1][i] == ' ')
86                     {
87                         after_whitespace = true;
88                         continue;
89                     }
90                     else if (!std::isdigit(numbers[1][i]) and after_whitespace == false)
91                     {
92                         return false;
93                     }
94                     else if (after_whitespace == true)
95                     {
96                         if (after_alpha == true and std::isalpha(numbers[1][i]))
97                         {
98                             return false;
99                         }
100                         else if (std::isalpha(numbers[1][i]))
101                         {
102                             continue;
103                         }
104                         else if (std::isdigit(numbers[1][i]))
105                         {
106                             after_alpha = true;
107                         }
108                     }
109                 }
110                 return true;
111             }
112             else
113             {
114                 return false;
115             }
116         }
117         else
118         {
119             return false;
120         }
121     }
.fi
.SS "bool scifir::is_lab_number (const string & init_lab_number)"

.PP
Definition at line 7 of file lab_number\&.cpp\&.
.PP
.nf
8     {
9         if ((init_lab_number\&.find("\u00B1") != string::npos or init_lab_number\&.find("+") != string::npos or init_lab_number\&.find("-") != string::npos) and init_lab_number\&.length() > 1)
10         {
11             vector<string> numbers;
12             boost::split(numbers,init_lab_number,boost::is_any_of("+-,\u00B1"));
13             if (numbers\&.size() != 3)
14             {
15                 return false;
16             }
17             if (numbers[2]\&.length() < 1)
18             {
19                 return false;
20             }
21             bool dot_present = false;
22             bool after_whitespace = false;
23             bool after_alpha = false;
24             boost::trim(numbers[0]);
25             boost::trim(numbers[2]);
26             for (unsigned int i = 0; i < numbers[0]\&.length(); i++)
27             {
28                 if (numbers[0][i] == '\&.')
29                 {
30                     if (dot_present)
31                     {
32                         return false;
33                     }
34                     else
35                     {
36                         dot_present = true;
37                         continue;
38                     }
39                 }
40                 else if (numbers[0][i] == ' ')
41                 {
42                     after_whitespace = true;
43                     continue;
44                 }
45                 else if (!std::isdigit(numbers[0][i]) and after_whitespace == false)
46                 {
47                     return false;
48                 }
49                 else if (after_whitespace == true)
50                 {
51                     if (after_alpha == true and std::isalpha(numbers[0][i]))
52                     {
53                         return false;
54                     }
55                     else if (std::isalpha(numbers[0][i]))
56                     {
57                         continue;
58                     }
59                     else if (std::isdigit(numbers[0][i]))
60                     {
61                         after_alpha = true;
62                     }
63                 }
64             }
65             dot_present = false;
66             after_whitespace = false;
67             after_alpha = false;
68             for (unsigned int i = 0; i < numbers[2]\&.length(); i++)
69             {
70                 if (numbers[2][i] == '\&.')
71                 {
72                     if (dot_present)
73                     {
74                         return false;
75                     }
76                     else
77                     {
78                         dot_present = true;
79                         continue;
80                     }
81                 }
82                 else if (numbers[2][i] == ' ')
83                 {
84                     after_whitespace = true;
85                     continue;
86                 }
87                 else if (!std::isdigit(numbers[2][i]) and after_whitespace == false)
88                 {
89                     return false;
90                 }
91                 else if (after_whitespace == true)
92                 {
93                     if (after_alpha == true and std::isalpha(numbers[2][i]))
94                     {
95                         return false;
96                     }
97                     else if (std::isalpha(numbers[2][i]))
98                     {
99                         continue;
100                     }
101                     else if (std::isdigit(numbers[2][i]))
102                     {
103                         after_alpha = true;
104                     }
105                 }
106             }
107             return true;
108         }
109         else
110         {
111             return false;
112         }
113     }
.fi
.SS "bool scifir::is_percentage (const string & init_percentage)"

.PP
Definition at line 476 of file percentage\&.cpp\&.
.PP
.nf
477     {
478         int iteration_limit;
479         if (init_percentage\&.back() == '%')
480         {
481             iteration_limit = int(init_percentage\&.length()) - 1;
482         }
483         else
484         {
485             string percentage_unit = init_percentage\&.substr(init_percentage\&.length() - 4,4);
486             if (percentage_unit == " ppm"/* or percentage_unit == " ppb" or percentage_unit == " ppt" or percentage_unit == " ppq"*/)
487             {
488                 iteration_limit = int(init_percentage\&.length()) - 4;
489             }
490             else
491             {
492                 percentage_unit = init_percentage\&.substr(init_percentage\&.length() - 3,3);
493                 if (percentage_unit == "ppm"/* or percentage_unit == "ppb" or percentage_unit == "ppt" or percentage_unit == "ppq"*/)
494                 {
495                     iteration_limit = int(init_percentage\&.length()) - 3;
496                 }
497                 else
498                 {
499                     return false;
500                 }
501             }
502         }
503         bool dot_present = false;
504         for (int i = 0; i < iteration_limit; i++)
505         {
506             if (init_percentage[i] == '\&.')
507             {
508                 if (dot_present)
509                 {
510                     return false;
511                 }
512                 else
513                 {
514                     dot_present = true;
515                 }
516             }
517             else if (!std::isdigit(init_percentage[i]))
518             {
519                 return false;
520             }
521         }
522         return true;
523     }
.fi
.SS "bool scifir::is_pixel (const string & init_pixel)"

.PP
Definition at line 191 of file pixel\&.cpp\&.
.PP
.nf
192     {
193         int iteration_limit;
194         if (init_pixel\&.substr(init_pixel\&.length() - 3,3) == " px")
195         {
196             iteration_limit = int(init_pixel\&.length()) - 3;
197         }
198         else if (init_pixel\&.substr(init_pixel\&.length() - 2,2) == "px")
199         {
200             iteration_limit = int(init_pixel\&.length()) - 2;
201         }
202         else
203         {
204             iteration_limit = int(init_pixel\&.length());
205         }
206         bool dot_present = false;
207         for (int i = 0; i < iteration_limit; i++)
208         {
209             if (init_pixel[i] == '\&.')
210             {
211                 if (dot_present)
212                 {
213                     return false;
214                 }
215                 else
216                 {
217                     dot_present = true;
218                 }
219             }
220             else if (!std::isdigit(init_pixel[i]))
221             {
222                 return false;
223             }
224         }
225         return true;
226     }
.fi
.SS "bool scifir::is_scalar_unit (const string & init_scalar)"

.PP
Checks if an string is an initialization string of a \fBscalar_unit\fP\&. 
.PP
\fBParameters\fP
.RS 4
\fIinit_scalar\fP string to check\&. It must be an initialization string of a \fBscalar_unit\fP to return true\&. 
.RE
.PP

.PP
Definition at line 542 of file scalar_unit\&.cpp\&.
.PP
.nf
543     {
544         bool dot_present = false;
545         bool e_present = false;
546         unsigned int current_pos = 0;
547         int e_present_pos = 0;
548         for (unsigned int i = 0; i < init_scalar\&.length(); i++)
549         {
550             if (init_scalar[i] == ' ')
551             {
552                 if (e_present and ((unsigned int)(e_present_pos + 1) == i))
553                 {
554                     return false;
555                 }
556                 current_pos = i;
557                 break;
558             }
559             if (e_present == false)
560             {
561                 if (init_scalar[i] == '\&.')
562                 {
563                     if (dot_present)
564                     {
565                         return false;
566                     }
567                     else
568                     {
569                         dot_present = true;
570                     }
571                 }
572                 else if (init_scalar[i] == 'e' or init_scalar[i] == 'E')
573                 {
574                     e_present = true;
575                     e_present_pos = i;
576                     continue;
577                 }
578                 else if (init_scalar[i] == '*')
579                 {
580                     if (!(init_scalar\&.substr(i + 1,3) == "10^"))
581                     {
582                         return false;
583                     }
584                     else
585                     {
586                         e_present = true;
587                         i += 3;
588                         e_present_pos = i;
589                         continue;
590                     }
591                 }
592                 else if (!isdigit(init_scalar[i]))
593                 {
594                     return false;
595                 }
596                 else if (i == (init_scalar\&.length() - 1))
597                 {
598                     return false;
599                 }
600             }
601             else
602             {
603                 if (!isdigit(init_scalar[i]))
604                 {
605                     return false;
606                 }
607             }
608         }
609         if (current_pos == (init_scalar\&.length() - 1))
610         {
611             return false;
612         }
613         if (current_pos == 0)
614         {
615             return false;
616         }
617         vector<string> values;
618         boost::split(values,init_scalar\&.substr(current_pos),boost::is_any_of("/"));
619         if (values\&.size() == 1)
620         {
621             vector<string> subvalues;
622             boost::split(subvalues,values[0],boost::is_any_of("*"));
623             for (string& x_subvalue : subvalues)
624             {
625                 boost::trim(x_subvalue);
626                 bool number_present = false;
627                 for (unsigned int i = 0; i < x_subvalue\&.length(); i++)
628                 {
629                     if (number_present == false)
630                     {
631                         if (isdigit(x_subvalue[i]))
632                         {
633                             number_present = true;
634                             continue;
635                         }
636                         else if (!isalpha(x_subvalue[i]))
637                         {
638                             return false;
639                         }
640                     }
641                     else
642                     {
643                         if (!isdigit(x_subvalue[i]))
644                         {
645                             return false;
646                         }
647                     }
648                 }
649             }
650             return true;
651         }
652         else if (values\&.size() == 2)
653         {
654             if (values[0] != "1")
655             {
656                 vector<string> subvalues;
657                 boost::split(subvalues,values[0],boost::is_any_of("*"));
658                 for (string& x_subvalue : subvalues)
659                 {
660                     boost::trim(x_subvalue);
661                     bool number_present = false;
662                     for (unsigned int i = 0; i < x_subvalue\&.length(); i++)
663                     {
664                         if (number_present == false)
665                         {
666                             if (isdigit(x_subvalue[i]))
667                             {
668                                 number_present = true;
669                                 continue;
670                             }
671                             else if (!isalpha(x_subvalue[i]))
672                             {
673                                 return false;
674                             }
675                         }
676                         else
677                         {
678                             if (!isdigit(x_subvalue[i]))
679                             {
680                                 return false;
681                             }
682                         }
683                     }
684                 }
685             }
686             vector<string> subvalues_denominator;
687             boost::split(subvalues_denominator,values[1],boost::is_any_of("*"));
688             for (string& x_subvalue : subvalues_denominator)
689             {
690                 boost::trim(x_subvalue);
691                 bool number_present = false;
692                 for (unsigned int i = 0; i < x_subvalue\&.length(); i++)
693                 {
694                     if (number_present == false)
695                     {
696                         if (isdigit(x_subvalue[i]))
697                         {
698                             number_present = true;
699                             continue;
700                         }
701                         else if (!isalpha(x_subvalue[i]))
702                         {
703                             return false;
704                         }
705                     }
706                     else
707                     {
708                         if (!isdigit(x_subvalue[i]))
709                         {
710                             return false;
711                         }
712                     }
713                 }
714             }
715             return true;
716         }
717         return false;
718     }
.fi
.SS "scifir::mass::mass (const \fBpercentage\fP & new_percentage, const mass & new_mass)"

.PP
Definition at line 308 of file unit_basic\&.cpp\&.
.PP
.nf
308                                                                     : scalar_unit()
309     {
310         dimensions = new_mass\&.get_dimensions();
311         value = new_percentage * new_mass\&.get_value();
312     }
.fi
.SS "scifir::mass::mass (const string & init_percentage, const string & init_mass)"

.PP
Definition at line 314 of file unit_basic\&.cpp\&.
.PP
.nf
314                                                                     : scalar_unit()
315     {
316         initialize_from_string(init_mass);
317         percentage new_percentage = percentage(init_percentage);
318         value = new_percentage * value;
319     }
.fi
.SS "scifir::mole::mole (const \fBpercentage\fP & new_percentage, const mole & new_mole)"

.PP
Definition at line 325 of file unit_basic\&.cpp\&.
.PP
.nf
325                                                                     : scalar_unit()
326     {
327         dimensions = new_mole\&.get_dimensions();
328         value = new_percentage * new_mole\&.get_value();
329     }
.fi
.SS "scifir::mole::mole (const string & init_percentage, const string & init_mole)"

.PP
Definition at line 331 of file unit_basic\&.cpp\&.
.PP
.nf
331                                                                     : scalar_unit()
332     {
333         initialize_from_string(init_mole);
334         percentage new_percentage = percentage(init_percentage);
335         value = new_percentage * value;
336     }
.fi
.SS "vector< \fBdimension\fP > scifir::multiply_dimensions (const vector< \fBdimension\fP > & x, const vector< \fBdimension\fP > & y)"

.PP
Multiplies two vectors of dimensions\&. The result is normalized after, which means that equal dimensions at the numerator and at the denominator are cancelled\&. 
.PP
Definition at line 1379 of file dimension\&.cpp\&.
.PP
.nf
1380     {
1381         vector<dimension> new_dimensions = x;
1382         for(const dimension& y_dimension : y)
1383         {
1384             new_dimensions\&.push_back(y_dimension);
1385         }
1386         return new_dimensions;
1387     }
.fi
.SS "vector< \fBdimension\fP > scifir::multiply_dimensions (vector< \fBdimension\fP > x, const vector< \fBdimension\fP > & y, long double & value)"

.PP
Multiplies two vectors of dimensions\&. The result is normalized after, which means that equal dimensions at the numerator and at the denominator are cancelled\&. It also updates the value associated with those two vectors of dimensions with the prefix m ath and the conversion factor of those dimensions\&. 
.PP
Definition at line 1389 of file dimension\&.cpp\&.
.PP
.nf
1390     {
1391         for(const dimension& y_dimension : y)
1392         {
1393             x\&.push_back(y_dimension);
1394         }
1395         return normalize_dimensions(x,value);
1396     }
.fi
.SS "\fBscalar_unit\fP scifir::norm (const \fBvector_unit_2d\fP & x)"

.PP
It returns the value of the vector in polar coordinates, p\&. 
.PP
Definition at line 321 of file vector_unit_2d\&.cpp\&.
.PP
.nf
322     {
323         return scalar_unit(std::abs(x\&.get_value()),x\&.get_dimensions());
324     }
.fi
.SS "\fBscalar_unit\fP scifir::norm (const \fBvector_unit_3d\fP & x)"

.PP
It returns the value of the vector in spherical coordinates, r\&. 
.PP
Definition at line 426 of file vector_unit_3d\&.cpp\&.
.PP
.nf
427     {
428         return scalar_unit(std::abs(x\&.get_value()),x\&.get_dimensions());
429     }
.fi
.SS "\fBscalar_unit\fP scifir::norm (const \fBvector_unit_nd\fP & x)"

.PP
It returns the value of the vector, which is the value in 1D, p in 2D (polar coordinates), or r in 3D (spherical coordinates)\&. 
.PP
Definition at line 742 of file vector_unit_nd\&.cpp\&.
.PP
.nf
743     {
744         return scalar_unit(std::abs(x\&.get_value()),x\&.get_dimensions());
745     }
.fi
.SS "vector< \fBdimension\fP > scifir::normalize_dimensions (const vector< \fBdimension\fP > & x)"

.PP
Normalizes the dimensions, which means that repited dimensions at the numerator and at the denominator are cancelled\&. 
.PP
Definition at line 1493 of file dimension\&.cpp\&.
.PP
.nf
1494     {
1495         vector<dimension> new_x = create_derived_dimensions(x);
1496         vector<unsigned int> skip_dimensions = vector<unsigned int>();
1497         for(unsigned int i = 0; i < new_x\&.size(); i++)
1498         {
1499             for(unsigned int j = i + 1; j < new_x\&.size(); j++)
1500             {
1501                 if (skip_dimensions\&.size() > 0)
1502                 {
1503                     bool skip = false;
1504                     for(unsigned int k = 0; k < skip_dimensions\&.size(); k++)
1505                     {
1506                         if (j == skip_dimensions[k])
1507                         {
1508                             skip = true;
1509                         }
1510                     }
1511                     if (skip)
1512                     {
1513                         continue;
1514                     }
1515                 }
1516                 if (new_x[i]\&.dimension_type == new_x[j]\&.dimension_type and new_x[i]\&.dimension_position != new_x[j]\&.dimension_position)
1517                 {
1518                     skip_dimensions\&.push_back(i);
1519                     skip_dimensions\&.push_back(j);
1520                     break;
1521                 }
1522             }
1523         }
1524         vector<dimension> new_dimensions = vector<dimension>();
1525         for(unsigned int i = 0; i < new_x\&.size(); i++)
1526         {
1527             bool skip = false;
1528             for(unsigned int j = 0; j < skip_dimensions\&.size(); j++)
1529             {
1530                 if (i == skip_dimensions[j])
1531                 {
1532                     skip = true;
1533                 }
1534             }
1535             if (!skip)
1536             {
1537                 new_dimensions\&.push_back(new_x[i]);
1538             }
1539         }
1540         return new_dimensions;
1541     }
.fi
.SS "vector< \fBdimension\fP > scifir::normalize_dimensions (const vector< \fBdimension\fP > & x, long double & value)"

.PP
Normalizes the dimensions, which means that repited dimensions at the numerator and at the denominator are cancelled\&. The value is updated if there are dimensions cancelled\&. 
.PP
Definition at line 1543 of file dimension\&.cpp\&.
.PP
.nf
1544     {
1545         vector<dimension> new_x = create_derived_dimensions(x,value);
1546         vector<unsigned int> skip_dimensions = vector<unsigned int>();
1547         for(unsigned int i = 0; i < new_x\&.size(); i++)
1548         {
1549             for(unsigned int j = i + 1; j < new_x\&.size(); j++)
1550             {
1551                 if (skip_dimensions\&.size() > 0)
1552                 {
1553                     bool skip = false;
1554                     for(unsigned int k = 0; k < skip_dimensions\&.size(); k++)
1555                     {
1556                         if (j == skip_dimensions[k])
1557                         {
1558                             skip = true;
1559                         }
1560                     }
1561                     if (skip)
1562                     {
1563                         continue;
1564                     }
1565                 }
1566                 if (new_x[i]\&.dimension_type == new_x[j]\&.dimension_type and new_x[i]\&.dimension_position != new_x[j]\&.dimension_position)
1567                 {
1568                     if (new_x[i]\&.dimension_position == dimension::NUMERATOR)
1569                     {
1570                         value *= float(new_x[i]\&.get_conversion_factor());
1571                         value *= float(new_x[i]\&.prefix_math());
1572                     }
1573                     else if (new_x[i]\&.dimension_position == dimension::DENOMINATOR)
1574                     {
1575                         value /= float(new_x[i]\&.get_conversion_factor());
1576                         value /= float(new_x[i]\&.prefix_math());
1577                     }
1578                     if (new_x[j]\&.dimension_position == dimension::NUMERATOR)
1579                     {
1580                         value *= float(new_x[j]\&.get_conversion_factor());
1581                         value *= float(new_x[j]\&.prefix_math());
1582                     }
1583                     else if (new_x[j]\&.dimension_position == dimension::DENOMINATOR)
1584                     {
1585                         value /= float(new_x[j]\&.get_conversion_factor());
1586                         value /= float(new_x[j]\&.prefix_math());
1587                     }
1588                     skip_dimensions\&.push_back(i);
1589                     skip_dimensions\&.push_back(j);
1590                     break;
1591                 }
1592             }
1593         }
1594         vector<dimension> new_dimensions = vector<dimension>();
1595         for(unsigned int i = 0; i < new_x\&.size(); i++)
1596         {
1597             bool skip = false;
1598             for(unsigned int j = 0; j < skip_dimensions\&.size(); j++)
1599             {
1600                 if (i == skip_dimensions[j])
1601                 {
1602                     skip = true;
1603                     break;
1604                 }
1605             }
1606             if (!skip)
1607             {
1608                 new_dimensions\&.push_back(new_x[i]);
1609             }
1610         }
1611         return new_dimensions;
1612     }
.fi
.SS "int scifir::mole::number_of_particles () const"

.PP
Definition at line 338 of file unit_basic\&.cpp\&.
.PP
.nf
339     {
340         return 1;
341         /*if (scalar_unit::actual_dimensions\&.count(particles))
342         {
343             return scalar_unit::value;
344         }
345         else
346         {
347             return scalar_unit::value * scifir::AVOGADRO_CONSTANT;
348         }*/
349     }
.fi
.SS "template<typename T1 , typename T2 > \fBscifir::time_duration\fP& scifir::operator+= (chrono::duration< T1, T2 > x)"

.PP
Definition at line 44 of file unit_basic\&.hpp\&.
.PP
.nf
45             {
46                  chrono::seconds d = chrono::duration_cast<chrono::seconds>(x);
47                  scifir::time_duration x_second = scifir::time_duration((long double)d\&.count(),"s");
48                  scalar_unit::operator+=(x_second);
49                  return *this;
50             }
.fi
.SS "template<typename T1 , typename T2 > \fBscifir::time_duration\fP& scifir::operator\-= (chrono::duration< T1, T2 > x)"

.PP
Definition at line 53 of file unit_basic\&.hpp\&.
.PP
.nf
54             {
55                  chrono::seconds d = chrono::duration_cast<chrono::seconds>(x);
56                  scifir::time_duration x_second = scifir::time_duration((long double)d\&.count(),"s");
57                  scalar_unit::operator\-=(x_second);
58                  return *this;
59             }
.fi
.SS "bool scifir::orthogonal (const \fBangle\fP & x, const \fBangle\fP & y)"

.PP
Checks if two angles in a 2D correspond to orthogonal lines (or orthogonal vectors)\&. 
.PP
Definition at line 323 of file angle\&.cpp\&.
.PP
.nf
324     {
325         float difference = std::abs((x - y)\&.get_value());
326         if (difference == 90\&.0f or difference == 270\&.0f)
327         {
328             return true;
329         }
330         else
331         {
332             return false;
333         }
334     }
.fi
.SS "bool scifir::orthogonal (const \fBvector_unit_2d\fP & x, const \fBvector_unit_2d\fP & y)"

.PP
Checks if two vectors x and y are orthogonal, that's, if they have 90 degrees of difference\&. 
.PP
Definition at line 360 of file vector_unit_2d\&.cpp\&.
.PP
.nf
361     {
362         return scifir::orthogonal(x\&.theta,y\&.theta);
363     }
.fi
.SS "bool scifir::orthogonal (const \fBvector_unit_3d\fP & x, const \fBvector_unit_3d\fP & y)"

.PP
Checks if two vectors x and y are orthogonal, that's, if they have 90 degrees between them\&. 
.PP
Definition at line 501 of file vector_unit_3d\&.cpp\&.
.PP
.nf
502     {
503         scifir::angle x_angle = angle_between(x,y);
504         return (x_angle == 90\&.0f);
505     }
.fi
.SS "bool scifir::orthogonal (const \fBvector_unit_nd\fP & x, const \fBvector_unit_nd\fP & y)"

.PP
Checks if two vectors x and y are orthogonal, that's, if they have 90 degrees between them\&. Both vectors must have the same ND, otherwise it returns an empty \fBvector_unit_nd\fP instead\&. 
.PP
Definition at line 859 of file vector_unit_nd\&.cpp\&.
.PP
.nf
860     {
861         if (same_nd(x,y))
862         {
863             if (x\&.get_nd() == 1)
864             {
865                 return false;
866             }
867             else if (x\&.get_nd() == 2)
868             {
869                 return scifir::orthogonal(x\&.angles[0],y\&.angles[0]);
870             }
871             else if (x\&.get_nd() == 3)
872             {
873                 scifir::angle x_angle = angle_between(x,y);
874                 return (x_angle == 90\&.0f);
875             }
876         }
877         return false;
878     }
.fi
.SS "bool scifir::parallel (const \fBangle\fP & x, const \fBangle\fP & y)"

.PP
Checks if two angles in a 2D correspond to parallel lines (or parallel vectors)\&. 
.PP
Definition at line 311 of file angle\&.cpp\&.
.PP
.nf
312     {
313         if(x == y or (x + 180\&.0f) == y)
314         {
315             return true;
316         }
317         else
318         {
319             return false;
320         }
321     }
.fi
.SS "bool scifir::parallel (const \fBvector_unit_2d\fP & x, const \fBvector_unit_2d\fP & y)"

.PP
Checks if two vectors x and y are parallel, which means that their direction is the same or the exact opposite\&. 
.PP
Definition at line 355 of file vector_unit_2d\&.cpp\&.
.PP
.nf
356     {
357         return scifir::parallel(x\&.theta,y\&.theta);
358     }
.fi
.SS "bool scifir::parallel (const \fBvector_unit_3d\fP & x, const \fBvector_unit_3d\fP & y)"

.PP
Checks if two vectors x and y are parallel, which means that their direction is the same or the exact opposite\&. 
.PP
Definition at line 489 of file vector_unit_3d\&.cpp\&.
.PP
.nf
490     {
491         if ((x\&.theta == y\&.theta and x\&.phi == y\&.phi) or (x\&.theta == (180\&.0f + y\&.theta) and x\&.phi == (180\&.0f - y\&.phi)))
492         {
493             return true;
494         }
495         else
496         {
497             return false;
498         }
499     }
.fi
.SS "bool scifir::parallel (const \fBvector_unit_nd\fP & x, const \fBvector_unit_nd\fP & y)"

.PP
Checks if two vectors x and y are parallel, which means that their direction is the same or the exact opposite\&. Both vectors must have the same ND, otherwise it returns an empty \fBvector_unit_nd\fP instead\&. 
.PP
Definition at line 832 of file vector_unit_nd\&.cpp\&.
.PP
.nf
833     {
834         if (same_nd(x,y))
835         {
836             if (x\&.get_nd() == 1)
837             {
838                 return true;
839             }
840             else if (x\&.get_nd() == 2)
841             {
842                 return scifir::parallel(x\&.angles[0],y\&.angles[0]);
843             }
844             else if (x\&.get_nd() == 3)
845             {
846                 if ((x\&.angles[0] == y\&.angles[0] and x\&.angles[1] == y\&.angles[1]) or (x\&.angles[0] == (180\&.0f + y\&.angles[0]) and x\&.angles[1] == (180\&.0f - y\&.angles[1])))
847                 {
848                     return true;
849                 }
850                 else
851                 {
852                     return false;
853                 }
854             }
855         }
856         return false;
857     }
.fi
.SS "float scifir::parse_float (const string & x)"

.PP
Definition at line 10 of file types\&.cpp\&.
.PP
.nf
11     {
12         try
13         {
14             float value = stof(x);
15             return value;
16         }
17         catch (const exception& e)
18         {
19             return 0;
20         }
21     }
.fi
.SS "int scifir::parse_int (const string & x)"

.PP
Definition at line 23 of file types\&.cpp\&.
.PP
.nf
24     {
25         try
26         {
27             int value = stoi(x);
28             return value;
29         }
30         catch (const exception& e)
31         {
32             return 0;
33         }
34     }
.fi
.SS "\fBscalar_unit\fP scifir::polar_to_cartesian_2d_x (const \fBscalar_unit\fP & p, const \fBangle\fP & theta)\fC [inline]\fP"

.PP
Definition at line 386 of file coordinates_2d\&.hpp\&.
.PP
.nf
387     {
388         return p * scifir::cos(theta);
389     }
.fi
.SS "float scifir::polar_to_cartesian_2d_x (float p, const \fBangle\fP & theta)\fC [inline]\fP"

.PP
Definition at line 406 of file coordinates_2d\&.hpp\&.
.PP
.nf
407     {
408         return p * scifir::cos(theta);
409     }
.fi
.SS "\fBscalar_unit\fP scifir::polar_to_cartesian_2d_y (const \fBscalar_unit\fP & p, const \fBangle\fP & theta)\fC [inline]\fP"

.PP
Definition at line 391 of file coordinates_2d\&.hpp\&.
.PP
.nf
392     {
393         return p * scifir::sin(theta);
394     }
.fi
.SS "float scifir::polar_to_cartesian_2d_y (float p, const \fBangle\fP & theta)\fC [inline]\fP"

.PP
Definition at line 411 of file coordinates_2d\&.hpp\&.
.PP
.nf
412     {
413         return p * scifir::sin(theta);
414     }
.fi
.SS "\fBscalar_unit\fP scifir::pow (const \fBscalar_unit\fP & x, int exponent)"

.PP
Exponentiates a \fBscalar_unit\fP to some numeric type, the dimensions are also exponentiated\&. 
.PP
Definition at line 725 of file scalar_unit\&.cpp\&.
.PP
.nf
726     {
727         return x ^ exponent;
728     }
.fi
.SS "vector< \fBdimension\fP > scifir::power_dimensions (const vector< \fBdimension\fP > & x, int exponent)"

.PP
Powers the dimensions by an exponent\&. 
.PP
Definition at line 1480 of file dimension\&.cpp\&.
.PP
.nf
1481     {
1482         vector<dimension> new_dimensions = vector<dimension>();
1483         for (const dimension& x_dimension: x)
1484         {
1485             for (int j = 1; j <= exponent; j++)
1486             {
1487                 new_dimensions\&.push_back(x_dimension);
1488             }
1489         }
1490         return new_dimensions;
1491     }
.fi
.SS "\fBprefix::type\fP scifir::prefix_string (const string & x)"

.PP
Returns the value of the enum \fBprefix::type\fP associated with the string x given\&. 
.PP
Definition at line 215 of file prefix\&.cpp\&.
.PP
.nf
216     {
217         if (x == "Q")
218         {
219             return prefix::QUETTA;
220         }
221         else if (x == "R")
222         {
223             return prefix::RONNA;
224         }
225         else if (x == "Y")
226         {
227             return prefix::YOTTA;
228         }
229         else if (x == "Z")
230         {
231             return prefix::ZETTA;
232         }
233         else if (x == "E")
234         {
235             return prefix::EXA;
236         }
237         else if (x == "P")
238         {
239             return prefix::PETA;
240         }
241         else if (x == "T")
242         {
243             return prefix::TERA;
244         }
245         else if(x == "G")
246         {
247             return prefix::GIGA;
248         }
249         else if(x == "M")
250         {
251             return prefix::MEGA;
252         }
253         else if(x == "k")
254         {
255             return prefix::KILO;
256         }
257         else if(x == "h")
258         {
259             return prefix::HECTO;
260         }
261         else if(x == "da")
262         {
263             return prefix::DECA;
264         }
265         else if(x == "d")
266         {
267             return prefix::DECI;
268         }
269         else if(x == "c")
270         {
271             return prefix::CENTI;
272         }
273         else if(x == "m")
274         {
275             return prefix::MILLI;
276         }
277         else if(x == "u" or x == "\u00B5")
278         {
279             return prefix::MICRO;
280         }
281         else if(x == "n")
282         {
283             return prefix::NANO;
284         }
285         else if(x == "p")
286         {
287             return prefix::PICO;
288         }
289         else if(x == "f")
290         {
291             return prefix::FEMTO;
292         }
293         else if(x == "a")
294         {
295             return prefix::ATTO;
296         }
297         else if(x == "z")
298         {
299             return prefix::ZEPTO;
300         }
301         else if(x == "y")
302         {
303             return prefix::YOCTO;
304         }
305         else if(x == "r")
306         {
307             return prefix::RONTO;
308         }
309         else if(x == "q")
310         {
311             return prefix::QUECTO;
312         }
313         else if (x == "")
314         {
315             return prefix::NONE;
316         }
317         else
318         {
319             return prefix::NONE;
320         }
321     }
.fi
.SS "float scifir::radian_to_degree (float x)\fC [inline]\fP"

.PP
Converts a radian to degree\&. 
.PP
Definition at line 17 of file angle\&.hpp\&.
.PP
.nf
18     {
19         return x * 180\&.0f / PI;
20     }
.fi
.SS "bool scifir::same_direction (const \fBvector_unit_2d\fP & x, const \fBvector_unit_2d\fP & y)"

.PP
Checks if two vectors x and y have the same direction\&. 
.PP
Definition at line 350 of file vector_unit_2d\&.cpp\&.
.PP
.nf
351     {
352         return x\&.theta == y\&.theta;
353     }
.fi
.SS "bool scifir::same_direction (const \fBvector_unit_3d\fP & x, const \fBvector_unit_3d\fP & y)"

.PP
Checks if two vectors x and y have the same direction\&. 
.PP
Definition at line 477 of file vector_unit_3d\&.cpp\&.
.PP
.nf
478     {
479         if (x\&.theta == y\&.theta and x\&.phi == y\&.phi)
480         {
481             return true;
482         }
483         else
484         {
485             return false;
486         }
487     }
.fi
.SS "bool scifir::same_direction (const \fBvector_unit_nd\fP & x, const \fBvector_unit_nd\fP & y)"

.PP
Checks if two vectors x and y have the same direction\&. Both vectors must have the same ND, otherwise it returns an empty \fBvector_unit_nd\fP instead\&. 
.PP
Definition at line 816 of file vector_unit_nd\&.cpp\&.
.PP
.nf
817     {
818         if (same_nd(x,y))
819         {
820             for(unsigned int i = 0; i < x\&.angles\&.size(); i++)
821             {
822                 if(x\&.angles[i] != y\&.angles[i])
823                 {
824                     return false;
825                 }
826             }
827             return true;
828         }
829         return false;
830     }
.fi
.SS "bool scifir::same_nd (const \fBvector_unit_nd\fP & x, const \fBvector_unit_nd\fP & y)"

.PP
Checks if two vectors have the same number of dimensions\&. 
.PP
Definition at line 804 of file vector_unit_nd\&.cpp\&.
.PP
.nf
805     {
806         if(x\&.angles\&.size() == y\&.angles\&.size())
807         {
808             return true;
809         }
810         else
811         {
812             return false;
813         }
814     }
.fi
.SS "scifir::SCALAR_UNIT_CPP (absorbed_dose, 'm2/s3')"

.SS "scifir::SCALAR_UNIT_CPP (action, 'kg*m2/s')"

.SS "scifir::SCALAR_UNIT_CPP (\fBarea\fP, 'm2')"

.SS "scifir::SCALAR_UNIT_CPP (area_density, 'g/m2')"

.SS "scifir::SCALAR_UNIT_CPP (capacitance, 'A2*s4/m2*kg')"

.SS "scifir::SCALAR_UNIT_CPP (catalytic_activity, 'kat')"

.SS "scifir::SCALAR_UNIT_CPP (catalytic_efficiency, 'm3/s*mol')"

.SS "scifir::SCALAR_UNIT_CPP (charge, 'C')"

.SS "scifir::SCALAR_UNIT_CPP (compressibility, 'm*s2/kg')"

.SS "scifir::SCALAR_UNIT_CPP (curvature, '1/m')"

.SS "scifir::SCALAR_UNIT_CPP (data, 'B')"

.SS "scifir::SCALAR_UNIT_CPP (density, 'g/m3')"

.SS "scifir::SCALAR_UNIT_CPP (diffusion_coefficient, 'm2/s')"

.SS "scifir::SCALAR_UNIT_CPP (dynamic_viscosity, 'g/m*s')"

.SS "scifir::SCALAR_UNIT_CPP (electric_charge_density, 'A*s/m3')"

.SS "scifir::SCALAR_UNIT_CPP (electric_conductance, 'A2*s3/kg*m2')"

.SS "scifir::SCALAR_UNIT_CPP (electric_current, 'A')"

.SS "scifir::SCALAR_UNIT_CPP (electric_current_density, 'A/m2')"

.SS "scifir::SCALAR_UNIT_CPP (electrical_conductivity, 'A2*s3/kg*m3')"

.SS "scifir::SCALAR_UNIT_CPP (electron_mobility, 'A*s2/kg')"

.SS "scifir::SCALAR_UNIT_CPP (energy, 'kg*m2/s2')"

.SS "scifir::SCALAR_UNIT_CPP (energy_density, 'g/m*s2')"

.SS "scifir::SCALAR_UNIT_CPP (energy_flux_density, 'kg/s3')"

.SS "scifir::SCALAR_UNIT_CPP (enthalpy, 'kg*m2/s2')"

.SS "scifir::SCALAR_UNIT_CPP (entropy, 'kg*m2/K*s2')"

.SS "scifir::SCALAR_UNIT_CPP (frequency, '1/s')"

.SS "scifir::SCALAR_UNIT_CPP (frequency_drift, '1/s2')"

.SS "scifir::SCALAR_UNIT_CPP (heat_capacity, 'kg*m2/K*s2')"

.SS "scifir::SCALAR_UNIT_CPP (heat_flux_density, 'kg/s3')"

.SS "scifir::SCALAR_UNIT_CPP (illuminance, 'lx')"

.SS "scifir::SCALAR_UNIT_CPP (inductance, 'H')"

.SS "scifir::SCALAR_UNIT_CPP (ionizing_radiation, 'A*s/kg')"

.SS "scifir::SCALAR_UNIT_CPP (length, 'm')"

.SS "scifir::SCALAR_UNIT_CPP (light, 'cd')"

.SS "scifir::SCALAR_UNIT_CPP (linear_charge_density, 'A*s/m')"

.SS "scifir::SCALAR_UNIT_CPP (linear_mass_density, 'g/m')"

.SS "scifir::SCALAR_UNIT_CPP (luminance, 'cd/m2')"

.SS "scifir::SCALAR_UNIT_CPP (luminous_efficacy, 'lm/W')"

.SS "scifir::SCALAR_UNIT_CPP (luminous_energy, 'cd*sr*s')"

.SS "scifir::SCALAR_UNIT_CPP (luminous_exposure, 'cd*sr*s/m2')"

.SS "scifir::SCALAR_UNIT_CPP (luminous_flux, 'lm')"

.SS "scifir::SCALAR_UNIT_CPP (magnetic_flux, 'Wb')"

.SS "scifir::SCALAR_UNIT_CPP (magnetic_permeability, 'A2*s2/kg*m')"

.SS "scifir::SCALAR_UNIT_CPP (magnetic_reluctance, 'A2*s2/kg*m2')"

.SS "scifir::SCALAR_UNIT_CPP (magnetic_rigidity, 'kg*m/A*s2')"

.SS "scifir::SCALAR_UNIT_CPP (magnetic_susceptibility, 'A2*s2/kg*m')"

.SS "scifir::SCALAR_UNIT_CPP (magnetization, 'A/m')"

.SS "scifir::SCALAR_UNIT_CPP (\fBmass\fP, 'g')"

.SS "scifir::SCALAR_UNIT_CPP (mass_flow_rate, 'g/s')"

.SS "scifir::SCALAR_UNIT_CPP (molality, 'mol/g')"

.SS "scifir::SCALAR_UNIT_CPP (molar_conductivity, 's3*A2/g*mol')"

.SS "scifir::SCALAR_UNIT_CPP (molar_energy, 'm2*g/s2*mol')"

.SS "scifir::SCALAR_UNIT_CPP (molar_enthalpy, 'm2*g/s2*mol')"

.SS "scifir::SCALAR_UNIT_CPP (molar_entropy, 'm2*g/s2*K*mol')"

.SS "scifir::SCALAR_UNIT_CPP (molar_heat_capacity, 'm2*g/s2*K*mol')"

.SS "scifir::SCALAR_UNIT_CPP (molar_mass, 'g/mol')"

.SS "scifir::SCALAR_UNIT_CPP (molar_volume, 'm3/mol')"

.SS "scifir::SCALAR_UNIT_CPP (molarity, 'mol/m3')"

.SS "scifir::SCALAR_UNIT_CPP (\fBmole\fP, 'mol')"

.SS "scifir::SCALAR_UNIT_CPP (moment_of_inertia, 'm2*kg')"

.SS "scifir::SCALAR_UNIT_CPP (optical_power, '1/m')"

.SS "scifir::SCALAR_UNIT_CPP (permittivity, 'A2*s4/kg*m3')"

.SS "scifir::SCALAR_UNIT_CPP (polarization_density, 'A*s/m2')"

.SS "scifir::SCALAR_UNIT_CPP (power, 'kg*m2/s3')"

.SS "scifir::SCALAR_UNIT_CPP (power_density, 'kg/m*s3')"

.SS "scifir::SCALAR_UNIT_CPP (radiance, 'kg/s3')"

.SS "scifir::SCALAR_UNIT_CPP (radiant_intensity, 'kg*m2/s3')"

.SS "scifir::SCALAR_UNIT_CPP (radioactivity, 'Bq')"

.SS "scifir::SCALAR_UNIT_CPP (resistance, 'kg*m2/A2*s3')"

.SS "scifir::SCALAR_UNIT_CPP (resistivity, 'kg*m3/A2*s3')"

.SS "scifir::SCALAR_UNIT_CPP (specific_energy, 'm2/s2')"

.SS "scifir::SCALAR_UNIT_CPP (specific_entropy, 'm2/s2*K')"

.SS "scifir::SCALAR_UNIT_CPP (specific_heat_capacity, 'm2/s2*K')"

.SS "scifir::SCALAR_UNIT_CPP (specific_volume, 'm3/g')"

.SS "scifir::SCALAR_UNIT_CPP (spectral_intensity, 'kg*m/s3')"

.SS "scifir::SCALAR_UNIT_CPP (spectral_radiance, 'kg/m*s3')"

.SS "scifir::SCALAR_UNIT_CPP (stiffness, 'kg/s2')"

.SS "scifir::SCALAR_UNIT_CPP (temperature, 'K')"

.SS "scifir::SCALAR_UNIT_CPP (thermal_conductivity, 'kg*m/K*s3')"

.SS "scifir::SCALAR_UNIT_CPP (thermal_diffusivity, 'm2/s')"

.SS "scifir::SCALAR_UNIT_CPP (thermal_expansion_coefficient, '1/K')"

.SS "scifir::SCALAR_UNIT_CPP (thermal_resistance, 'K*s3/kg*m2')"

.SS "scifir::SCALAR_UNIT_CPP (\fBtime_duration\fP, 's')"

.SS "scifir::SCALAR_UNIT_CPP (transfer_speed, 'B/s')"

.SS "scifir::SCALAR_UNIT_CPP (viscosity, 'm2/s')"

.SS "scifir::SCALAR_UNIT_CPP (voltage, 'V')"

.SS "scifir::SCALAR_UNIT_CPP (\fBvolume\fP, 'm3')"

.SS "scifir::SCALAR_UNIT_CPP (volume_4d, 'm4')"

.SS "scifir::SCALAR_UNIT_CPP (volumetric_flow, 'm3/s')"

.SS "scifir::SCALAR_UNIT_CPP (wavenumber, '1/m')"

.SS "scifir::SCALAR_UNIT_HPP (absorbed_dose)"

.SS "scifir::SCALAR_UNIT_HPP (action)"

.SS "scifir::SCALAR_UNIT_HPP (area_density)"

.SS "scifir::SCALAR_UNIT_HPP (capacitance)"

.SS "scifir::SCALAR_UNIT_HPP (catalytic_activity)"

.SS "scifir::SCALAR_UNIT_HPP (catalytic_efficiency)"

.SS "scifir::SCALAR_UNIT_HPP (charge)"

.SS "scifir::SCALAR_UNIT_HPP (compressibility)"

.SS "scifir::SCALAR_UNIT_HPP (curvature)"

.SS "scifir::SCALAR_UNIT_HPP (data)"

.SS "scifir::SCALAR_UNIT_HPP (density)"

.SS "scifir::SCALAR_UNIT_HPP (diffusion_coefficient)"

.SS "scifir::SCALAR_UNIT_HPP (dynamic_viscosity)"

.SS "scifir::SCALAR_UNIT_HPP (electric_charge_density)"

.SS "scifir::SCALAR_UNIT_HPP (electric_conductance)"

.SS "scifir::SCALAR_UNIT_HPP (electric_current)"

.SS "scifir::SCALAR_UNIT_HPP (electric_current_density)"

.SS "scifir::SCALAR_UNIT_HPP (electrical_conductivity)"

.SS "scifir::SCALAR_UNIT_HPP (electron_mobility)"

.SS "scifir::SCALAR_UNIT_HPP (energy)"

.SS "scifir::SCALAR_UNIT_HPP (energy_density)"

.SS "scifir::SCALAR_UNIT_HPP (energy_flux_density)"

.SS "scifir::SCALAR_UNIT_HPP (enthalpy)"

.SS "scifir::SCALAR_UNIT_HPP (entropy)"

.SS "scifir::SCALAR_UNIT_HPP (frequency)"

.SS "scifir::SCALAR_UNIT_HPP (frequency_drift)"

.SS "scifir::SCALAR_UNIT_HPP (heat_capacity)"

.SS "scifir::SCALAR_UNIT_HPP (heat_flux_density)"

.SS "scifir::SCALAR_UNIT_HPP (illuminance)"

.SS "scifir::SCALAR_UNIT_HPP (inductance)"

.SS "scifir::SCALAR_UNIT_HPP (ionizing_radiation)"

.SS "scifir::SCALAR_UNIT_HPP (length)"

.SS "scifir::SCALAR_UNIT_HPP (light)"

.SS "scifir::SCALAR_UNIT_HPP (linear_charge_density)"

.SS "scifir::SCALAR_UNIT_HPP (linear_mass_density)"

.SS "scifir::SCALAR_UNIT_HPP (luminance)"

.SS "scifir::SCALAR_UNIT_HPP (luminous_efficacy)"

.SS "scifir::SCALAR_UNIT_HPP (luminous_energy)"

.SS "scifir::SCALAR_UNIT_HPP (luminous_exposure)"

.SS "scifir::SCALAR_UNIT_HPP (luminous_flux)"

.SS "scifir::SCALAR_UNIT_HPP (magnetic_flux)"

.SS "scifir::SCALAR_UNIT_HPP (magnetic_permeability)"

.SS "scifir::SCALAR_UNIT_HPP (magnetic_reluctance)"

.SS "scifir::SCALAR_UNIT_HPP (magnetic_rigidity)"

.SS "scifir::SCALAR_UNIT_HPP (magnetic_susceptibility)"

.SS "scifir::SCALAR_UNIT_HPP (magnetization)"

.SS "scifir::SCALAR_UNIT_HPP (mass_flow_rate)"

.SS "scifir::SCALAR_UNIT_HPP (molality)"

.SS "scifir::SCALAR_UNIT_HPP (molar_conductivity)"

.SS "scifir::SCALAR_UNIT_HPP (molar_energy)"

.SS "scifir::SCALAR_UNIT_HPP (molar_enthalpy)"

.SS "scifir::SCALAR_UNIT_HPP (molar_entropy)"

.SS "scifir::SCALAR_UNIT_HPP (molar_heat_capacity)"

.SS "scifir::SCALAR_UNIT_HPP (molar_mass)"

.SS "scifir::SCALAR_UNIT_HPP (molar_volume)"

.SS "scifir::SCALAR_UNIT_HPP (molarity)"

.SS "scifir::SCALAR_UNIT_HPP (moment_of_inertia)"

.SS "scifir::SCALAR_UNIT_HPP (optical_power)"

.SS "scifir::SCALAR_UNIT_HPP (permittivity)"

.SS "scifir::SCALAR_UNIT_HPP (polarization_density)"

.SS "scifir::SCALAR_UNIT_HPP (power)"

.SS "scifir::SCALAR_UNIT_HPP (power_density)"

.SS "scifir::SCALAR_UNIT_HPP (radiance)"

.SS "scifir::SCALAR_UNIT_HPP (radiant_intensity)"

.SS "scifir::SCALAR_UNIT_HPP (radioactivity)"

.SS "scifir::SCALAR_UNIT_HPP (resistance)"

.SS "scifir::SCALAR_UNIT_HPP (resistivity)"

.SS "scifir::SCALAR_UNIT_HPP (specific_energy)"

.SS "scifir::SCALAR_UNIT_HPP (specific_entropy)"

.SS "scifir::SCALAR_UNIT_HPP (specific_heat_capacity)"

.SS "scifir::SCALAR_UNIT_HPP (specific_volume)"

.SS "scifir::SCALAR_UNIT_HPP (spectral_intensity)"

.SS "scifir::SCALAR_UNIT_HPP (spectral_radiance)"

.SS "scifir::SCALAR_UNIT_HPP (stiffness)"

.SS "scifir::SCALAR_UNIT_HPP (temperature)"

.SS "scifir::SCALAR_UNIT_HPP (thermal_conductivity)"

.SS "scifir::SCALAR_UNIT_HPP (thermal_diffusivity)"

.SS "scifir::SCALAR_UNIT_HPP (thermal_expansion_coefficient)"

.SS "scifir::SCALAR_UNIT_HPP (thermal_resistance)"

.SS "scifir::SCALAR_UNIT_HPP (transfer_speed)"

.SS "scifir::SCALAR_UNIT_HPP (viscosity)"

.SS "scifir::SCALAR_UNIT_HPP (voltage)"

.SS "scifir::SCALAR_UNIT_HPP (volume_4d)"

.SS "scifir::SCALAR_UNIT_HPP (volumetric_flow)"

.SS "scifir::SCALAR_UNIT_HPP (wavenumber)"

.SS "scifir::SCALAR_UNIT_HPP_BEGIN (\fBarea\fP)"

.SS "scifir::SCALAR_UNIT_HPP_BEGIN (\fBmass\fP)"

.SS "scifir::SCALAR_UNIT_HPP_BEGIN (\fBmole\fP)"

.SS "scifir::SCALAR_UNIT_HPP_BEGIN (\fBtime_duration\fP)"

.SS "scifir::SCALAR_UNIT_HPP_BEGIN (\fBvolume\fP)"

.SS "scifir::SCALAR_UNIT_HPP_END ()"

.SS "float scifir::sin (const \fBangle\fP & x)"

.PP
Calculates the sin of angle x\&. It uses the \fBsin()\fP function of the standard library of C++, the difference is that angle is in degrees, not in radians\&. 
.PP
Definition at line 346 of file angle\&.cpp\&.
.PP
.nf
347     {
348         return std::sin(x\&.get_radian());
349     }
.fi
.SS "float scifir::sinh (const \fBangle\fP & x)"

.PP
Calculates the sinh of angle x\&. It uses the \fBsinh()\fP function of the standard library of C++, the difference is that angle is in degrees, not in radians\&. 
.PP
Definition at line 376 of file angle\&.cpp\&.
.PP
.nf
377     {
378         return std::sinh(x\&.get_radian());
379     }
.fi
.SS "\fBscalar_unit\fP scifir::spherical_to_cartesian_3d_x (const \fBscalar_unit\fP & r, const \fBangle\fP & theta, const \fBangle\fP & phi)\fC [inline]\fP"

.PP
Definition at line 653 of file coordinates_3d\&.hpp\&.
.PP
.nf
654     {
655         return r * scifir::cos(theta) * scifir::sin(phi);
656     }
.fi
.SS "float scifir::spherical_to_cartesian_3d_x (float r, const \fBangle\fP & theta, const \fBangle\fP & phi)\fC [inline]\fP"

.PP
Definition at line 745 of file coordinates_3d\&.hpp\&.
.PP
.nf
746     {
747         return r * scifir::cos(theta) * scifir::sin(phi);
748     }
.fi
.SS "\fBscalar_unit\fP scifir::spherical_to_cartesian_3d_y (const \fBscalar_unit\fP & r, const \fBangle\fP & theta, const \fBangle\fP & phi)\fC [inline]\fP"

.PP
Definition at line 658 of file coordinates_3d\&.hpp\&.
.PP
.nf
659     {
660         return r * scifir::sin(theta) * scifir::sin(phi);
661     }
.fi
.SS "float scifir::spherical_to_cartesian_3d_y (float r, const \fBangle\fP & theta, const \fBangle\fP & phi)\fC [inline]\fP"

.PP
Definition at line 750 of file coordinates_3d\&.hpp\&.
.PP
.nf
751     {
752         return r * scifir::sin(theta) * scifir::sin(phi);
753     }
.fi
.SS "\fBscalar_unit\fP scifir::spherical_to_cartesian_3d_z (const \fBscalar_unit\fP & r, const \fBangle\fP & theta, const \fBangle\fP & phi)\fC [inline]\fP"

.PP
Definition at line 663 of file coordinates_3d\&.hpp\&.
.PP
.nf
664     {
665         return r * scifir::cos(phi);
666     }
.fi
.SS "float scifir::spherical_to_cartesian_3d_z (float r, const \fBangle\fP & theta, const \fBangle\fP & phi)\fC [inline]\fP"

.PP
Definition at line 755 of file coordinates_3d\&.hpp\&.
.PP
.nf
756     {
757         return r * scifir::cos(phi);
758     }
.fi
.SS "\fBscalar_unit\fP scifir::spherical_to_cylindrical_p (const \fBscalar_unit\fP & r, const \fBangle\fP & theta, const \fBangle\fP & phi)\fC [inline]\fP"

.PP
Definition at line 668 of file coordinates_3d\&.hpp\&.
.PP
.nf
669     {
670         return r * scifir::sin(phi);
671     }
.fi
.SS "float scifir::spherical_to_cylindrical_p (float r, const \fBangle\fP & theta, const \fBangle\fP & phi)\fC [inline]\fP"

.PP
Definition at line 760 of file coordinates_3d\&.hpp\&.
.PP
.nf
761     {
762         return r * scifir::sin(phi);
763     }
.fi
.SS "\fBangle\fP scifir::spherical_to_cylindrical_theta (const \fBscalar_unit\fP & r, const \fBangle\fP & theta, const \fBangle\fP & phi)\fC [inline]\fP"

.PP
Definition at line 673 of file coordinates_3d\&.hpp\&.
.PP
.nf
674     {
675         return theta;
676     }
.fi
.SS "\fBangle\fP scifir::spherical_to_cylindrical_theta (float r, const \fBangle\fP & theta, const \fBangle\fP & phi)\fC [inline]\fP"

.PP
Definition at line 765 of file coordinates_3d\&.hpp\&.
.PP
.nf
766     {
767         return theta;
768     }
.fi
.SS "\fBscalar_unit\fP scifir::spherical_to_cylindrical_z (const \fBscalar_unit\fP & r, const \fBangle\fP & theta, const \fBangle\fP & phi)\fC [inline]\fP"

.PP
Definition at line 678 of file coordinates_3d\&.hpp\&.
.PP
.nf
679     {
680         return r * scifir::cos(phi);
681     }
.fi
.SS "float scifir::spherical_to_cylindrical_z (float r, const \fBangle\fP & theta, const \fBangle\fP & phi)\fC [inline]\fP"

.PP
Definition at line 770 of file coordinates_3d\&.hpp\&.
.PP
.nf
771     {
772         return r * scifir::cos(phi);
773     }
.fi
.SS "\fBangle\fP scifir::sqrt (const \fBangle\fP & x)"

.PP
Calculates the square root of the angle x and returns that new angle\&. 
.PP
Definition at line 336 of file angle\&.cpp\&.
.PP
.nf
337     {
338         return angle(std::sqrt(x\&.get_value()));
339     }
.fi
.SS "template<typename T > \fBcomplex_number\fP<\fBscalar_unit\fP> scifir::sqrt (const \fBcomplex_number\fP< T > & x)"

.PP
Definition at line 188 of file complex_number\&.hpp\&.
.PP
.nf
189     {
190         int sgn_value;
191         if (x\&.imaginary > 0)
192         {
193             sgn_value = 1;
194         }
195         else if (x\&.imaginary < 0)
196         {
197             sgn_value = -1;
198         }
199         else
200         {
201             sgn_value = 0;
202         }
203         scalar_unit new_real = scifir::sqrt(x\&.real + scifir::sqrt((x\&.real^2) + (x\&.imaginary^2)));
204         scalar_unit new_imaginary = sgn_value * scifir::sqrt(((-1) * x\&.real + scifir::sqrt((x\&.real^2) + (x\&.imaginary^2))) / 2);
205         return complex_number<scalar_unit>(new_real,new_imaginary);
206     }
.fi
.SS "\fBpixel\fP scifir::sqrt (const \fBpixel\fP & x)"

.PP
Definition at line 228 of file pixel\&.cpp\&.
.PP
.nf
229     {
230         return pixel(std::sqrt(x\&.get_value()));
231     }
.fi
.SS "\fBscalar_unit\fP scifir::sqrt (const \fBscalar_unit\fP & x)"

.PP
Square root of a \fBscalar_unit\fP, it squares the dimensions too\&. 
.PP
Definition at line 730 of file scalar_unit\&.cpp\&.
.PP
.nf
731     {
732         long double new_value = x\&.get_value();
733         vector<dimension> new_dimensions = square_dimensions(x\&.get_dimensions(), new_value, 2);
734         new_value = std::sqrt(new_value);
735         return scalar_unit(new_value, new_dimensions);
736     }
.fi
.SS "\fBvector_unit_2d\fP scifir::sqrt (const \fBvector_unit_2d\fP & x)"

.PP
It squares the vector, creating a \fBvector_unit_2d\fP with the value squared and always the same theta\&. The dimensions are squared with the same rules for the square of dimensions than \fBscalar_unit\fP classes\&. 
.PP
Definition at line 326 of file vector_unit_2d\&.cpp\&.
.PP
.nf
327     {
328         scalar_unit new_value = scifir::sqrt(scalar_unit(x));
329         return vector_unit_2d(new_value, x\&.theta);
330     }
.fi
.SS "\fBvector_unit_3d\fP scifir::sqrt (const \fBvector_unit_3d\fP & x)"

.PP
It squares the vector, creating a \fBvector_unit_3d\fP with the value squared and always the same theta and the same phi\&. The dimensions are squared with the same rules for the square of dimensions than \fBscalar_unit\fP classes\&. 
.PP
Definition at line 431 of file vector_unit_3d\&.cpp\&.
.PP
.nf
432     {
433         scalar_unit new_value = scifir::sqrt(scalar_unit(x));
434         return vector_unit_3d(new_value, x\&.theta, x\&.phi);
435     }
.fi
.SS "\fBvector_unit_nd\fP scifir::sqrt (const \fBvector_unit_nd\fP & x)"

.PP
It squares the vector, creating a \fBvector_unit_nd\fP with the value squared and always the same angles\&. The dimensions are squared with the same rules for the square of dimensions than \fBscalar_unit\fP classes\&. 
.PP
Definition at line 747 of file vector_unit_nd\&.cpp\&.
.PP
.nf
748     {
749         scalar_unit new_value = scifir::sqrt(scalar_unit(x));
750         return vector_unit_nd(new_value, x\&.angles);
751     }
.fi
.SS "\fBangle\fP scifir::sqrt_nth (const \fBangle\fP & x, int index)"

.PP
Calculates the nth root of the angle x and returns that new angle\&. 
.PP
Definition at line 341 of file angle\&.cpp\&.
.PP
.nf
342     {
343         return angle(std::pow(x\&.get_value(), float(1\&.0f / index)));
344     }
.fi
.SS "\fBpixel\fP scifir::sqrt_nth (const \fBpixel\fP & x, int index)"

.PP
Definition at line 233 of file pixel\&.cpp\&.
.PP
.nf
234     {
235         return pixel(std::pow(x\&.get_value(), 1\&.0f / index));
236     }
.fi
.SS "\fBscalar_unit\fP scifir::sqrt_nth (const \fBscalar_unit\fP & x, int index)"

.PP
Nth root of a \fBscalar_unit\fP to any numeric value, it squares the dimensions too\&. 
.PP
Definition at line 738 of file scalar_unit\&.cpp\&.
.PP
.nf
739     {
740         long double new_value = x\&.get_value();
741         vector<dimension> new_dimensions = square_dimensions(x\&.get_dimensions(), new_value, index);
742         new_value = std::pow(new_value, 1\&.0f / index);
743         return scalar_unit(new_value, new_dimensions);
744     }
.fi
.SS "\fBvector_unit_2d\fP scifir::sqrt_nth (const \fBvector_unit_2d\fP & x, int index)"

.PP
It takes the root of the vector with the index given, creating a \fBvector_unit_2d\fP with the value rooted to that index and always maintains the same theta\&. The dimensions are squared with the same rules for the square of dimensions than \fBscalar_unit\fP classes\&. 
.PP
Definition at line 332 of file vector_unit_2d\&.cpp\&.
.PP
.nf
333     {
334         scalar_unit new_value = scifir::sqrt_nth(scalar_unit(x), index);
335         return vector_unit_2d(new_value, x\&.theta);
336     }
.fi
.SS "\fBvector_unit_3d\fP scifir::sqrt_nth (const \fBvector_unit_3d\fP & x, int index)"

.PP
It takes the root of the vector with the index given, creating a \fBvector_unit_3d\fP with the value rooted to that index and always maintains the same theta and the same phi\&. The dimensions are squared with the same rules for the square of dimensions than \fBscalar_unit\fP classes\&. 
.PP
Definition at line 437 of file vector_unit_3d\&.cpp\&.
.PP
.nf
438     {
439         scalar_unit new_value = scifir::sqrt_nth(scalar_unit(x), index);
440         return vector_unit_3d(new_value, x\&.theta, x\&.phi);
441     }
.fi
.SS "\fBvector_unit_nd\fP scifir::sqrt_nth (const \fBvector_unit_nd\fP & x, int index)"

.PP
It takes the root of the vector with the index given, creating a \fBvector_unit_nd\fP with the value rooted to that index and always maintains the same angles\&. The dimensions are squared with the same rules for the square of dimensions than \fBscalar_unit\fP classes\&. 
.PP
Definition at line 753 of file vector_unit_nd\&.cpp\&.
.PP
.nf
754     {
755         scalar_unit new_value = scifir::sqrt_nth(scalar_unit(x), index);
756         return vector_unit_nd(new_value, x\&.angles);
757     }
.fi
.SS "vector< \fBdimension\fP > scifir::square_dimensions (vector< \fBdimension\fP > x, long double & value, int index)"

.PP
Squares a vector of dimensions by an index\&. The value is updated too related to the prefix math and the conversion factor of this operation\&. 
.PP
Definition at line 1408 of file dimension\&.cpp\&.
.PP
.nf
1409     {
1410         map<dimension::type,int> dimensions_count = map<dimension::type,int>();
1411         for (const dimension& x_dimension : x)
1412         {
1413             dimensions_count[x_dimension\&.dimension_type]++;
1414         }
1415         for (const auto& x_count : dimensions_count)
1416         {
1417             if ((x_count\&.second % index) != 0)
1418             {
1419                 return vector<dimension>();
1420             }
1421         }
1422         vector<dimension> new_dimensions = vector<dimension>();
1423         if (dimensions_count\&.size() == 1) // If there's only one type of dimension, square it and conserve its type
1424         {
1425             for (int i = 0; i < dimensions_count[x[0]\&.dimension_type]; i++)
1426             {
1427                 if (x[i]\&.dimension_position == dimension::NUMERATOR)
1428                 {
1429                     value *= x[i]\&.get_conversion_factor();
1430                     value *= x[i]\&.prefix_math();
1431                 }
1432                 else if (x[i]\&.dimension_position == dimension::DENOMINATOR)
1433                 {
1434                     value /= x[i]\&.get_conversion_factor();
1435                     value /= x[i]\&.prefix_math();
1436                 }
1437             }
1438             int total_dimensions = int(std::pow(dimensions_count[x[0]\&.dimension_type], 1\&.0f / index));
1439             x[0]\&.prefix\&.prefix_type = prefix::NONE;
1440             for (int j = 0; j < total_dimensions; j++)
1441             {
1442                 new_dimensions\&.push_back(x[0]);
1443             }
1444             return new_dimensions;
1445         }
1446         else // If there's more than one type of dimension, creates the derived dimensions of them, and squares the total\&. If there are abbreviations, they are losed
1447         {
1448             x = normalize_dimensions(x,value);
1449             vector<dimension::type> counted_dimensions = vector<dimension::type>();
1450             dimensions_count\&.clear();
1451             for (const dimension& x_dimension : x)
1452             {
1453                 dimensions_count[x_dimension\&.dimension_type]++;
1454             }
1455             for (const dimension& x_dimension : x)
1456             {
1457                 bool counted = false;
1458                 for (const dimension::type& counted_dimension : counted_dimensions)
1459                 {
1460                     if (counted_dimension == x_dimension\&.dimension_type)
1461                     {
1462                         counted = true;
1463                     }
1464                 }
1465                 if (counted == true)
1466                 {
1467                     continue;
1468                 }
1469                 int total_dimensions = int(std::pow(dimensions_count[x_dimension\&.dimension_type], 1\&.0f / index));
1470                 for (int j = 0; j < total_dimensions; j++)
1471                 {
1472                     new_dimensions\&.push_back(x_dimension);
1473                 }
1474                 counted_dimensions\&.push_back(x_dimension\&.dimension_type);
1475             }
1476         }
1477         return new_dimensions;
1478     }
.fi
.SS "float scifir::tan (const \fBangle\fP & x)"

.PP
Calculates the tan of angle x\&. It uses the \fBtan()\fP function of the standard library of C++, the difference is that angle is in degrees, not in radians\&. 
.PP
Definition at line 356 of file angle\&.cpp\&.
.PP
.nf
357     {
358         return std::tan(x\&.get_radian());
359     }
.fi
.SS "float scifir::tanh (const \fBangle\fP & x)"

.PP
Calculates the tanh of angle x\&. It uses the \fBtanh()\fP function of the standard library of C++, the difference is that angle is in degrees, not in radians\&. 
.PP
Definition at line 386 of file angle\&.cpp\&.
.PP
.nf
387     {
388         return std::tanh(x\&.get_radian());
389     }
.fi
.SS "scifir::time_duration::time_duration (const string & init_time)"

.PP
Definition at line 25 of file unit_basic\&.cpp\&.
.PP
.nf
25                                                         : scalar_unit()
26     {
27         if(!isdigit(init_time[0]))
28         {
29             return;
30         }
31         else
32         {
33             vector<string> init_values;
34             boost::split(init_values,init_time,boost::is_any_of(" "));
35             value = 0;
36             for (unsigned int i = 0; i < init_values\&.size(); i++)
37             {
38                 int j = 0;
39                 while(isdigit(init_values[i][j]) || init_values[i][j] == '\&.' || init_values[i][j] == ' ' || init_values[i][j] == '*' || init_values[i][j] == '^' || init_values[i][j] == 'e' || init_values[i][j] == 'E')
40                 {
41                     if (init_values[i][j] == ' ')
42                     {
43                         break;
44                     }
45                     j++;
46                 }
47                 string string_value = init_values[i]\&.substr(0, j);
48                 boost::algorithm::erase_all(string_value, " ");
49                 size_t search_e = string_value\&.find("E");
50                 if (search_e != string::npos)
51                 {
52                     string_value\&.replace(search_e,1,"e");
53                 }
54                 size_t search_10 = string_value\&.find("*10^");
55                 if (search_10 != string::npos)
56                 {
57                     string_value\&.replace(search_10,4,"e");
58                 }
59                 stringstream ss(string_value);
60                 float init_value_float;
61                 ss >> init_value_float;
62                 string init_value_dimension = init_values[i]\&.substr(j);
63                 float init_value_dimension_quantity = 0\&.0f;
64                 if (init_value_dimension == "d")
65                 {
66                     init_value_dimension_quantity = 86400\&.0f;
67                 }
68                 else if(init_value_dimension == "h")
69                 {
70                     init_value_dimension_quantity = 3600\&.0f;
71                 }
72                 else if(init_value_dimension == "min")
73                 {
74                     init_value_dimension_quantity = 60\&.0f;
75                 }
76                 else if(init_value_dimension == "s")
77                 {
78                     init_value_dimension_quantity = 1\&.0f;
79                 }
80                 value += init_value_float * init_value_dimension_quantity;
81             }
82             dimensions = create_dimensions("s");
83         }
84     }
.fi
.SS "string scifir::to_string (const \fBaid\fP & x)"

.PP
Definition at line 470 of file aid\&.cpp\&.
.PP
.nf
471     {
472         return x\&.display();
473     }
.fi
.SS "string scifir::to_string (const \fBaid::type\fP & x)"

.PP
Definition at line 475 of file aid\&.cpp\&.
.PP
.nf
476     {
477         switch (x)
478         {
479             case aid::UNIVERSE:
480                 return "U";
481             case aid::GALAXY:
482                 return "G";
483             case aid::SOLAR_SYSTEM:
484                 return "SS";
485             case aid::PLANET:
486                 return "P";
487             case aid::STAR:
488                 return "ST";
489             case aid::ASTEROID:
490                 return "A";
491             case aid::MOON:
492                 return "MN";
493             case aid::METEOR:
494                 return "MT";
495             case aid::NONE:
496                 return "";
497         }
498         return "";
499     }
.fi
.SS "string scifir::to_string (const \fBangle\fP & x)"

.PP
Converts an angle to their string representation\&. 
.PP
Definition at line 273 of file angle\&.cpp\&.
.PP
.nf
274     {
275         return x\&.display(2);
276     }
.fi
.SS "template<typename T > string scifir::to_string (const \fBcomplex_number\fP< T > & x)"

.PP
Definition at line 174 of file complex_number\&.hpp\&.
.PP
.nf
175     {
176         return x\&.display(2);
177     }
.fi
.SS "string scifir::to_string (const \fBcoordinates_1d\fP< float > & x)"

.PP
Definition at line 8 of file coordinates_1d\&.cpp\&.
.PP
.nf
9     {
10         return x\&.display_cartesian();
11     }
.fi
.SS "template<typename T > string scifir::to_string (const \fBcoordinates_1d\fP< T > & x)"

.PP
Definition at line 209 of file coordinates_1d\&.hpp\&.
.PP
.nf
210     {
211         return x\&.display_cartesian();
212     }
.fi
.SS "string scifir::to_string (const \fBcoordinates_2d\fP< float > & x)"

.PP
Definition at line 9 of file coordinates_2d\&.cpp\&.
.PP
.nf
10     {
11         return x\&.display_cartesian();
12     }
.fi
.SS "template<typename T > string scifir::to_string (const \fBcoordinates_2d\fP< T > & x)"

.PP
Definition at line 343 of file coordinates_2d\&.hpp\&.
.PP
.nf
344     {
345         return x\&.display_cartesian();
346     }
.fi
.SS "string scifir::to_string (const \fBcoordinates_2dr\fP< float > & x)"

.PP
Definition at line 7 of file coordinates_2dr\&.cpp\&.
.PP
.nf
8     {
9         return x\&.display_cartesian();
10     }
.fi
.SS "template<typename T > string scifir::to_string (const \fBcoordinates_2dr\fP< T > & x)"

.PP
Definition at line 484 of file coordinates_2dr\&.hpp\&.
.PP
.nf
485     {
486         return x\&.display_cartesian();
487     }
.fi
.SS "string scifir::to_string (const \fBcoordinates_3d\fP< float > & x)"

.PP
Definition at line 7 of file coordinates_3d\&.cpp\&.
.PP
.nf
8     {
9         return x\&.display_cartesian();
10     }
.fi
.SS "template<typename T > string scifir::to_string (const \fBcoordinates_3d\fP< T > & x)"

.PP
Definition at line 585 of file coordinates_3d\&.hpp\&.
.PP
.nf
586     {
587         return x\&.display_cartesian();
588     }
.fi
.SS "string scifir::to_string (const \fBcoordinates_3dr\fP< float > & x)"

.PP
Definition at line 7 of file coordinates_3dr\&.cpp\&.
.PP
.nf
8     {
9         return x\&.display_cartesian();
10     }
.fi
.SS "template<typename T > string scifir::to_string (const \fBcoordinates_3dr\fP< T > & x)"

.PP
Definition at line 932 of file coordinates_3dr\&.hpp\&.
.PP
.nf
933     {
934         return x\&.display_cartesian();
935     }
.fi
.SS "string scifir::to_string (const \fBcoordinates_nd\fP< float > & x)"

.PP
Definition at line 7 of file coordinates_nd\&.cpp\&.
.PP
.nf
8     {
9         if (x\&.values\&.size() > 0)
10         {
11             ostringstream out;
12             out << "(";
13             for (int i = 0; i < x\&.values\&.size(); i++)
14             {
15                 out << display_float(x\&.values[i]);
16                 if ((i + 1) != x\&.values\&.size())
17                 {
18                     out << ",";
19                 }
20             }
21             out << ")";
22             return out\&.str();
23         }
24         else
25         {
26             return "[empty]";
27         }
28     }
.fi
.SS "template<typename T > string scifir::to_string (const \fBcoordinates_nd\fP< T > & x)"

.PP
Definition at line 1062 of file coordinates_nd\&.hpp\&.
.PP
.nf
1063     {
1064         if (x\&.values\&.size() > 0)
1065         {
1066             ostringstream out;
1067             out << "(";
1068             for (int i = 0; i < x\&.values\&.size(); i++)
1069             {
1070                 out << x\&.values[i];
1071                 if ((i + 1) != x\&.values\&.size())
1072                 {
1073                     out << ",";
1074                 }
1075             }
1076             out << ")";
1077             return out\&.str();
1078         }
1079         else
1080         {
1081             return "[empty]";
1082         }
1083     }
.fi
.SS "string scifir::to_string (const \fBcoordinates_ndr\fP< float > & x)"

.PP
Definition at line 10 of file coordinates_ndr\&.cpp\&.
.PP
.nf
11     {
12         if (x\&.get_values()\&.size() > 0)
13         {
14             ostringstream out;
15             out << "(";
16             if (x\&.get_values()\&.size() > 0)
17             {
18                 for (int i = 0; i < x\&.get_values()\&.size(); i++)
19                 {
20                     out << display_float(x\&.get_value(i));
21                     if ((i + 1) != x\&.get_values()\&.size())
22                     {
23                         out << ",";
24                     }
25                 }
26             }
27             if (x\&.get_angles()\&.size() > 0)
28             {
29                 out << ";";
30                 for (int i = 0; i < x\&.get_angles()\&.size(); i++)
31                 {
32                     out << x\&.get_angle(i);
33                     if ((i + 1) != x\&.get_angles()\&.size())
34                     {
35                         out << ",";
36                     }
37                 }
38             }
39             out << ")";
40             return out\&.str();
41         }
42         else
43         {
44             return "[empty]";
45         }
46     }
.fi
.SS "template<typename T > string scifir::to_string (const \fBcoordinates_ndr\fP< T > & x)"

.PP
Definition at line 2145 of file coordinates_ndr\&.hpp\&.
.PP
.nf
2146     {
2147         if (x\&.get_values()\&.size() > 0)
2148         {
2149             ostringstream out;
2150             out << "(";
2151             if (x\&.get_values()\&.size() > 0)
2152             {
2153                 for (int i = 0; i < x\&.get_values()\&.size(); i++)
2154                 {
2155                     out << x\&.get_value(i);
2156                     if ((i + 1) != x\&.get_values()\&.size())
2157                     {
2158                         out << ",";
2159                     }
2160                 }
2161             }
2162             if (x\&.get_angles()\&.size() > 0)
2163             {
2164                 out << ";";
2165                 for (int i = 0; i < x\&.get_angles()\&.size(); i++)
2166                 {
2167                     out << x\&.get_angle(i);
2168                     if ((i + 1) != x\&.get_angles()\&.size())
2169                     {
2170                         out << ",";
2171                     }
2172                 }
2173             }
2174             out << ")";
2175             return out\&.str();
2176         }
2177         else
2178         {
2179             return "[empty]";
2180         }
2181     }
.fi
.SS "string scifir::to_string (const \fBdimension\fP & x)"

.PP
Creates the string representation of a dimension\&. 
.PP
Definition at line 1154 of file dimension\&.cpp\&.
.PP
.nf
1155     {
1156         ostringstream out;
1157         out << x\&.prefix << x\&.get_symbol();
1158         return out\&.str();
1159     }
.fi
.SS "string scifir::to_string (const \fBdirection\fP & x)"

.PP
Definition at line 341 of file direction\&.cpp\&.
.PP
.nf
342     {
343         return to_string(x\&.value);
344     }
.fi
.SS "string scifir::to_string (const \fBemotion\fP &)"

.SS "string scifir::to_string (const \fBfeeling\fP &)"

.SS "template<typename T > string scifir::to_string (const \fBlab_number\fP< T > & x)"

.PP
Definition at line 110 of file lab_number\&.hpp\&.
.PP
.nf
111     {
112         return x\&.display(2);
113     }
.fi
.SS "string scifir::to_string (const \fBpercentage\fP & x)"

.PP
Definition at line 471 of file percentage\&.cpp\&.
.PP
.nf
472     {
473         return x\&.display_percentage();
474     }
.fi
.SS "string scifir::to_string (const \fBpH\fP & x)"

.PP
Definition at line 200 of file pH\&.cpp\&.
.PP
.nf
201     {
202         return x\&.display(2);
203     }
.fi
.SS "string scifir::to_string (const \fBpixel\fP & x)"

.PP
Definition at line 184 of file pixel\&.cpp\&.
.PP
.nf
185     {
186         ostringstream output;
187         output << display_float(x\&.get_value()) << " px";
188         return output\&.str();
189     }
.fi
.SS "string scifir::to_string (const \fBpOH\fP & x)"

.PP
Definition at line 198 of file pOH\&.cpp\&.
.PP
.nf
199     {
200         return x\&.display(2);
201     }
.fi
.SS "string scifir::to_string (const \fBpoint_1d\fP< float > & x)"

.PP
Definition at line 28 of file point_1d\&.cpp\&.
.PP
.nf
29     {
30         return x\&.display_cartesian();
31     }
.fi
.SS "template<typename T > string scifir::to_string (const \fBpoint_1d\fP< T > & x)"

.PP
Definition at line 191 of file point_1d\&.hpp\&.
.PP
.nf
192     {
193         return x\&.display_cartesian();
194     }
.fi
.SS "string scifir::to_string (const \fBpoint_2d\fP< float > & x)"

.PP
Definition at line 30 of file point_2d\&.cpp\&.
.PP
.nf
31     {
32         return x\&.display_cartesian();
33     }
.fi
.SS "template<typename T > string scifir::to_string (const \fBpoint_2d\fP< T > & x)"

.PP
Definition at line 320 of file point_2d\&.hpp\&.
.PP
.nf
321     {
322         return x\&.display_cartesian();
323     }
.fi
.SS "string scifir::to_string (const \fBpoint_3d\fP< float > & x)"

.PP
Definition at line 32 of file point_3d\&.cpp\&.
.PP
.nf
33     {
34         return x\&.display_cartesian();
35     }
.fi
.SS "template<typename T > string scifir::to_string (const \fBpoint_3d\fP< T > & x)"

.PP
Definition at line 557 of file point_3d\&.hpp\&.
.PP
.nf
558     {
559         return x\&.display_cartesian();
560     }
.fi
.SS "string scifir::to_string (const \fBpoint_nd\fP< float > & x)"

.PP
Definition at line 28 of file point_nd\&.cpp\&.
.PP
.nf
29     {
30         if (x\&.values\&.size() > 0)
31         {
32             ostringstream out;
33             out << "(";
34             for (int i = 0; i < x\&.values\&.size(); i++)
35             {
36                 out << display_float(x\&.values[i]);
37                 if ((i + 1) != x\&.values\&.size())
38                 {
39                     out << ",";
40                 }
41             }
42             out << ")";
43             return out\&.str();
44         }
45         else
46         {
47             return "[empty]";
48         }
49     }
.fi
.SS "template<typename T > string scifir::to_string (const \fBpoint_nd\fP< T > & x)"

.PP
Definition at line 1046 of file point_nd\&.hpp\&.
.PP
.nf
1047     {
1048         if (x\&.values\&.size() > 0)
1049         {
1050             ostringstream out;
1051             out << "(";
1052             for (int i = 0; i < x\&.values\&.size(); i++)
1053             {
1054                 out << x\&.values[i];
1055                 if ((i + 1) != x\&.values\&.size())
1056                 {
1057                     out << ",";
1058                 }
1059             }
1060             out << ")";
1061             return out\&.str();
1062         }
1063         else
1064         {
1065             return "[empty]";
1066         }
1067     }
.fi
.SS "string scifir::to_string (const \fBscalar_unit\fP & x)"

.PP
Generates an string representation of the \fBscalar_unit\fP, it uses the display of the \fBscalar_unit\fP with 2 decimals, without brackets and without a close prefix\&. 
.PP
\fBParameters\fP
.RS 4
\fIx\fP \fBscalar_unit\fP to generate the string\&. 
.RE
.PP

.PP
Definition at line 537 of file scalar_unit\&.cpp\&.
.PP
.nf
538     {
539         return x\&.display(2);
540     }
.fi
.SS "string scifir::to_string (const \fBsensation\fP &)"

.SS "string scifir::to_string (const \fBsize_2d\fP< float > & x)"

.PP
Definition at line 7 of file size_2d\&.cpp\&.
.PP
.nf
8     {
9         return x\&.display();
10     }
.fi
.SS "template<typename T > string scifir::to_string (const \fBsize_2d\fP< T > & x)"

.PP
Definition at line 208 of file size_2d\&.hpp\&.
.PP
.nf
209     {
210         return x\&.display();
211     }
.fi
.SS "string scifir::to_string (const \fBsize_3d\fP< float > & x)"

.PP
Definition at line 7 of file size_3d\&.cpp\&.
.PP
.nf
8     {
9         return x\&.display();
10     }
.fi
.SS "template<typename T > string scifir::to_string (const \fBsize_3d\fP< T > & x)"

.PP
Definition at line 222 of file size_3d\&.hpp\&.
.PP
.nf
223     {
224         return x\&.display();
225     }
.fi
.SS "string scifir::to_string (const \fBsize_nd\fP< float > & x)"

.PP
Definition at line 7 of file size_nd\&.cpp\&.
.PP
.nf
8     {
9         return x\&.display();
10     }
.fi
.SS "template<typename T > string scifir::to_string (const \fBsize_nd\fP< T > & x)"

.PP
Definition at line 332 of file size_nd\&.hpp\&.
.PP
.nf
333     {
334         return x\&.display();
335     }
.fi
.SS "string scifir::to_string (const vector< \fBdimension\fP > & x_dimensions, bool with_brackets = \fCfalse\fP)"

.PP
Creates the string representation of a vector of dimensions\&. Used to display the dimensions of \fBscalar_unit\fP and all vector_unit classes\&. The dimensions can be displayed optionally between brackets like '[]' too\&. 
.PP
Definition at line 1161 of file dimension\&.cpp\&.
.PP
.nf
1162     {
1163         ostringstream out;
1164         if (x_dimensions\&.size() > 0)
1165         {
1166             if (with_brackets)
1167             {
1168                 out << "[";
1169             }
1170             vector<dimension::type> printed_dimensions = vector<dimension::type>();
1171             map<prefix,int> counted_prefixes = map<prefix,int>();
1172             bool first_print = true;
1173             for (const dimension& x_dimension : x_dimensions)
1174             {
1175                 if (x_dimension\&.dimension_position == dimension::NUMERATOR)
1176                 {
1177                     bool printed = false;
1178                     for (const dimension::type& print_dimension : printed_dimensions)
1179                     {
1180                         if (print_dimension == x_dimension\&.dimension_type)
1181                         {
1182                             printed = true;
1183                         }
1184                     }
1185                     if (printed == true)
1186                     {
1187                         continue;
1188                     }
1189                     counted_prefixes = map<prefix,int>();
1190                     for (const dimension& y_dimension : x_dimensions)
1191                     {
1192                         if (x_dimension\&.dimension_type == y_dimension\&.dimension_type)
1193                         {
1194                             counted_prefixes[y_dimension\&.prefix]++;
1195                         }
1196                     }
1197                     for (const auto& x_prefix : counted_prefixes)
1198                     {
1199                         if (!first_print)
1200                         {
1201                             out << "*";
1202                         }
1203                         out << x_prefix\&.first << x_dimension\&.get_symbol();
1204                         if (x_prefix\&.second > 1)
1205                         {
1206                             out << x_prefix\&.second;
1207                         }
1208                         first_print = false;
1209                     }
1210                     printed_dimensions\&.push_back(x_dimension\&.dimension_type);
1211                 }
1212             }
1213             printed_dimensions\&.clear();
1214             bool first_negative_iteration = true;
1215             bool first_negative_prefix = true;
1216             for (const dimension& x_dimension : x_dimensions)
1217             {
1218                 if (x_dimension\&.dimension_position == dimension::DENOMINATOR)
1219                 {
1220                     if (first_negative_iteration == true)
1221                     {
1222                         if (first_print)
1223                         {
1224                             out << "1";
1225                         }
1226                         out << "/";
1227                         first_negative_iteration = false;
1228                     }
1229                     bool printed = false;
1230                     for (const dimension::type& print_dimension : printed_dimensions)
1231                     {
1232                         if (print_dimension == x_dimension\&.dimension_type)
1233                         {
1234                             printed = true;
1235                         }
1236                     }
1237                     if (printed == true)
1238                     {
1239                         continue;
1240                     }
1241                     counted_prefixes = map<prefix,int>();
1242                     for (const dimension& y_dimension : x_dimensions)
1243                     {
1244                         if (x_dimension\&.dimension_type == y_dimension\&.dimension_type)
1245                         {
1246                             counted_prefixes[y_dimension\&.prefix]++;
1247                         }
1248                     }
1249                     for (const auto& x_prefix : counted_prefixes)
1250                     {
1251                         if (first_negative_prefix == false)
1252                         {
1253                             out << "*";
1254                         }
1255                         out << x_prefix\&.first << x_dimension\&.get_symbol();
1256                         if (x_prefix\&.second > 1)
1257                         {
1258                             out << x_prefix\&.second;
1259                         }
1260                         first_negative_prefix = false;
1261                     }
1262                     printed_dimensions\&.push_back(x_dimension\&.dimension_type);
1263                 }
1264             }
1265             if (with_brackets)
1266             {
1267                 out << "]";
1268             }
1269         }
1270         else
1271         {
1272             out << "[empty]";
1273         }
1274         return out\&.str();
1275     }
.fi
.SS "string scifir::to_string (const \fBvector_unit_2d\fP & x)"

.PP
It generates a string representation of \fBvector_unit_2d\fP\&. 
.SS "string scifir::to_string (const \fBvector_unit_3d\fP & x)"

.PP
It generates a string representation of \fBvector_unit_3d\fP\&. 
.SS "string scifir::to_string (const \fBvector_unit_nd\fP & x)"

.PP
It generates a string representation of \fBvector_unit_nd\fP\&. 
.PP
Definition at line 737 of file vector_unit_nd\&.cpp\&.
.PP
.nf
738     {
739         return x\&.vectorial_display(2);
740     }
.fi
.SS "string scifir::to_string (const \fBzid\fP & x)"

.PP
Definition at line 171 of file zid\&.cpp\&.
.PP
.nf
172     {
173         return x\&.display();
174     }
.fi
.SS "string scifir::to_string (\fBdirection::name\fP x)"

.PP
Definition at line 279 of file direction\&.cpp\&.
.PP
.nf
280     {
281         switch (x)
282         {
283             case direction::NONE:
284                 return "";
285             case direction::LEFT:
286                 return "left";
287             case direction::RIGHT:
288                 return "right";
289             case direction::TOP:
290                 return "top";
291             case direction::BOTTOM:
292                 return "bottom";
293             case direction::FRONT:
294                 return "front";
295             case direction::BACK:
296                 return "back";
297             case direction::LEFT_TOP:
298                 return "left-top";
299             case direction::LEFT_BOTTOM:
300                 return "left-bottom";
301             case direction::RIGHT_TOP:
302                 return "right-top";
303             case direction::RIGHT_BOTTOM:
304                 return "right-bottom";
305             case direction::LEFT_FRONT:
306                 return "left-front";
307             case direction::LEFT_BACK:
308                 return "left-back";
309             case direction::RIGHT_FRONT:
310                 return "right-front";
311             case direction::RIGHT_BACK:
312                 return "right-back";
313             case direction::TOP_FRONT:
314                 return "top-front";
315             case direction::TOP_BACK:
316                 return "top-back";
317             case direction::BOTTOM_FRONT:
318                 return "bottom-front";
319             case direction::BOTTOM_BACK:
320                 return "bottom-back";
321             case direction::LEFT_TOP_FRONT:
322                 return "left-top-front";
323             case direction::LEFT_TOP_BACK:
324                 return "left-top-back";
325             case direction::LEFT_BOTTOM_FRONT:
326                 return "left-bottom-front";
327             case direction::LEFT_BOTTOM_BACK:
328                 return "left-bottom-back";
329             case direction::RIGHT_TOP_FRONT:
330                 return "right-top-front";
331             case direction::RIGHT_TOP_BACK:
332                 return "right-top-back";
333             case direction::RIGHT_BOTTOM_FRONT:
334                 return "right-bottom-front";
335             case direction::RIGHT_BOTTOM_BACK:
336                 return "right-bottom-back";
337         }
338         return "";
339     }
.fi
.SS "scifir::VECTOR_UNIT_2D_CPP (displacement, 'm')"

.SS "scifir::VECTOR_UNIT_2D_HPP (displacement)"

.SS "scifir::VECTOR_UNIT_3D_CPP (displacement, 'm')"

.SS "scifir::VECTOR_UNIT_3D_HPP (displacement)"

.SS "scifir::VECTOR_UNIT_CPP (acceleration, 'm/s2')"

.SS "scifir::VECTOR_UNIT_CPP (angular_acceleration, 'rad/s2')"

.SS "scifir::VECTOR_UNIT_CPP (angular_momentum, 'm2*kg/s')"

.SS "scifir::VECTOR_UNIT_CPP (angular_velocity, 'rad/s')"

.SS "scifir::VECTOR_UNIT_CPP (electric_displacement_field, 'A*s/m2')"

.SS "scifir::VECTOR_UNIT_CPP (electric_field_strength, 'kg*m/A*s3')"

.SS "scifir::VECTOR_UNIT_CPP (force, 'kg*m/s2')"

.SS "scifir::VECTOR_UNIT_CPP (impulse, 'm*kg/s')"

.SS "scifir::VECTOR_UNIT_CPP (irradiance, 'kg/s3')"

.SS "scifir::VECTOR_UNIT_CPP (jerk, 'm/s3')"

.SS "scifir::VECTOR_UNIT_CPP (magnetic_moment, 'A*m2')"

.SS "scifir::VECTOR_UNIT_CPP (magnetic_strength, 'Wb/m2')"

.SS "scifir::VECTOR_UNIT_CPP (magnetic_vector_potential, 'kg*m/A*s2')"

.SS "scifir::VECTOR_UNIT_CPP (magnetomotive_force, 'A')"

.SS "scifir::VECTOR_UNIT_CPP (pressure, 'kg/m*s2')"

.SS "scifir::VECTOR_UNIT_CPP (radiant_exposure, 'kg/s2')"

.SS "scifir::VECTOR_UNIT_CPP (radiant_flux, 'kg*m2/s3')"

.SS "scifir::VECTOR_UNIT_CPP (snap, 'm/s4')"

.SS "scifir::VECTOR_UNIT_CPP (specific_angular_momentum, 'm2/s')"

.SS "scifir::VECTOR_UNIT_CPP (spectral_flux, 'kg*m/s3')"

.SS "scifir::VECTOR_UNIT_CPP (surface_tension, 'kg/s2')"

.SS "scifir::VECTOR_UNIT_CPP (temperature_gradient, 'K/m')"

.SS "scifir::VECTOR_UNIT_CPP (torque, 'kg*m2/s2')"

.SS "scifir::VECTOR_UNIT_CPP (velocity, 'm/s')"

.SS "scifir::VECTOR_UNIT_HPP (acceleration)"

.SS "scifir::VECTOR_UNIT_HPP (angular_acceleration)"

.SS "scifir::VECTOR_UNIT_HPP (angular_momentum)"

.SS "scifir::VECTOR_UNIT_HPP (angular_velocity)"

.SS "scifir::VECTOR_UNIT_HPP (electric_displacement_field)"

.SS "scifir::VECTOR_UNIT_HPP (electric_field_strength)"

.SS "scifir::VECTOR_UNIT_HPP (force)"

.SS "scifir::VECTOR_UNIT_HPP (impulse)"

.SS "scifir::VECTOR_UNIT_HPP (irradiance)"

.SS "scifir::VECTOR_UNIT_HPP (jerk)"

.SS "scifir::VECTOR_UNIT_HPP (magnetic_moment)"

.SS "scifir::VECTOR_UNIT_HPP (magnetic_strength)"

.SS "scifir::VECTOR_UNIT_HPP (magnetic_vector_potential)"

.SS "scifir::VECTOR_UNIT_HPP (magnetomotive_force)"

.SS "scifir::VECTOR_UNIT_HPP (pressure)"

.SS "scifir::VECTOR_UNIT_HPP (radiant_exposure)"

.SS "scifir::VECTOR_UNIT_HPP (radiant_flux)"

.SS "scifir::VECTOR_UNIT_HPP (snap)"

.SS "scifir::VECTOR_UNIT_HPP (specific_angular_momentum)"

.SS "scifir::VECTOR_UNIT_HPP (spectral_flux)"

.SS "scifir::VECTOR_UNIT_HPP (surface_tension)"

.SS "scifir::VECTOR_UNIT_HPP (temperature_gradient)"

.SS "scifir::VECTOR_UNIT_HPP (torque)"

.SS "scifir::VECTOR_UNIT_HPP (velocity)"

.SS "scifir::VECTOR_UNIT_ND_CPP (displacement, 'm')"

.SS "scifir::VECTOR_UNIT_ND_HPP (displacement)"

.SS "scifir::volume::volume (const \fBsize_3d\fP< length > & x)\fC [explicit]\fP"

.PP
Definition at line 22 of file space_units\&.cpp\&.
.PP
.nf
22                                            : scalar_unit()
23     {
24         length x_height = x\&.height;
25         length x_depth = x\&.depth;
26         x_height\&.change_dimensions(x\&.width);
27         x_depth\&.change_dimensions(x\&.width);
28         *this = x\&.width * x_height * x_depth;
29     }
.fi
.SH "Variable Documentation"
.PP 
.SS "const long double scifir::AVOGADRO_CONSTANT = 6\&.02214076e23\fC [static]\fP"

.PP
Definition at line 11 of file constants\&.hpp\&.
.SS "\fBangle\fP scifir::coordinates_ndr_no_angle = \fBangle\fP()"

.PP
Definition at line 7 of file coordinates_ndr\&.cpp\&.
.SS "map< string, \fBconversion\fP > scifir::get_conversion"

.PP
Definition at line 22 of file conversion\&.cpp\&.
.SS "constexpr float scifir::PI = boost::math::constants::pi<float>()\fC [constexpr]\fP"

.PP
Definition at line 10 of file constants\&.hpp\&.
.SH "Author"
.PP 
Generated automatically by Doxygen for scifir-units from the source code\&.
