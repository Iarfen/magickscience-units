.TH "scifir::matrix< T, M, N >" 3 "Sat Jul 13 2024" "Version 2.0.0" "scifir-units" \" -*- nroff -*-
.ad l
.nh
.SH NAME
scifir::matrix< T, M, N >
.SH SYNOPSIS
.br
.PP
.PP
\fC#include <matrix\&.hpp>\fP
.SS "Public Member Functions"

.in +1c
.ti -1c
.RI "\fBmatrix\fP ()"
.br
.ti -1c
.RI "\fBmatrix\fP (initializer_list< vector< T >> x)"
.br
.ti -1c
.RI "virtual \fBmatrix\fP< T, M, N > * \fBclone\fP () const"
.br
.ti -1c
.RI "int \fBrow_size\fP () const"
.br
.ti -1c
.RI "int \fBcolumn_size\fP () const"
.br
.ti -1c
.RI "\fBmatrix\fP< T, 1, N > \fBrow\fP (int i) const"
.br
.ti -1c
.RI "\fBmatrix\fP< T, M, 1 > \fBcolumn\fP (int j) const"
.br
.ti -1c
.RI "const T & \fBoperator()\fP (int i, int j) const"
.br
.ti -1c
.RI "T & \fBoperator()\fP (int i, int j)"
.br
.ti -1c
.RI "\fBmatrix\fP< T, M, N > \fBoperator+\fP (const \fBmatrix\fP< T, M, N > &x)"
.br
.ti -1c
.RI "\fBmatrix\fP< T, M, N > \fBoperator\-\fP (const \fBmatrix\fP< T, M, N > &x)"
.br
.ti -1c
.RI "template<int N2> \fBmatrix\fP< T, N, N2 > \fBoperator*\fP (const \fBmatrix\fP< T, N, N2 > &x)"
.br
.ti -1c
.RI "template<typename U , typename  = typename enable_if<is_integer_number<T>::value>::type> \fBmatrix\fP< T, M, N > \fBoperator^\fP (U x)"
.br
.ti -1c
.RI "void \fBoperator+=\fP (const \fBmatrix\fP< T, M, N > &x)"
.br
.ti -1c
.RI "void \fBoperator\-=\fP (const \fBmatrix\fP< T, M, N > &x)"
.br
.ti -1c
.RI "template<typename U , typename  = typename enable_if<is_integer_number<T>::value>::type> void \fBoperator^=\fP (U x)"
.br
.ti -1c
.RI "\fBmatrix\fP< T, N, M > \fBt\fP () const"
.br
.ti -1c
.RI "bool \fBis_square\fP () const"
.br
.ti -1c
.RI "bool \fBis_diagonal\fP () const"
.br
.in -1c
.SS "Private Member Functions"

.in +1c
.ti -1c
.RI "bool \fBoutside_row_limits\fP (int i) const"
.br
.ti -1c
.RI "bool \fBoutside_column_limits\fP (int i) const"
.br
.ti -1c
.RI "bool \fBoutside_limits\fP (int i, int j) const"
.br
.in -1c
.SS "Private Attributes"

.in +1c
.ti -1c
.RI "vector< vector< T > > \fBdata\fP"
.br
.in -1c
.SH "Detailed Description"
.PP 

.SS "template<typename T, int M, int N>
.br
class scifir::matrix< T, M, N >"

.PP
Definition at line 15 of file matrix\&.hpp\&.
.SH "Constructor & Destructor Documentation"
.PP 
.SS "template<typename T , int M, int N> \fBscifir::matrix\fP< T, M, N >::\fBmatrix\fP ()\fC [inline]\fP"

.PP
Definition at line 18 of file matrix\&.hpp\&.
.PP
.nf
18                      : data(vector<vector<T>>(M, vector<T>(N)))
19             {}
.fi
.SS "template<typename T , int M, int N> \fBscifir::matrix\fP< T, M, N >::\fBmatrix\fP (initializer_list< vector< T >> x)\fC [inline]\fP"

.PP
Definition at line 21 of file matrix\&.hpp\&.
.PP
.nf
21                                                   : matrix()
22             {
23                 if(x\&.size() != M)
24                 {
25                     return;
26                 }
27                 for(const auto& column : x)
28                 {
29                     if(column\&.size() != N)
30                     {
31                         return;
32                     }
33                 }
34                 int i = 0;
35                 for(const auto& column : x)
36                 {
37                     for(int j = 0; j < N; j++)
38                     {
39                         data[i][j] = column[j];
40                     }
41                     i++;
42                 }
43             }
.fi
.SH "Member Function Documentation"
.PP 
.SS "template<typename T , int M, int N> virtual \fBmatrix\fP<T, M, N>* \fBscifir::matrix\fP< T, M, N >::clone () const\fC [inline]\fP, \fC [virtual]\fP"

.PP
Definition at line 45 of file matrix\&.hpp\&.
.PP
.nf
46             {
47                 return new matrix<T, M, N>(static_cast<const matrix<T, M, N>&>(*this));
48             }
.fi
.SS "template<typename T , int M, int N> \fBmatrix\fP<T,M,1> \fBscifir::matrix\fP< T, M, N >::column (int j) const\fC [inline]\fP"

.PP
Definition at line 74 of file matrix\&.hpp\&.
.PP
.nf
75             {
76                 if (outside_column_limits(j))
77                 {
78                     return matrix<T,M,1>();
79                 }
80                 matrix<T,M,1> x = matrix<T,M,1>();
81                 for (int i = 0; i < M; i++)
82                 {
83                     x(i + 1,1) = data[i][j - 1];
84                 }
85                 return std::move(x);
86             }
.fi
.SS "template<typename T , int M, int N> int \fBscifir::matrix\fP< T, M, N >::column_size () const\fC [inline]\fP"

.PP
Definition at line 55 of file matrix\&.hpp\&.
.PP
.nf
56             {
57                 return N;
58             }
.fi
.SS "template<typename T , int M, int N> bool \fBscifir::matrix\fP< T, M, N >::is_diagonal () const\fC [inline]\fP"

.PP
Definition at line 211 of file matrix\&.hpp\&.
.PP
.nf
212             {
213                 for(int i = 0; i < M; i++)
214                 {
215                     for(int j = 0; j < N; j++)
216                     {
217                         if(i != j and data[i][j] != 0)
218                         {
219                             return false;
220                         }
221                     }
222                 }
223                 return true;
224             }
.fi
.SS "template<typename T , int M, int N> bool \fBscifir::matrix\fP< T, M, N >::is_square () const\fC [inline]\fP"

.PP
Definition at line 199 of file matrix\&.hpp\&.
.PP
.nf
200             {
201                 if(M == N)
202                 {
203                     return true;
204                 }
205                 else
206                 {
207                     return false;
208                 }
209             }
.fi
.SS "template<typename T , int M, int N> T& \fBscifir::matrix\fP< T, M, N >::operator() (int i, int j)\fC [inline]\fP"

.PP
Definition at line 97 of file matrix\&.hpp\&.
.PP
.nf
98             {
99                 if (outside_limits(i,j))
100                 {
101                     return T();
102                 }
103                 return data[i - 1][j - 1];
104             }
.fi
.SS "template<typename T , int M, int N> const T& \fBscifir::matrix\fP< T, M, N >::operator() (int i, int j) const\fC [inline]\fP"

.PP
Definition at line 88 of file matrix\&.hpp\&.
.PP
.nf
89             {
90                 if (outside_limits(i,j))
91                 {
92                     return T();
93                 }
94                 return data[i - 1][j - 1];
95             }
.fi
.SS "template<typename T , int M, int N> template<int N2> \fBmatrix\fP<T, N, N2> \fBscifir::matrix\fP< T, M, N >::operator* (const \fBmatrix\fP< T, N, N2 > & x)\fC [inline]\fP"

.PP
Definition at line 121 of file matrix\&.hpp\&.
.PP
.nf
122             {
123                 matrix<T, N, N2> new_matrix = matrix<T, N, N2>();
124                 for(int i = 0; i < M; i++)
125                 {
126                     for(int j = 0; j < N2; j++)
127                     {
128                         T a = 0;
129                         for(int k = 0; k < N; k++)
130                         {
131                             a += data[i][k] * x(k + 1,j + 1);
132                         }
133                         new_matrix(i + 1,j + 1) = a;
134                     }
135                 }
136                 return move(new_matrix);
137             }
.fi
.SS "template<typename T , int M, int N> \fBmatrix\fP<T, M, N> \fBscifir::matrix\fP< T, M, N >::operator+ (const \fBmatrix\fP< T, M, N > & x)\fC [inline]\fP"

.PP
Definition at line 106 of file matrix\&.hpp\&.
.PP
.nf
107             {
108                 matrix<T, M, N> y = *clone();
109                 y += x;
110                 return std::move(y);
111             }
.fi
.SS "template<typename T , int M, int N> void \fBscifir::matrix\fP< T, M, N >::operator+= (const \fBmatrix\fP< T, M, N > & x)\fC [inline]\fP"

.PP
Definition at line 147 of file matrix\&.hpp\&.
.PP
.nf
148             {
149                 for(int i = 0; i < M; i++)
150                 {
151                     for(int j = 0; j < N; j++)
152                     {
153                         data[i][j] += x(i + 1,j + 1);
154                     }
155                 }
156             }
.fi
.SS "template<typename T , int M, int N> \fBmatrix\fP<T, M, N> \fBscifir::matrix\fP< T, M, N >::operator\- (const \fBmatrix\fP< T, M, N > & x)\fC [inline]\fP"

.PP
Definition at line 113 of file matrix\&.hpp\&.
.PP
.nf
114             {
115                 matrix<T, M, N> y = *clone();
116                 y -= x;
117                 return std::move(y);
118             }
.fi
.SS "template<typename T , int M, int N> void \fBscifir::matrix\fP< T, M, N >::operator\-= (const \fBmatrix\fP< T, M, N > & x)\fC [inline]\fP"

.PP
Definition at line 158 of file matrix\&.hpp\&.
.PP
.nf
159             {
160                 for(int i = 0; i < M; i++)
161                 {
162                     for(int j = 0; j < N; j++)
163                     {
164                         data[i][j] -= x(i + 1,j + 1);
165                     }
166                 }
167             }
.fi
.SS "template<typename T , int M, int N> template<typename U , typename  = typename enable_if<is_integer_number<T>::value>::type> \fBmatrix\fP<T, M, N> \fBscifir::matrix\fP< T, M, N >::operator^ (U x)\fC [inline]\fP"

.PP
Definition at line 140 of file matrix\&.hpp\&.
.PP
.nf
141             {
142                 matrix<T, M, N> y = *clone();
143                 y ^= x;
144                 return move(y);
145             }
.fi
.SS "template<typename T , int M, int N> template<typename U , typename  = typename enable_if<is_integer_number<T>::value>::type> void \fBscifir::matrix\fP< T, M, N >::operator^= (U x)\fC [inline]\fP"

.PP
Definition at line 170 of file matrix\&.hpp\&.
.PP
.nf
171             {
172                 matrix<T,M,N> new_data = *clone();
173                 for(int i = 2; i <= x; i++)
174                 {
175                     new_data = (new_data * (*this));
176                 }
177                 for (int i = 0; i < M; i++)
178                 {
179                     for (int j = 0; j < N; j++)
180                     {
181                         data[i][j] = new_data(i + 1,j + 1);
182                     }
183                 }
184             }
.fi
.SS "template<typename T , int M, int N> bool \fBscifir::matrix\fP< T, M, N >::outside_column_limits (int i) const\fC [inline]\fP, \fC [private]\fP"

.PP
Definition at line 238 of file matrix\&.hpp\&.
.PP
.nf
239             {
240                 if (i < 1 or i > N)
241                 {
242                     return true;
243                 }
244                 return false;
245             }
.fi
.SS "template<typename T , int M, int N> bool \fBscifir::matrix\fP< T, M, N >::outside_limits (int i, int j) const\fC [inline]\fP, \fC [private]\fP"

.PP
Definition at line 247 of file matrix\&.hpp\&.
.PP
.nf
248             {
249                 if (outside_row_limits(i) or outside_column_limits(j))
250                 {
251                     return true;
252                 }
253                 return false;
254             }
.fi
.SS "template<typename T , int M, int N> bool \fBscifir::matrix\fP< T, M, N >::outside_row_limits (int i) const\fC [inline]\fP, \fC [private]\fP"

.PP
Definition at line 229 of file matrix\&.hpp\&.
.PP
.nf
230             {
231                 if (i < 1 or i > M)
232                 {
233                     return true;
234                 }
235                 return false;
236             }
.fi
.SS "template<typename T , int M, int N> \fBmatrix\fP<T,1,N> \fBscifir::matrix\fP< T, M, N >::row (int i) const\fC [inline]\fP"

.PP
Definition at line 60 of file matrix\&.hpp\&.
.PP
.nf
61             {
62                 if (outside_row_limits(i))
63                 {
64                     return matrix<T,1,N>();
65                 }
66                 matrix<T,1,N> x = matrix<T,1,N>();
67                 for (int j = 0; j < N; j++)
68                 {
69                     x(1,j + 1) = data[i - 1][j];
70                 }
71                 return std::move(x);
72             }
.fi
.SS "template<typename T , int M, int N> int \fBscifir::matrix\fP< T, M, N >::row_size () const\fC [inline]\fP"

.PP
Definition at line 50 of file matrix\&.hpp\&.
.PP
.nf
51             {
52                 return M;
53             }
.fi
.SS "template<typename T , int M, int N> \fBmatrix\fP<T, N, M> \fBscifir::matrix\fP< T, M, N >::t () const\fC [inline]\fP"

.PP
Definition at line 186 of file matrix\&.hpp\&.
.PP
.nf
187             {
188                 matrix<T, N, M> new_data = matrix<T, N, M>();
189                 for(int i = 0; i < M; i++)
190                 {
191                     for(int j = 0; j < N; j++)
192                     {
193                         new_data(j + 1,i + 1) = data[i][j];
194                     }
195                 }
196                 return move(new_data);
197             }
.fi
.SH "Member Data Documentation"
.PP 
.SS "template<typename T , int M, int N> vector<vector<T> > \fBscifir::matrix\fP< T, M, N >::data\fC [private]\fP"

.PP
Definition at line 227 of file matrix\&.hpp\&.

.SH "Author"
.PP 
Generated automatically by Doxygen for scifir-units from the source code\&.
