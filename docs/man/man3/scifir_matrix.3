.TH "scifir::matrix< T, M, N >" 3 "Version 2.0.0" "scifir-units" \" -*- nroff -*-
.ad l
.nh
.SH NAME
scifir::matrix< T, M, N >
.SH SYNOPSIS
.br
.PP
.PP
\fC#include <matrix\&.hpp>\fP
.SS "Public Member Functions"

.in +1c
.ti -1c
.RI "\fBmatrix\fP ()"
.br
.ti -1c
.RI "\fBmatrix\fP (\fBinitializer_list\fP< vector< T > > x)"
.br
.ti -1c
.RI "\fBvirtual\fP \fBmatrix\fP< T, M, N > * \fBclone\fP () \fBconst\fP"
.br
.ti -1c
.RI "\fBint\fP \fBrow_size\fP () \fBconst\fP"
.br
.ti -1c
.RI "\fBint\fP \fBcolumn_size\fP () \fBconst\fP"
.br
.ti -1c
.RI "\fBmatrix\fP< T, 1, N > \fBrow\fP (\fBint\fP \fBi\fP) \fBconst\fP"
.br
.ti -1c
.RI "\fBmatrix\fP< T, M, 1 > \fBcolumn\fP (\fBint\fP \fBj\fP) \fBconst\fP"
.br
.ti -1c
.RI "\fBconst\fP T & \fBoperator()\fP (\fBint\fP \fBi\fP, \fBint\fP \fBj\fP) \fBconst\fP"
.br
.ti -1c
.RI "T & \fBoperator()\fP (\fBint\fP \fBi\fP, \fBint\fP \fBj\fP)"
.br
.ti -1c
.RI "\fBmatrix\fP< T, M, N > \fBoperator+\fP (\fBconst\fP \fBmatrix\fP< T, M, N > &x)"
.br
.ti -1c
.RI "\fBmatrix\fP< T, M, N > \fBoperator\-\fP (\fBconst\fP \fBmatrix\fP< T, M, N > &x)"
.br
.ti -1c
.RI "template<\fBint\fP N2> \fBmatrix\fP< T, N, \fBN2\fP > \fBoperator*\fP (\fBconst\fP \fBmatrix\fP< T, N, \fBN2\fP > &x)"
.br
.ti -1c
.RI "template<\fBtypename\fP \fBU\fP , \fBtypename\fP  = typename enable_if<is_integer_number<T>::value>::type> \fBmatrix\fP< T, M, N > \fBoperator^\fP (\fBU\fP x)"
.br
.ti -1c
.RI "\fBvoid\fP \fBoperator+=\fP (\fBconst\fP \fBmatrix\fP< T, M, N > &x)"
.br
.ti -1c
.RI "\fBvoid\fP \fBoperator\-=\fP (\fBconst\fP \fBmatrix\fP< T, M, N > &x)"
.br
.ti -1c
.RI "template<\fBtypename\fP \fBU\fP , \fBtypename\fP  = typename enable_if<is_integer_number<T>::value>::type> \fBvoid\fP \fBoperator^=\fP (\fBU\fP x)"
.br
.ti -1c
.RI "\fBmatrix\fP< T, N, M > \fBt\fP () \fBconst\fP"
.br
.ti -1c
.RI "\fBbool\fP \fBis_square\fP () \fBconst\fP"
.br
.ti -1c
.RI "\fBbool\fP \fBis_diagonal\fP () \fBconst\fP"
.br
.in -1c
.SS "Private Member Functions"

.in +1c
.ti -1c
.RI "\fBbool\fP \fBoutside_row_limits\fP (\fBint\fP \fBi\fP) \fBconst\fP"
.br
.ti -1c
.RI "\fBbool\fP \fBoutside_column_limits\fP (\fBint\fP \fBi\fP) \fBconst\fP"
.br
.ti -1c
.RI "\fBbool\fP \fBoutside_limits\fP (\fBint\fP \fBi\fP, \fBint\fP \fBj\fP) \fBconst\fP"
.br
.in -1c
.SS "Private Attributes"

.in +1c
.ti -1c
.RI "vector< vector< T > > \fBdata\fP"
.br
.in -1c
.SH "Detailed Description"
.PP 

.SS "template<\fBtypename\fP T, \fBint\fP M, \fBint\fP N>
.br
class scifir::matrix< T, M, N >"
.PP
Definition at line \fB15\fP of file \fBmatrix\&.hpp\fP\&.
.SH "Constructor & Destructor Documentation"
.PP 
.SS "template<\fBtypename\fP T , \fBint\fP M, \fBint\fP N> \fBscifir::matrix\fP< T, M, N >::matrix ()\fC [inline]\fP"

.PP
Definition at line \fB18\fP of file \fBmatrix\&.hpp\fP\&..PP
.nf
18                      : data(vector<vector<T>>(M, vector<T>(N)))
19             {}
.fi

.SS "template<\fBtypename\fP T , \fBint\fP M, \fBint\fP N> \fBscifir::matrix\fP< T, M, N >::matrix (\fBinitializer_list\fP< vector< T > > x)\fC [inline]\fP"

.PP
Definition at line \fB21\fP of file \fBmatrix\&.hpp\fP\&..PP
.nf
21                                                   : matrix()
22             {
23                 if(x\&.size() != M)
24                 {
25                     return;
26                 }
27                 for(const auto& column : x)
28                 {
29                     if(column\&.size() != N)
30                     {
31                         return;
32                     }
33                 }
34                 int i = 0;
35                 for(const auto& column : x)
36                 {
37                     for(int j = 0; j < N; j++)
38                     {
39                         data[i][j] = column[j];
40                     }
41                     i++;
42                 }
43             }
.fi

.SH "Member Function Documentation"
.PP 
.SS "template<\fBtypename\fP T , \fBint\fP M, \fBint\fP N> \fBvirtual\fP \fBmatrix\fP< T, M, N > * \fBscifir::matrix\fP< T, M, N >::clone () const\fC [inline]\fP, \fC [virtual]\fP"

.PP
Definition at line \fB45\fP of file \fBmatrix\&.hpp\fP\&..PP
.nf
46             {
47                 return new matrix<T, M, N>(static_cast<const matrix<T, M, N>&>(*this));
48             }
.fi

.SS "template<\fBtypename\fP T , \fBint\fP M, \fBint\fP N> \fBmatrix\fP< T, M, 1 > \fBscifir::matrix\fP< T, M, N >::column (\fBint\fP j) const\fC [inline]\fP"

.PP
Definition at line \fB74\fP of file \fBmatrix\&.hpp\fP\&..PP
.nf
75             {
76                 if (outside_column_limits(j))
77                 {
78                     return matrix<T,M,1>();
79                 }
80                 matrix<T,M,1> x = matrix<T,M,1>();
81                 for (int i = 0; i < M; i++)
82                 {
83                     x(i + 1,1) = data[i][j \- 1];
84                 }
85                 return std::move(x);
86             }
.fi

.SS "template<\fBtypename\fP T , \fBint\fP M, \fBint\fP N> \fBint\fP \fBscifir::matrix\fP< T, M, N >::column_size () const\fC [inline]\fP"

.PP
Definition at line \fB55\fP of file \fBmatrix\&.hpp\fP\&..PP
.nf
56             {
57                 return N;
58             }
.fi

.SS "template<\fBtypename\fP T , \fBint\fP M, \fBint\fP N> \fBbool\fP \fBscifir::matrix\fP< T, M, N >::is_diagonal () const\fC [inline]\fP"

.PP
Definition at line \fB211\fP of file \fBmatrix\&.hpp\fP\&..PP
.nf
212             {
213                 for(int i = 0; i < M; i++)
214                 {
215                     for(int j = 0; j < N; j++)
216                     {
217                         if(i != j and data[i][j] != 0)
218                         {
219                             return false;
220                         }
221                     }
222                 }
223                 return true;
224             }
.fi

.SS "template<\fBtypename\fP T , \fBint\fP M, \fBint\fP N> \fBbool\fP \fBscifir::matrix\fP< T, M, N >::is_square () const\fC [inline]\fP"

.PP
Definition at line \fB199\fP of file \fBmatrix\&.hpp\fP\&..PP
.nf
200             {
201                 if(M == N)
202                 {
203                     return true;
204                 }
205                 else
206                 {
207                     return false;
208                 }
209             }
.fi

.SS "template<\fBtypename\fP T , \fBint\fP M, \fBint\fP N> T & \fBscifir::matrix\fP< T, M, N >::operator() (\fBint\fP i, \fBint\fP j)\fC [inline]\fP"

.PP
Definition at line \fB97\fP of file \fBmatrix\&.hpp\fP\&..PP
.nf
98             {
99                 if (outside_limits(i,j))
100                 {
101                     return T();
102                 }
103                 return data[i \- 1][j \- 1];
104             }
.fi

.SS "template<\fBtypename\fP T , \fBint\fP M, \fBint\fP N> \fBconst\fP T & \fBscifir::matrix\fP< T, M, N >::operator() (\fBint\fP i, \fBint\fP j) const\fC [inline]\fP"

.PP
Definition at line \fB88\fP of file \fBmatrix\&.hpp\fP\&..PP
.nf
89             {
90                 if (outside_limits(i,j))
91                 {
92                     return T();
93                 }
94                 return data[i \- 1][j \- 1];
95             }
.fi

.SS "template<\fBtypename\fP T , \fBint\fP M, \fBint\fP N> template<\fBint\fP N2> \fBmatrix\fP< T, N, \fBN2\fP > \fBscifir::matrix\fP< T, M, N >::operator* (\fBconst\fP \fBmatrix\fP< T, N, \fBN2\fP > & x)\fC [inline]\fP"

.PP
Definition at line \fB121\fP of file \fBmatrix\&.hpp\fP\&..PP
.nf
122             {
123                 matrix<T, N, N2> new_matrix = matrix<T, N, N2>();
124                 for(int i = 0; i < M; i++)
125                 {
126                     for(int j = 0; j < N2; j++)
127                     {
128                         T a = 0;
129                         for(int k = 0; k < N; k++)
130                         {
131                             a += data[i][k] * x(k + 1,j + 1);
132                         }
133                         new_matrix(i + 1,j + 1) = a;
134                     }
135                 }
136                 return move(new_matrix);
137             }
.fi

.SS "template<\fBtypename\fP T , \fBint\fP M, \fBint\fP N> \fBmatrix\fP< T, M, N > \fBscifir::matrix\fP< T, M, N >::operator+ (\fBconst\fP \fBmatrix\fP< T, M, N > & x)\fC [inline]\fP"

.PP
Definition at line \fB106\fP of file \fBmatrix\&.hpp\fP\&..PP
.nf
107             {
108                 matrix<T, M, N> y = *clone();
109                 y += x;
110                 return std::move(y);
111             }
.fi

.SS "template<\fBtypename\fP T , \fBint\fP M, \fBint\fP N> \fBvoid\fP \fBscifir::matrix\fP< T, M, N >::operator+= (\fBconst\fP \fBmatrix\fP< T, M, N > & x)\fC [inline]\fP"

.PP
Definition at line \fB147\fP of file \fBmatrix\&.hpp\fP\&..PP
.nf
148             {
149                 for(int i = 0; i < M; i++)
150                 {
151                     for(int j = 0; j < N; j++)
152                     {
153                         data[i][j] += x(i + 1,j + 1);
154                     }
155                 }
156             }
.fi

.SS "template<\fBtypename\fP T , \fBint\fP M, \fBint\fP N> \fBmatrix\fP< T, M, N > \fBscifir::matrix\fP< T, M, N >::operator\- (\fBconst\fP \fBmatrix\fP< T, M, N > & x)\fC [inline]\fP"

.PP
Definition at line \fB113\fP of file \fBmatrix\&.hpp\fP\&..PP
.nf
114             {
115                 matrix<T, M, N> y = *clone();
116                 y \-= x;
117                 return std::move(y);
118             }
.fi

.SS "template<\fBtypename\fP T , \fBint\fP M, \fBint\fP N> \fBvoid\fP \fBscifir::matrix\fP< T, M, N >::operator\-= (\fBconst\fP \fBmatrix\fP< T, M, N > & x)\fC [inline]\fP"

.PP
Definition at line \fB158\fP of file \fBmatrix\&.hpp\fP\&..PP
.nf
159             {
160                 for(int i = 0; i < M; i++)
161                 {
162                     for(int j = 0; j < N; j++)
163                     {
164                         data[i][j] \-= x(i + 1,j + 1);
165                     }
166                 }
167             }
.fi

.SS "template<\fBtypename\fP T , \fBint\fP M, \fBint\fP N> template<\fBtypename\fP \fBU\fP , \fBtypename\fP  = typename enable_if<is_integer_number<T>::value>::type> \fBmatrix\fP< T, M, N > \fBscifir::matrix\fP< T, M, N >::operator^ (\fBU\fP x)\fC [inline]\fP"

.PP
Definition at line \fB140\fP of file \fBmatrix\&.hpp\fP\&..PP
.nf
141             {
142                 matrix<T, M, N> y = *clone();
143                 y ^= x;
144                 return move(y);
145             }
.fi

.SS "template<\fBtypename\fP T , \fBint\fP M, \fBint\fP N> template<\fBtypename\fP \fBU\fP , \fBtypename\fP  = typename enable_if<is_integer_number<T>::value>::type> \fBvoid\fP \fBscifir::matrix\fP< T, M, N >::operator^= (\fBU\fP x)\fC [inline]\fP"

.PP
Definition at line \fB170\fP of file \fBmatrix\&.hpp\fP\&..PP
.nf
171             {
172                 matrix<T,M,N> new_data = *clone();
173                 for(int i = 2; i <= x; i++)
174                 {
175                     new_data = (new_data * (*this));
176                 }
177                 for (int i = 0; i < M; i++)
178                 {
179                     for (int j = 0; j < N; j++)
180                     {
181                         data[i][j] = new_data(i + 1,j + 1);
182                     }
183                 }
184             }
.fi

.SS "template<\fBtypename\fP T , \fBint\fP M, \fBint\fP N> \fBbool\fP \fBscifir::matrix\fP< T, M, N >::outside_column_limits (\fBint\fP i) const\fC [inline]\fP, \fC [private]\fP"

.PP
Definition at line \fB238\fP of file \fBmatrix\&.hpp\fP\&..PP
.nf
239             {
240                 if (i < 1 or i > N)
241                 {
242                     return true;
243                 }
244                 return false;
245             }
.fi

.SS "template<\fBtypename\fP T , \fBint\fP M, \fBint\fP N> \fBbool\fP \fBscifir::matrix\fP< T, M, N >::outside_limits (\fBint\fP i, \fBint\fP j) const\fC [inline]\fP, \fC [private]\fP"

.PP
Definition at line \fB247\fP of file \fBmatrix\&.hpp\fP\&..PP
.nf
248             {
249                 if (outside_row_limits(i) or outside_column_limits(j))
250                 {
251                     return true;
252                 }
253                 return false;
254             }
.fi

.SS "template<\fBtypename\fP T , \fBint\fP M, \fBint\fP N> \fBbool\fP \fBscifir::matrix\fP< T, M, N >::outside_row_limits (\fBint\fP i) const\fC [inline]\fP, \fC [private]\fP"

.PP
Definition at line \fB229\fP of file \fBmatrix\&.hpp\fP\&..PP
.nf
230             {
231                 if (i < 1 or i > M)
232                 {
233                     return true;
234                 }
235                 return false;
236             }
.fi

.SS "template<\fBtypename\fP T , \fBint\fP M, \fBint\fP N> \fBmatrix\fP< T, 1, N > \fBscifir::matrix\fP< T, M, N >::row (\fBint\fP i) const\fC [inline]\fP"

.PP
Definition at line \fB60\fP of file \fBmatrix\&.hpp\fP\&..PP
.nf
61             {
62                 if (outside_row_limits(i))
63                 {
64                     return matrix<T,1,N>();
65                 }
66                 matrix<T,1,N> x = matrix<T,1,N>();
67                 for (int j = 0; j < N; j++)
68                 {
69                     x(1,j + 1) = data[i \- 1][j];
70                 }
71                 return std::move(x);
72             }
.fi

.SS "template<\fBtypename\fP T , \fBint\fP M, \fBint\fP N> \fBint\fP \fBscifir::matrix\fP< T, M, N >::row_size () const\fC [inline]\fP"

.PP
Definition at line \fB50\fP of file \fBmatrix\&.hpp\fP\&..PP
.nf
51             {
52                 return M;
53             }
.fi

.SS "template<\fBtypename\fP T , \fBint\fP M, \fBint\fP N> \fBmatrix\fP< T, N, M > \fBscifir::matrix\fP< T, M, N >::t () const\fC [inline]\fP"

.PP
Definition at line \fB186\fP of file \fBmatrix\&.hpp\fP\&..PP
.nf
187             {
188                 matrix<T, N, M> new_data = matrix<T, N, M>();
189                 for(int i = 0; i < M; i++)
190                 {
191                     for(int j = 0; j < N; j++)
192                     {
193                         new_data(j + 1,i + 1) = data[i][j];
194                     }
195                 }
196                 return move(new_data);
197             }
.fi

.SH "Member Data Documentation"
.PP 
.SS "template<\fBtypename\fP T , \fBint\fP M, \fBint\fP N> vector<vector<T> > \fBscifir::matrix\fP< T, M, N >::data\fC [private]\fP"

.PP
Definition at line \fB227\fP of file \fBmatrix\&.hpp\fP\&.

.SH "Author"
.PP 
Generated automatically by Doxygen for scifir-units from the source code\&.
