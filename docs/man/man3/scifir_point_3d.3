.TH "scifir::point_3d< T >" 3 "Sat Jul 13 2024" "Version 2.0.0" "scifir-units" \" -*- nroff -*-
.ad l
.nh
.SH NAME
scifir::point_3d< T >
.SH SYNOPSIS
.br
.PP
.PP
\fC#include <point_3d\&.hpp>\fP
.SS "Public Member Functions"

.in +1c
.ti -1c
.RI "\fBpoint_3d\fP ()"
.br
.ti -1c
.RI "\fBpoint_3d\fP (const \fBpoint_3d\fP< T > &x_point)"
.br
.ti -1c
.RI "\fBpoint_3d\fP (\fBpoint_3d\fP< T > &&x_point)"
.br
.ti -1c
.RI "\fBpoint_3d\fP (const T &new_x, const T &new_y, const T &new_z)"
.br
.ti -1c
.RI "\fBpoint_3d\fP (const T &new_p, const \fBangle\fP &new_theta, T new_z)"
.br
.ti -1c
.RI "\fBpoint_3d\fP (const T &new_r, const \fBangle\fP &new_theta, const \fBangle\fP &new_phi)"
.br
.ti -1c
.RI "\fBpoint_3d\fP (const \fBangle\fP &new_latitude, const \fBangle\fP &new_longitude, const T &new_altitude)"
.br
.ti -1c
.RI "\fBpoint_3d\fP (const \fBcoordinates_3d\fP< T > &x_coordinates)"
.br
.ti -1c
.RI "\fBpoint_3d\fP (\fBcoordinates_3d\fP< T > &&x_coordinates)"
.br
.ti -1c
.RI "\fBpoint_3d\fP (const string &init_point_3d)"
.br
.ti -1c
.RI "\fBpoint_3d\fP< T > & \fBoperator=\fP (const \fBpoint_3d\fP< T > &x_point)"
.br
.ti -1c
.RI "\fBpoint_3d\fP< T > & \fBoperator=\fP (\fBpoint_3d\fP< T > &&x_point)"
.br
.ti -1c
.RI "\fBpoint_3d\fP< T > & \fBoperator=\fP (const \fBcoordinates_3d\fP< T > &)"
.br
.ti -1c
.RI "\fBpoint_3d\fP< T > & \fBoperator=\fP (\fBcoordinates_3d\fP< T > &&)"
.br
.ti -1c
.RI "\fBpoint_3d\fP< T > & \fBoperator=\fP (const string &init_point_3d)"
.br
.ti -1c
.RI "T \fBget_p\fP () const"
.br
.ti -1c
.RI "\fBangle\fP \fBget_theta\fP () const"
.br
.ti -1c
.RI "T \fBget_r\fP () const"
.br
.ti -1c
.RI "\fBangle\fP \fBget_phi\fP () const"
.br
.ti -1c
.RI "\fBangle\fP \fBget_latitude\fP () const"
.br
.ti -1c
.RI "\fBangle\fP \fBget_longitude\fP () const"
.br
.ti -1c
.RI "T \fBget_altitude\fP () const"
.br
.ti -1c
.RI "void \fBset_position\fP (const T &new_x, const T &new_y, const T &new_z)"
.br
.ti -1c
.RI "void \fBset_position\fP (const T &new_p, const \fBangle\fP &new_theta, T new_z)"
.br
.ti -1c
.RI "void \fBset_position\fP (const T &new_r, const \fBangle\fP &new_theta, const \fBangle\fP &new_phi)"
.br
.ti -1c
.RI "void \fBset_position\fP (const \fBangle\fP &new_latitude, const \fBangle\fP &new_longitude, const T &new_altitude)"
.br
.ti -1c
.RI "void \fBrotate_in_x\fP (const \fBangle\fP &x_angle)"
.br
.ti -1c
.RI "void \fBrotate_in_y\fP (const \fBangle\fP &x_angle)"
.br
.ti -1c
.RI "void \fBrotate_in_z\fP (const \fBangle\fP &x_angle)"
.br
.ti -1c
.RI "void \fBmove\fP (const displacement_3d &x_displacement)"
.br
.ti -1c
.RI "void \fBmove\fP (const T &new_x, const T &new_y, const T &new_z)"
.br
.ti -1c
.RI "void \fBmove\fP (const T &new_p, const \fBangle\fP &new_theta, T new_z)"
.br
.ti -1c
.RI "void \fBmove\fP (const T &new_r, const \fBangle\fP &new_theta, const \fBangle\fP &new_phi)"
.br
.ti -1c
.RI "T \fBdistance_to_origin\fP () const"
.br
.ti -1c
.RI "string \fBdisplay_cartesian\fP () const"
.br
.ti -1c
.RI "string \fBdisplay_cylindrical\fP () const"
.br
.ti -1c
.RI "string \fBdisplay_spherical\fP () const"
.br
.ti -1c
.RI "string \fBdisplay_geographical\fP () const"
.br
.in -1c
.SS "Public Attributes"

.in +1c
.ti -1c
.RI "T \fBx\fP"
.br
.ti -1c
.RI "T \fBy\fP"
.br
.ti -1c
.RI "T \fBz\fP"
.br
.in -1c
.SS "Private Member Functions"

.in +1c
.ti -1c
.RI "void \fBinitialize_from_string\fP (string init_point_3d)"
.br
.in -1c
.SH "Detailed Description"
.PP 

.SS "template<typename T = length>
.br
class scifir::point_3d< T >"

.PP
Definition at line 19 of file point_3d\&.hpp\&.
.SH "Constructor & Destructor Documentation"
.PP 
.SS "template<typename T  = length> \fBscifir::point_3d\fP< T >::\fBpoint_3d\fP ()\fC [inline]\fP"

.PP
Definition at line 22 of file point_3d\&.hpp\&.
.PP
.nf
22                        : x(),y(),z()
23             {}
.fi
.SS "template<typename T  = length> \fBscifir::point_3d\fP< T >::\fBpoint_3d\fP (const \fBpoint_3d\fP< T > & x_point)\fC [inline]\fP"

.PP
Definition at line 25 of file point_3d\&.hpp\&.
.PP
.nf
25                                                  : x(x_point\&.x),y(x_point\&.y),z(x_point\&.z)
26             {}
.fi
.SS "template<typename T  = length> \fBscifir::point_3d\fP< T >::\fBpoint_3d\fP (\fBpoint_3d\fP< T > && x_point)\fC [inline]\fP"

.PP
Definition at line 28 of file point_3d\&.hpp\&.
.PP
.nf
28                                             : x(std::move(x_point\&.x)),y(std::move(x_point\&.y)),z(std::move(x_point\&.z))
29             {}
.fi
.SS "template<typename T  = length> \fBscifir::point_3d\fP< T >::\fBpoint_3d\fP (const T & new_x, const T & new_y, const T & new_z)\fC [inline]\fP, \fC [explicit]\fP"

.PP
Definition at line 31 of file point_3d\&.hpp\&.
.PP
.nf
31                                                                             : x(new_x),y(new_y),z(new_z)
32             {}
.fi
.SS "template<typename T  = length> \fBscifir::point_3d\fP< T >::\fBpoint_3d\fP (const T & new_p, const \fBangle\fP & new_theta, T new_z)\fC [inline]\fP, \fC [explicit]\fP"

.PP
Definition at line 34 of file point_3d\&.hpp\&.
.PP
.nf
35             {
36                 set_position(new_p,new_theta,new_z);
37             }
.fi
.SS "template<typename T  = length> \fBscifir::point_3d\fP< T >::\fBpoint_3d\fP (const T & new_r, const \fBangle\fP & new_theta, const \fBangle\fP & new_phi)\fC [inline]\fP, \fC [explicit]\fP"

.PP
Definition at line 39 of file point_3d\&.hpp\&.
.PP
.nf
40             {
41                 set_position(new_r,new_theta,new_phi);
42             }
.fi
.SS "template<typename T  = length> \fBscifir::point_3d\fP< T >::\fBpoint_3d\fP (const \fBangle\fP & new_latitude, const \fBangle\fP & new_longitude, const T & new_altitude)\fC [inline]\fP, \fC [explicit]\fP"

.PP
Definition at line 44 of file point_3d\&.hpp\&.
.PP
.nf
45             {
46                 set_position(new_latitude,new_longitude,new_altitude);
47             }
.fi
.SS "template<typename T > \fBscifir::point_3d\fP< T >::\fBpoint_3d\fP (const \fBcoordinates_3d\fP< T > & x_coordinates)\fC [explicit]\fP"

.PP
Definition at line 13 of file point_3d_impl\&.hpp\&.
.PP
.nf
13                                                                 : x(x_coordinates\&.x),y(x_coordinates\&.y),z(x_coordinates\&.z)
14     {}
.fi
.SS "template<typename T > \fBscifir::point_3d\fP< T >::\fBpoint_3d\fP (\fBcoordinates_3d\fP< T > && x_coordinates)\fC [explicit]\fP"

.PP
Definition at line 17 of file point_3d_impl\&.hpp\&.
.PP
.nf
17                                                            : x(std::move(x_coordinates\&.x)),y(std::move(x_coordinates\&.y)),z(std::move(x_coordinates\&.z))
18     {}
.fi
.SS "template<typename T  = length> \fBscifir::point_3d\fP< T >::\fBpoint_3d\fP (const string & init_point_3d)\fC [inline]\fP, \fC [explicit]\fP"

.PP
Definition at line 53 of file point_3d\&.hpp\&.
.PP
.nf
53                                                            : point_3d()
54             {
55                 initialize_from_string(init_point_3d);
56             }
.fi
.SH "Member Function Documentation"
.PP 
.SS "template<typename T  = length> string \fBscifir::point_3d\fP< T >::display_cartesian () const\fC [inline]\fP"

.PP
Definition at line 206 of file point_3d\&.hpp\&.
.PP
.nf
207             {
208                 ostringstream out;
209                 out << "(" << x << "," << y << "," << z << ")";
210                 return out\&.str();
211             }
.fi
.SS "template<typename T  = length> string \fBscifir::point_3d\fP< T >::display_cylindrical () const\fC [inline]\fP"

.PP
Definition at line 213 of file point_3d\&.hpp\&.
.PP
.nf
214             {
215                 ostringstream out;
216                 out << "(" << get_p() << "," << get_theta() << "," << z << ")";
217                 return out\&.str();
218             }
.fi
.SS "template<typename T  = length> string \fBscifir::point_3d\fP< T >::display_geographical () const\fC [inline]\fP"

.PP
Definition at line 227 of file point_3d\&.hpp\&.
.PP
.nf
228             {
229                 ostringstream out;
230                 out << "(" << get_latitude() << "," << get_longitude() << "," << get_altitude() << ")";
231                 return out\&.str();
232             }
.fi
.SS "template<typename T  = length> string \fBscifir::point_3d\fP< T >::display_spherical () const\fC [inline]\fP"

.PP
Definition at line 220 of file point_3d\&.hpp\&.
.PP
.nf
221             {
222                 ostringstream out;
223                 out << "(" << get_r() << "," << get_theta() << "," << get_phi() << ")";
224                 return out\&.str();
225             }
.fi
.SS "template<typename T  = length> T \fBscifir::point_3d\fP< T >::distance_to_origin () const\fC [inline]\fP"

.PP
Definition at line 201 of file point_3d\&.hpp\&.
.PP
.nf
202             {
203                 return scifir::sqrt(scifir::pow(x,2) + scifir::pow(y,2) + scifir::pow(z,2));
204             }
.fi
.SS "template<typename T  = length> T \fBscifir::point_3d\fP< T >::get_altitude () const\fC [inline]\fP"

.PP
Definition at line 114 of file point_3d\&.hpp\&.
.PP
.nf
115             {
116                 return T();
117             }
.fi
.SS "template<typename T  = length> \fBangle\fP \fBscifir::point_3d\fP< T >::get_latitude () const\fC [inline]\fP"

.PP
Definition at line 104 of file point_3d\&.hpp\&.
.PP
.nf
105             {
106                 return scifir::asin(float(z/T(6317,"km")));
107             }
.fi
.SS "template<typename T  = length> \fBangle\fP \fBscifir::point_3d\fP< T >::get_longitude () const\fC [inline]\fP"

.PP
Definition at line 109 of file point_3d\&.hpp\&.
.PP
.nf
110             {
111                 return scifir::atan(float(y/x));
112             }
.fi
.SS "template<typename T  = length> T \fBscifir::point_3d\fP< T >::get_p () const\fC [inline]\fP"

.PP
Definition at line 84 of file point_3d\&.hpp\&.
.PP
.nf
85             {
86                 return scifir::sqrt(scifir::pow(x,2) + scifir::pow(y,2));
87             }
.fi
.SS "template<typename T  = length> \fBangle\fP \fBscifir::point_3d\fP< T >::get_phi () const\fC [inline]\fP"

.PP
Definition at line 99 of file point_3d\&.hpp\&.
.PP
.nf
100             {
101                 return angle(scifir::acos_degree(float(z/scifir::sqrt(scifir::pow(x,2) + scifir::pow(y,2) + scifir::pow(z,2)))));
102             }
.fi
.SS "template<typename T  = length> T \fBscifir::point_3d\fP< T >::get_r () const\fC [inline]\fP"

.PP
Definition at line 94 of file point_3d\&.hpp\&.
.PP
.nf
95             {
96                 return scifir::sqrt(scifir::pow(x,2) + scifir::pow(y,2) + scifir::pow(z,2));
97             }
.fi
.SS "template<typename T  = length> \fBangle\fP \fBscifir::point_3d\fP< T >::get_theta () const\fC [inline]\fP"

.PP
Definition at line 89 of file point_3d\&.hpp\&.
.PP
.nf
90             {
91                 return scifir::atan(float(y/x));
92             }
.fi
.SS "template<typename T  = length> void \fBscifir::point_3d\fP< T >::initialize_from_string (string init_point_3d)\fC [inline]\fP, \fC [private]\fP"

.PP
Definition at line 239 of file point_3d\&.hpp\&.
.PP
.nf
240             {
241                 vector<string> values;
242                 if (init_point_3d\&.front() == '(')
243                 {
244                     init_point_3d\&.erase(0,1);
245                 }
246                 if (init_point_3d\&.back() == ')')
247                 {
248                     init_point_3d\&.erase(init_point_3d\&.size()-1,1);
249                 }
250                 boost::split(values,init_point_3d,boost::is_any_of(","));
251                 if (values\&.size() == 3)
252                 {
253                     if (is_angle(values[0]))
254                     {
255                         if (is_angle(values[1]))
256                         {
257                             if (!is_angle(values[2]))
258                             {
259                                 set_position(angle(values[0]),angle(values[1]),T(values[2]));
260                             }
261                         }
262                     }
263                     else
264                     {
265                         if (is_angle(values[1]))
266                         {
267                             if (is_angle(values[2]))
268                             {
269                                 set_position(T(values[0]),angle(values[1]),angle(values[2]));
270                             }
271                             else
272                             {
273                                 set_position(T(values[0]),angle(values[1]),T(values[2]));
274                             }
275                         }
276                         else
277                         {
278                             if (!is_angle(values[2]))
279                             {
280                                 set_position(T(values[0]),T(values[1]),T(values[2]));
281                             }
282                         }
283                     }
284                 }
285             }
.fi
.SS "template<typename T  = length> void \fBscifir::point_3d\fP< T >::move (const displacement_3d & x_displacement)\fC [inline]\fP"

.PP
Definition at line 172 of file point_3d\&.hpp\&.
.PP
.nf
173             {
174                 x += x_displacement\&.x_projection();
175                 y += x_displacement\&.y_projection();
176                 z += x_displacement\&.z_projection();
177             }
.fi
.SS "template<typename T  = length> void \fBscifir::point_3d\fP< T >::move (const T & new_p, const \fBangle\fP & new_theta, T new_z)\fC [inline]\fP"

.PP
Definition at line 186 of file point_3d\&.hpp\&.
.PP
.nf
187             {
188                 new_z\&.change_dimensions(new_p);
189                 x += T(new_p * scifir::cos(new_theta));
190                 y += T(new_p * scifir::sin(new_theta));
191                 z += new_z;
192             }
.fi
.SS "template<typename T  = length> void \fBscifir::point_3d\fP< T >::move (const T & new_r, const \fBangle\fP & new_theta, const \fBangle\fP & new_phi)\fC [inline]\fP"

.PP
Definition at line 194 of file point_3d\&.hpp\&.
.PP
.nf
195             {
196                 x += T(new_r * scifir::cos(new_theta) * scifir::sin(new_phi));
197                 y += T(new_r * scifir::sin(new_theta) * scifir::sin(new_phi));
198                 z += T(new_r * scifir::cos(new_phi));
199             }
.fi
.SS "template<typename T  = length> void \fBscifir::point_3d\fP< T >::move (const T & new_x, const T & new_y, const T & new_z)\fC [inline]\fP"

.PP
Definition at line 179 of file point_3d\&.hpp\&.
.PP
.nf
180             {
181                 x += new_x;
182                 y += new_y;
183                 z += new_z;
184             }
.fi
.SS "template<typename T > \fBpoint_3d\fP< T > & \fBscifir::point_3d\fP< T >::operator= (const \fBcoordinates_3d\fP< T > & x_coordinates)"

.PP
Definition at line 21 of file point_3d_impl\&.hpp\&.
.PP
.nf
22     {
23         x = x_coordinates\&.x;
24         y = x_coordinates\&.y;
25         z = x_coordinates\&.z;
26         return *this;
27     }
.fi
.SS "template<typename T  = length> \fBpoint_3d\fP<T>& \fBscifir::point_3d\fP< T >::operator= (const \fBpoint_3d\fP< T > & x_point)\fC [inline]\fP"

.PP
Definition at line 58 of file point_3d\&.hpp\&.
.PP
.nf
59             {
60                 x = x_point\&.x;
61                 y = x_point\&.y;
62                 z = x_point\&.z;
63                 return *this;
64             }
.fi
.SS "template<typename T  = length> \fBpoint_3d\fP<T>& \fBscifir::point_3d\fP< T >::operator= (const string & init_point_3d)\fC [inline]\fP"

.PP
Definition at line 78 of file point_3d\&.hpp\&.
.PP
.nf
79             {
80                 initialize_from_string(init_point_3d);
81                 return *this;
82             }
.fi
.SS "template<typename T > \fBpoint_3d\fP< T > & \fBscifir::point_3d\fP< T >::operator= (\fBcoordinates_3d\fP< T > && x_coordinates)"

.PP
Definition at line 30 of file point_3d_impl\&.hpp\&.
.PP
.nf
31     {
32         x = std::move(x_coordinates\&.x);
33         y = std::move(x_coordinates\&.y);
34         z = std::move(x_coordinates\&.z);
35         return *this;
36     }
.fi
.SS "template<typename T  = length> \fBpoint_3d\fP<T>& \fBscifir::point_3d\fP< T >::operator= (\fBpoint_3d\fP< T > && x_point)\fC [inline]\fP"

.PP
Definition at line 66 of file point_3d\&.hpp\&.
.PP
.nf
67             {
68                 x = std::move(x_point\&.x);
69                 y = std::move(x_point\&.y);
70                 z = std::move(x_point\&.z);
71                 return *this;
72             }
.fi
.SS "template<typename T  = length> void \fBscifir::point_3d\fP< T >::rotate_in_x (const \fBangle\fP & x_angle)\fC [inline]\fP"

.PP
Definition at line 148 of file point_3d\&.hpp\&.
.PP
.nf
149             {
150                 T y_coord = y;
151                 T z_coord = z;
152                 y = y_coord * scifir::cos(x_angle) - z_coord * scifir::sin(x_angle);
153                 z = y_coord * scifir::sin(x_angle) + z_coord * scifir::cos(x_angle);
154             }
.fi
.SS "template<typename T  = length> void \fBscifir::point_3d\fP< T >::rotate_in_y (const \fBangle\fP & x_angle)\fC [inline]\fP"

.PP
Definition at line 156 of file point_3d\&.hpp\&.
.PP
.nf
157             {
158                 T x_coord = x;
159                 T z_coord = z;
160                 x = x_coord * scifir::cos(x_angle) - z_coord * scifir::sin(x_angle);
161                 z = x_coord * scifir::sin(x_angle) + z_coord * scifir::cos(x_angle);
162             }
.fi
.SS "template<typename T  = length> void \fBscifir::point_3d\fP< T >::rotate_in_z (const \fBangle\fP & x_angle)\fC [inline]\fP"

.PP
Definition at line 164 of file point_3d\&.hpp\&.
.PP
.nf
165             {
166                 T x_coord = x;
167                 T y_coord = y;
168                 x = x_coord * scifir::cos(x_angle) - y_coord * scifir::sin(x_angle);
169                 y = x_coord * scifir::sin(x_angle) + y_coord * scifir::cos(x_angle);
170             }
.fi
.SS "template<typename T  = length> void \fBscifir::point_3d\fP< T >::set_position (const \fBangle\fP & new_latitude, const \fBangle\fP & new_longitude, const T & new_altitude)\fC [inline]\fP"

.PP
Definition at line 141 of file point_3d\&.hpp\&.
.PP
.nf
142             {
143                 x = T(new_altitude * scifir::cos(new_latitude) * scifir::cos(new_longitude));
144                 y = T(new_altitude * scifir::cos(new_latitude) * scifir::sin(new_longitude));
145                 z = T(new_altitude * scifir::sin(new_latitude));
146             }
.fi
.SS "template<typename T  = length> void \fBscifir::point_3d\fP< T >::set_position (const T & new_p, const \fBangle\fP & new_theta, T new_z)\fC [inline]\fP"

.PP
Definition at line 126 of file point_3d\&.hpp\&.
.PP
.nf
127             {
128                 new_z\&.change_dimensions(new_p);
129                 x = T(new_p * scifir::cos(new_theta));
130                 y = T(new_p * scifir::sin(new_theta));
131                 z = new_z;
132             }
.fi
.SS "template<typename T  = length> void \fBscifir::point_3d\fP< T >::set_position (const T & new_r, const \fBangle\fP & new_theta, const \fBangle\fP & new_phi)\fC [inline]\fP"

.PP
Definition at line 134 of file point_3d\&.hpp\&.
.PP
.nf
135             {
136                 x = T(new_r * scifir::cos(new_theta) * scifir::sin(new_phi));
137                 y = T(new_r * scifir::sin(new_theta) * scifir::sin(new_phi));
138                 z = T(new_r * scifir::cos(new_phi));
139             }
.fi
.SS "template<typename T  = length> void \fBscifir::point_3d\fP< T >::set_position (const T & new_x, const T & new_y, const T & new_z)\fC [inline]\fP"

.PP
Definition at line 119 of file point_3d\&.hpp\&.
.PP
.nf
120             {
121                 x = new_x;
122                 y = new_y;
123                 z = new_z;
124             }
.fi
.SH "Member Data Documentation"
.PP 
.SS "template<typename T  = length> T \fBscifir::point_3d\fP< T >::x"

.PP
Definition at line 234 of file point_3d\&.hpp\&.
.SS "template<typename T  = length> T \fBscifir::point_3d\fP< T >::y"

.PP
Definition at line 235 of file point_3d\&.hpp\&.
.SS "template<typename T  = length> T \fBscifir::point_3d\fP< T >::z"

.PP
Definition at line 236 of file point_3d\&.hpp\&.

.SH "Author"
.PP 
Generated automatically by Doxygen for scifir-units from the source code\&.
