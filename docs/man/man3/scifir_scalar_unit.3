.TH "scifir::scalar_unit" 3 "Sat Jul 13 2024" "Version 2.0.0" "scifir-units" \" -*- nroff -*-
.ad l
.nh
.SH NAME
scifir::scalar_unit \- Class that allows to create scalar units, which are cmoposed of a value (as a float) and dimensions\&. The dimensions can be of any number, and be basic dimensions and/or abbreviations of dimensions\&.  

.SH SYNOPSIS
.br
.PP
.PP
\fC#include <scalar_unit\&.hpp>\fP
.PP
Inherited by \fBscifir::vector_unit_2d\fP, \fBscifir::vector_unit_3d\fP, and \fBscifir::vector_unit_nd\fP\&.
.SS "Public Member Functions"

.in +1c
.ti -1c
.RI "\fBscalar_unit\fP ()"
.br
.RI "Default constructor, the value is 0 and the dimensions are empty\&. "
.ti -1c
.RI "\fBscalar_unit\fP (const \fBscalar_unit\fP &x)"
.br
.RI "Copy constructor, copies the value and the dimensions\&. "
.ti -1c
.RI "\fBscalar_unit\fP (\fBscalar_unit\fP &&x)"
.br
.RI "Move constructor, moves the value and the dimensions\&. "
.ti -1c
.RI "\fBscalar_unit\fP (float new_value, const string &init_dimensions)"
.br
.RI "Creates a new \fBscalar_unit\fP with the value and with the dimensions specified in the string\&. "
.ti -1c
.RI "\fBscalar_unit\fP (double new_value, const string &init_dimensions)"
.br
.RI "Creates a new \fBscalar_unit\fP, the double is casted to a float\&. "
.ti -1c
.RI "\fBscalar_unit\fP (long double new_value, const string &init_dimensions)"
.br
.RI "Creates a new \fBscalar_unit\fP, the long double is casted to a float\&. "
.ti -1c
.RI "\fBscalar_unit\fP (int new_value, const string &init_dimensions)"
.br
.RI "Creates a new \fBscalar_unit\fP, the int is casted to a float\&. "
.ti -1c
.RI "\fBscalar_unit\fP (float new_value, const vector< \fBdimension\fP > &new_dimensions)"
.br
.RI "Creates a new \fBscalar_unit\fP with the value given and copying the dimensions\&. "
.ti -1c
.RI "\fBscalar_unit\fP (double new_value, const vector< \fBdimension\fP > &new_dimensions)"
.br
.RI "Creates a new \fBscalar_unit\fP, the double is casted to a float, the dimensions are copied\&. "
.ti -1c
.RI "\fBscalar_unit\fP (long double new_value, const vector< \fBdimension\fP > &new_dimensions)"
.br
.RI "Creates a new \fBscalar_unit\fP, the long double is casted to a float, the dimensions are copied\&. "
.ti -1c
.RI "\fBscalar_unit\fP (int new_value, const vector< \fBdimension\fP > &new_dimensions)"
.br
.RI "Creates a new \fBscalar_unit\fP, the int is casted to a float, the dimensions are copied\&. "
.ti -1c
.RI "\fBscalar_unit\fP (const string &init_scalar)"
.br
.RI "Creates a new \fBscalar_unit\fP, the initialization string specifies both the value and the dimensions\&. "
.ti -1c
.RI "\fBscalar_unit\fP & \fBoperator=\fP (const \fBscalar_unit\fP &x)"
.br
.RI "Copy assignment, it assigns a copy of the \fBscalar_unit\fP\&. "
.ti -1c
.RI "\fBscalar_unit\fP & \fBoperator=\fP (\fBscalar_unit\fP &&x)"
.br
.RI "Move assignment, it moves the \fBscalar_unit\fP\&. "
.ti -1c
.RI "\fBscalar_unit\fP & \fBoperator=\fP (const string &init_scalar)"
.br
.RI "Assignment with an initialization string, the value and the dimensions are both specified\&. "
.ti -1c
.RI "\fBoperator float\fP () const"
.br
.RI "Cast the \fBscalar_unit\fP to their float equivalent, it discards the dimensions and copies the value to a float\&. "
.ti -1c
.RI "bool \fBoperator==\fP (\fBscalar_unit\fP x) const"
.br
.RI "Comparison operator, two \fBscalar_unit\fP classes are considered equivalent if they have the same value given the same dimensions\&. "
.ti -1c
.RI "\fBscalar_unit\fP \fBoperator+\fP (\fBscalar_unit\fP x) const"
.br
.RI "Addition operator, it sums two \fBscalar_unit\fP classes, their dimensions are changed to be equal first\&. If the basic dimensions are different, it returns an empty \fBscalar_unit\fP class\&. "
.ti -1c
.RI "\fBscalar_unit\fP \fBoperator\-\fP (\fBscalar_unit\fP x) const"
.br
.RI "Substraction operator, it substracts one \fBscalar_unit\fP from the other, their dimensions are changed to be equal first\&. If the basic dimensions are different, it returns an empty \fBscalar_unit\fP class\&. "
.ti -1c
.RI "\fBscalar_unit\fP \fBoperator*\fP (\fBscalar_unit\fP x) const"
.br
.RI "Multiplication operator, it multiplies two \fBscalar_unit\fP classes, their dimensions are also multiplied\&. "
.ti -1c
.RI "\fBscalar_unit\fP \fBoperator/\fP (\fBscalar_unit\fP x) const"
.br
.RI "Division operator, it divides one \fBscalar_unit\fP class with the other, their dimensions are also divided\&. "
.ti -1c
.RI "\fBscalar_unit\fP \fBoperator^\fP (const \fBscalar_unit\fP &x) const"
.br
.RI "Power operator, it powers a \fBscalar_unit\fP class with another, if that second \fBscalar_unit\fP class, which is the exponent, as empty dimensions\&. If the exponent doesn't has empty dimensions it returns an empty \fBscalar_unit\fP class\&. "
.ti -1c
.RI "void \fBoperator+=\fP (\fBscalar_unit\fP x)"
.br
.RI "Addition operator, it adds a \fBscalar_unit\fP class to another, by converting their dimensions to be equal first\&. If their basic dimensions are different, it doesn't sums to the value\&. "
.ti -1c
.RI "void \fBoperator\-=\fP (\fBscalar_unit\fP x)"
.br
.RI "Substraction operator, it substracts a \fBscalar_unit\fP class to another, by converting their dimensions to be equal first\&. If their basic dimensions are different, it doesn't substracts to the value\&. "
.ti -1c
.RI "template<typename T , typename  = typename enable_if<scifir::is_number<T>::value>::type> \fBscalar_unit\fP \fBoperator+\fP (T y) const"
.br
.RI "Addition operator, it sums the numeric type to the value, independent of the dimensions\&. "
.ti -1c
.RI "template<typename T , typename  = typename enable_if<scifir::is_number<T>::value>::type> \fBscalar_unit\fP \fBoperator\-\fP (T y) const"
.br
.RI "Substraction operator, it substracts the numeric type to the value, independent of the dimensions\&. "
.ti -1c
.RI "template<typename T , typename  = typename enable_if<scifir::is_number<T>::value>::type> \fBscalar_unit\fP \fBoperator*\fP (T y) const"
.br
.RI "Multiplication operator, it multiplies the numeric type with the value, independent of the dimensions\&. "
.ti -1c
.RI "template<typename T , typename  = typename enable_if<scifir::is_number<T>::value>::type> \fBscalar_unit\fP \fBoperator/\fP (T y) const"
.br
.RI "Division operator, it divides the value with the numeric type, independent of the dimensions\&. "
.ti -1c
.RI "template<typename T , typename  = typename enable_if<is_integer_number<T>::value>::type> \fBscalar_unit\fP \fBoperator^\fP (T y) const"
.br
.RI "Power operator, it powers the value with the numeric type, independent of the dimensions\&. "
.ti -1c
.RI "template<typename T , typename  = typename enable_if<scifir::is_number<T>::value>::type> void \fBoperator+=\fP (T y)"
.br
.RI "Addition operator, it adds the numeric type to the value, independent of the dimensions\&. "
.ti -1c
.RI "template<typename T , typename  = typename enable_if<scifir::is_number<T>::value>::type> void \fBoperator\-=\fP (T y)"
.br
.RI "Substraction operator, it substracts the numeric type to the value, independent of the dimensions\&. "
.ti -1c
.RI "template<typename T , typename  = typename enable_if<scifir::is_number<T>::value>::type> void \fBoperator*=\fP (T y)"
.br
.RI "Multiplication operator, it multiplies the numeric type to the value, independent of the dimensions\&. "
.ti -1c
.RI "template<typename T , typename  = typename enable_if<scifir::is_number<T>::value>::type> void \fBoperator/=\fP (T y)"
.br
.RI "Division operator, it divides the numeric type to the value, independent of the dimensions\&. "
.ti -1c
.RI "\fBscalar_unit\fP & \fBoperator++\fP ()"
.br
.RI "Increment operator, it increases the value by one\&. "
.ti -1c
.RI "\fBscalar_unit\fP & \fBoperator++\fP (int)"
.br
.RI "Increment operator, it increases the value by one\&. "
.ti -1c
.RI "\fBscalar_unit\fP & \fBoperator\-\-\fP ()"
.br
.RI "Decrement operator, it decreases the value by one\&. "
.ti -1c
.RI "\fBscalar_unit\fP & \fBoperator\-\-\fP (int)"
.br
.RI "Decrement operator, it decreases the value by one\&. "
.ti -1c
.RI "void \fBchange_dimensions\fP (const string &init_dimensions)"
.br
.RI "Changes the dimensions to the dimensions specified by the initialization string of dimensions\&. "
.ti -1c
.RI "void \fBchange_dimensions\fP (const \fBscalar_unit\fP &x)"
.br
.RI "Changes the dimensions to the same dimensions of the \fBscalar_unit\fP\&. "
.ti -1c
.RI "bool \fBhas_dimensions\fP (const string &init_dimensions) const"
.br
.RI "Checks if the basic dimensions are the same as the initialization string of dimensions\&. "
.ti -1c
.RI "bool \fBhas_dimensions\fP (const vector< \fBdimension\fP > &x_dimensions) const"
.br
.RI "Checks if the basic dimensions are the same as some set of dimensions\&. "
.ti -1c
.RI "bool \fBhas_dimensions\fP (const \fBscalar_unit\fP &x) const"
.br
.RI "Checks if the basic dimensions are the same as other \fBscalar_unit\fP\&. "
.ti -1c
.RI "bool \fBhas_empty_dimensions\fP () const"
.br
.RI "Checks if there aren't basic dimensions\&. "
.ti -1c
.RI "string \fBdisplay_dimensions\fP () const"
.br
.RI "Generates an string of the dimensions of the \fBscalar_unit\fP, with the same format as the initialization string of dimensions\&. "
.ti -1c
.RI "vector< \fBdimension\fP > \fBget_derived_dimensions\fP () const"
.br
.RI "Generates a set of the derived dimensions of the dimensions of the \fBscalar_unit\fP\&. "
.ti -1c
.RI "const vector< \fBdimension\fP > & \fBget_dimensions\fP () const"
.br
.RI "Read-only getter of the dimensions\&. "
.ti -1c
.RI "const float & \fBget_value\fP () const"
.br
.RI "Read-only getter of the value\&. "
.ti -1c
.RI "string \fBdisplay\fP (int number_of_decimals=2, bool with_brackets=false, bool use_close_prefix=false) const"
.br
.RI "Generates an string representation of the \fBscalar_unit\fP, with the value and the dimensions\&. The dimensions can be enclosed by brackets, and the value can be set to have the closest prefix\&. "
.ti -1c
.RI "string \fBderived_display\fP (int number_of_decimals=2, bool with_brackets=false, bool use_close_prefix=false) const"
.br
.RI "Generates an string representation of the \fBscalar_unit\fP, with all dimensions converted to their derived counterpart\&. "
.ti -1c
.RI "string \fBcustom_display\fP (const string &init_dimensions, int number_of_decimals=2, bool with_brackets=false) const"
.br
.RI "Generates an string representation of the \fBscalar_unit\fP, with the dimensions changed to any set of dimensions, specified by an initialization string of dimensions\&. "
.in -1c
.SS "Protected Member Functions"

.in +1c
.ti -1c
.RI "void \fBadd_dimension\fP (const \fBdimension\fP &new_dimension)"
.br
.RI "\fBInternal function\fP\&. It adds a dimension, changing the value according to the conversion factor of the added dimension and the prefix\&. "
.ti -1c
.RI "void \fBremove_dimension\fP (const \fBdimension\fP &old_dimension)"
.br
.RI "\fBInternal function\fP\&. It removes a dimension, changing the value according to the conversion factor of the removed dimension and the prefix\&. "
.ti -1c
.RI "void \fBinitialize_from_string\fP (string init_scalar)"
.br
.RI "\fBInternal function\fP\&. It sets the value and the dimensions of the \fBscalar_unit\fP to the value and dimensions specified by the initialization string of \fBscalar_unit\fP\&. "
.in -1c
.SS "Protected Attributes"

.in +1c
.ti -1c
.RI "vector< \fBdimension\fP > \fBdimensions\fP"
.br
.RI "Dimensions of the \fBscalar_unit\fP\&. They can be basic dimensions or abbreviations\&. "
.ti -1c
.RI "float \fBvalue\fP"
.br
.RI "Value of the \fBscalar_unit\fP\&. It changes automatically when the dimensions change\&. "
.in -1c
.SH "Detailed Description"
.PP 
Class that allows to create scalar units, which are cmoposed of a value (as a float) and dimensions\&. The dimensions can be of any number, and be basic dimensions and/or abbreviations of dimensions\&. 

\fBscalar_unit\fP is a class that allows to have a scalar unit, which is composed of a value and one or more dimensions\&. All dimensions of the SI system of units are supported, and also all of its abbreviations\&. The abbreviations can be converted to its derived dimensions, too\&. \fBscalar_unit\fP classes have operators with all numeric types, and have operators with themselves\&. They can be displayed by its dimensions, its derived dimensions, or any custom combination of dimensions\&. When they change dimensions, like, for example, from meters to kilometers, their numeric value is changed accordingly\&. POSSIBLE FEATURES At the present \fBscalar_unit\fP classes use a vector<dimension> to allow to have any number of dimensions, which can be basic or abbreviations\&. In order to size less, it's possible for some \fBscalar_unit\fP classes to have only one dimension, instead of a vector, that saves memory\&. With that approach, the dimension needs only 3 bytes\&. The possibility to switch between a single dimension and a vector<dimension> doesn't yet exists in C++, and so this important feature has been postposed\&. 
.PP
Definition at line 78 of file scalar_unit\&.hpp\&.
.SH "Constructor & Destructor Documentation"
.PP 
.SS "scalar_unit::scalar_unit ()"

.PP
Default constructor, the value is 0 and the dimensions are empty\&. 
.PP
Definition at line 23 of file scalar_unit\&.cpp\&.
.PP
.nf
23                              : dimensions(),value(0\&.0f)
24     {}
.fi
.SS "scalar_unit::scalar_unit (const \fBscalar_unit\fP & x)"

.PP
Copy constructor, copies the value and the dimensions\&. 
.PP
\fBParameters\fP
.RS 4
\fIx\fP \fBscalar_unit\fP to be copied\&. 
.RE
.PP

.PP
Definition at line 26 of file scalar_unit\&.cpp\&.
.PP
.nf
26                                                  : dimensions(x\&.get_dimensions()),value(x\&.get_value())
27     {}
.fi
.SS "scalar_unit::scalar_unit (\fBscalar_unit\fP && x)"

.PP
Move constructor, moves the value and the dimensions\&. 
.PP
\fBParameters\fP
.RS 4
\fIx\fP \fBscalar_unit\fP to be moved\&. 
.RE
.PP

.PP
Definition at line 29 of file scalar_unit\&.cpp\&.
.PP
.nf
29                                             : dimensions(std::move(x\&.get_dimensions())),value(std::move(x\&.get_value()))
30     {}
.fi
.SS "scalar_unit::scalar_unit (float new_value, const string & init_dimensions)\fC [explicit]\fP"

.PP
Creates a new \fBscalar_unit\fP with the value and with the dimensions specified in the string\&. 
.PP
Definition at line 32 of file scalar_unit\&.cpp\&.
.PP
.nf
32                                                                            : dimensions(create_dimensions(init_dimensions)),value(new_value)
33     {}
.fi
.SS "scalar_unit::scalar_unit (double new_value, const string & init_dimensions)\fC [explicit]\fP"

.PP
Creates a new \fBscalar_unit\fP, the double is casted to a float\&. 
.PP
Definition at line 35 of file scalar_unit\&.cpp\&.
.PP
.nf
35                                                                             : dimensions(create_dimensions(init_dimensions)),value(float(new_value))
36     {}
.fi
.SS "scalar_unit::scalar_unit (long double new_value, const string & init_dimensions)\fC [explicit]\fP"

.PP
Creates a new \fBscalar_unit\fP, the long double is casted to a float\&. 
.PP
Definition at line 38 of file scalar_unit\&.cpp\&.
.PP
.nf
38                                                                                  : dimensions(create_dimensions(init_dimensions)),value(float(new_value))
39     {}
.fi
.SS "scalar_unit::scalar_unit (int new_value, const string & init_dimensions)\fC [explicit]\fP"

.PP
Creates a new \fBscalar_unit\fP, the int is casted to a float\&. 
.PP
Definition at line 41 of file scalar_unit\&.cpp\&.
.PP
.nf
41                                                                          : dimensions(create_dimensions(init_dimensions)),value(float(new_value))
42     {}
.fi
.SS "scalar_unit::scalar_unit (float new_value, const vector< \fBdimension\fP > & new_dimensions)\fC [explicit]\fP"

.PP
Creates a new \fBscalar_unit\fP with the value given and copying the dimensions\&. 
.PP
Definition at line 44 of file scalar_unit\&.cpp\&.
.PP
.nf
44                                                                                      : dimensions(new_dimensions),value(new_value)
45     {}
.fi
.SS "scalar_unit::scalar_unit (double new_value, const vector< \fBdimension\fP > & new_dimensions)\fC [explicit]\fP"

.PP
Creates a new \fBscalar_unit\fP, the double is casted to a float, the dimensions are copied\&. 
.PP
Definition at line 47 of file scalar_unit\&.cpp\&.
.PP
.nf
47                                                                                       : dimensions(new_dimensions),value(float(new_value))
48     {}
.fi
.SS "scalar_unit::scalar_unit (long double new_value, const vector< \fBdimension\fP > & new_dimensions)\fC [explicit]\fP"

.PP
Creates a new \fBscalar_unit\fP, the long double is casted to a float, the dimensions are copied\&. 
.PP
Definition at line 50 of file scalar_unit\&.cpp\&.
.PP
.nf
50                                                                                            : dimensions(new_dimensions),value(float(new_value))
51     {}
.fi
.SS "scalar_unit::scalar_unit (int new_value, const vector< \fBdimension\fP > & new_dimensions)\fC [explicit]\fP"

.PP
Creates a new \fBscalar_unit\fP, the int is casted to a float, the dimensions are copied\&. 
.PP
Definition at line 53 of file scalar_unit\&.cpp\&.
.PP
.nf
53                                                                                    : dimensions(new_dimensions),value(float(new_value))
54     {}
.fi
.SS "scalar_unit::scalar_unit (const string & init_scalar)\fC [explicit]\fP"

.PP
Creates a new \fBscalar_unit\fP, the initialization string specifies both the value and the dimensions\&. 
.PP
Definition at line 56 of file scalar_unit\&.cpp\&.
.PP
.nf
56                                                       : scalar_unit()
57     {
58         //static_assert(is_valid_scalar_unit("asdf"),"invalid initialization string");
59         initialize_from_string(init_scalar);
60     }
.fi
.SH "Member Function Documentation"
.PP 
.SS "void scalar_unit::add_dimension (const \fBdimension\fP & new_dimension)\fC [protected]\fP"

.PP
\fBInternal function\fP\&. It adds a dimension, changing the value according to the conversion factor of the added dimension and the prefix\&. 
.PP
Definition at line 474 of file scalar_unit\&.cpp\&.
.PP
.nf
475     {
476         if (new_dimension\&.dimension_position == dimension::NUMERATOR)
477         {
478             value /= float(new_dimension\&.get_conversion_factor());
479             value /= float(new_dimension\&.prefix_math());
480         }
481         else if (new_dimension\&.dimension_position == dimension::DENOMINATOR)
482         {
483             value *= float(new_dimension\&.get_conversion_factor());
484             value *= float(new_dimension\&.prefix_math());
485         }
486     }
.fi
.SS "void scalar_unit::change_dimensions (const \fBscalar_unit\fP & x)"

.PP
Changes the dimensions to the same dimensions of the \fBscalar_unit\fP\&. 
.PP
Definition at line 265 of file scalar_unit\&.cpp\&.
.PP
.nf
266     {
267         if(has_dimensions(x\&.get_dimensions()))
268         {
269             if (equal_dimensions_and_prefixes(dimensions,x\&.get_dimensions()))
270             {
271                 return;
272             }
273             for(const dimension& actual_dimension : dimensions)
274             {
275                 remove_dimension(actual_dimension);
276                 if(actual_dimension\&.is_derived_dimension())
277                 {
278                     vector<dimension> derived_dimensions = actual_dimension\&.get_basic_dimensions();
279                     for(const dimension& derived_dimension : derived_dimensions)
280                     {
281                         remove_dimension(derived_dimension);
282                     }
283                 }
284             }
285             dimensions\&.clear();
286             for(const dimension& new_dimension : x\&.get_dimensions())
287             {
288                 add_dimension(new_dimension);
289                 if(new_dimension\&.is_derived_dimension())
290                 {
291                     vector<dimension> new_derived_dimensions = new_dimension\&.get_basic_dimensions();
292                     for(const dimension& new_derived_dimension : new_derived_dimensions)
293                     {
294                         add_dimension(new_derived_dimension);
295                     }
296                 }
297             }
298             dimensions = x\&.get_dimensions();
299         }
300         else
301         {
302             cerr << "Cannot change to different base dimensions" << endl;
303         }
304     }
.fi
.SS "void scalar_unit::change_dimensions (const string & init_dimensions)"

.PP
Changes the dimensions to the dimensions specified by the initialization string of dimensions\&. 
.PP
Definition at line 223 of file scalar_unit\&.cpp\&.
.PP
.nf
224     {
225         vector<dimension> new_dimensions = create_dimensions(init_dimensions);
226         if(has_dimensions(new_dimensions))
227         {
228             if (equal_dimensions_and_prefixes(dimensions,new_dimensions))
229             {
230                 return;
231             }
232             for(const dimension& actual_dimension : dimensions)
233             {
234                 remove_dimension(actual_dimension);
235                 if(actual_dimension\&.is_derived_dimension())
236                 {
237                     vector<dimension> derived_dimensions = actual_dimension\&.get_basic_dimensions();
238                     for(const dimension& derived_dimension : derived_dimensions)
239                     {
240                         remove_dimension(derived_dimension);
241                     }
242                 }
243             }
244             dimensions\&.clear();
245             for(const dimension& new_dimension : new_dimensions)
246             {
247                 add_dimension(new_dimension);
248                 if(new_dimension\&.is_derived_dimension())
249                 {
250                     vector<dimension> new_derived_dimensions = new_dimension\&.get_basic_dimensions();
251                     for(const dimension& new_derived_dimension : new_derived_dimensions)
252                     {
253                         add_dimension(new_derived_dimension);
254                     }
255                 }
256             }
257             dimensions = new_dimensions;
258         }
259         else
260         {
261             cerr << "Cannot change to different base dimensions" << endl;
262         }
263     }
.fi
.SS "string scalar_unit::custom_display (const string & init_dimensions, int number_of_decimals = \fC2\fP, bool with_brackets = \fCfalse\fP) const"

.PP
Generates an string representation of the \fBscalar_unit\fP, with the dimensions changed to any set of dimensions, specified by an initialization string of dimensions\&. 
.PP
Definition at line 401 of file scalar_unit\&.cpp\&.
.PP
.nf
402     {
403         ostringstream output;
404         long double new_value = get_value();
405         if (init_dimensions != "sci")
406         {
407             vector<dimension> new_dimensions = create_dimensions(init_dimensions);
408             for(const dimension& x_dimension : dimensions)
409             {
410                 if (x_dimension\&.dimension_position == dimension::NUMERATOR)
411                 {
412                     new_value *= x_dimension\&.get_conversion_factor();
413                     new_value *= x_dimension\&.prefix_math();
414                 }
415                 else if (x_dimension\&.dimension_position == dimension::DENOMINATOR)
416                 {
417                     new_value /= x_dimension\&.get_conversion_factor();
418                     new_value /= x_dimension\&.prefix_math();
419                 }
420             }
421             vector<dimension> derived_dimensions = create_derived_dimensions(dimensions);
422             for(const dimension& x_dimension : derived_dimensions)
423             {
424                 if (x_dimension\&.dimension_position == dimension::NUMERATOR)
425                 {
426                     new_value *= x_dimension\&.prefix_math();
427                 }
428                 else if (x_dimension\&.dimension_position == dimension::DENOMINATOR)
429                 {
430                     new_value /= x_dimension\&.prefix_math();
431                 }
432             }
433             for(const dimension& x_new_dimension : new_dimensions)
434             {
435                 if (x_new_dimension\&.dimension_position == dimension::NUMERATOR)
436                 {
437                     new_value /= x_new_dimension\&.get_conversion_factor();
438                     new_value /= x_new_dimension\&.prefix_math();
439                 }
440                 else if (x_new_dimension\&.dimension_position == dimension::DENOMINATOR)
441                 {
442                     new_value *= x_new_dimension\&.get_conversion_factor();
443                     new_value *= x_new_dimension\&.prefix_math();
444                 }
445             }
446             output << display_float(float(new_value),number_of_decimals) << " ";
447             if (with_brackets)
448             {
449                 output << "[";
450             }
451             output << init_dimensions;
452             if (with_brackets)
453             {
454                 output << "]";
455             }
456         }
457         else
458         {
459             for (const dimension& x_dimension : dimensions)
460             {
461                 new_value *= x_dimension\&.prefix_math();
462             }
463             vector<dimension> new_dimensions = dimensions;
464             for (dimension& x_new_dimension : new_dimensions)
465             {
466                 x_new_dimension\&.prefix\&.prefix_type = prefix::NONE;
467             }
468             int value_scale = int(log10(get_value()));
469             output << display_float(float(new_value / std::pow(10,value_scale)),number_of_decimals) << "e" << value_scale << " " << to_string(new_dimensions,with_brackets);
470         }
471         return output\&.str();
472     }
.fi
.SS "string scalar_unit::derived_display (int number_of_decimals = \fC2\fP, bool with_brackets = \fCfalse\fP, bool use_close_prefix = \fCfalse\fP) const"

.PP
Generates an string representation of the \fBscalar_unit\fP, with all dimensions converted to their derived counterpart\&. 
.PP
Definition at line 379 of file scalar_unit\&.cpp\&.
.PP
.nf
380     {
381         ostringstream output;
382         long double x_value = get_value();
383         vector<dimension> derived_dimensions = create_derived_dimensions(dimensions,x_value);
384         if (derived_dimensions\&.size() == 1 and use_close_prefix == true)
385         {
386             int value_scale = int(log10(get_value()));
387             prefix display_prefix = closest_prefix(derived_dimensions[0]\&.prefix,value_scale);
388             x_value *= derived_dimensions[0]\&.prefix_math();
389             x_value /= derived_dimensions[0]\&.prefix_math(display_prefix);
390             vector<dimension> x_dimensions = derived_dimensions;
391             x_dimensions[0]\&.prefix = display_prefix;
392             output << display_float(float(x_value),number_of_decimals) << " " << to_string(derived_dimensions,with_brackets);
393         }
394         else
395         {
396             output << display_float(float(x_value),number_of_decimals) << " " << to_string(derived_dimensions,with_brackets);
397         }
398         return output\&.str();
399     }
.fi
.SS "string scalar_unit::display (int number_of_decimals = \fC2\fP, bool with_brackets = \fCfalse\fP, bool use_close_prefix = \fCfalse\fP) const"

.PP
Generates an string representation of the \fBscalar_unit\fP, with the value and the dimensions\&. The dimensions can be enclosed by brackets, and the value can be set to have the closest prefix\&. 
.PP
Definition at line 350 of file scalar_unit\&.cpp\&.
.PP
.nf
351     {
352         ostringstream output;
353         if (dimensions\&.size() == 1 and use_close_prefix == true)
354         {
355             prefix display_prefix;
356             if (get_value() != 0)
357             {
358                 int value_scale = int(log10(get_value()));
359                 display_prefix = closest_prefix(dimensions[0]\&.prefix,value_scale);
360             }
361             else
362             {
363                 display_prefix = dimensions[0]\&.prefix;
364             }
365             long double x_value = get_value();
366             x_value *= dimensions[0]\&.prefix_math();
367             x_value /= dimensions[0]\&.prefix_math(display_prefix);
368             vector<dimension> x_dimensions = dimensions;
369             x_dimensions[0]\&.prefix = display_prefix;
370             output << display_float(float(x_value),number_of_decimals) << " " << to_string(x_dimensions,with_brackets);
371         }
372         else
373         {
374             output << display_float(get_value(),number_of_decimals) << " " << to_string(dimensions,with_brackets);
375         }
376         return output\&.str();
377     }
.fi
.SS "string scalar_unit::display_dimensions () const"

.PP
Generates an string of the dimensions of the \fBscalar_unit\fP, with the same format as the initialization string of dimensions\&. 
.PP
Definition at line 335 of file scalar_unit\&.cpp\&.
.PP
.nf
336     {
337         return to_string(dimensions);
338     }
.fi
.SS "vector< \fBdimension\fP > scalar_unit::get_derived_dimensions () const"

.PP
Generates a set of the derived dimensions of the dimensions of the \fBscalar_unit\fP\&. 
.PP
Definition at line 345 of file scalar_unit\&.cpp\&.
.PP
.nf
346     {
347         return create_derived_dimensions(dimensions);
348     }
.fi
.SS "const vector< \fBdimension\fP > & scalar_unit::get_dimensions () const\fC [inline]\fP"

.PP
Read-only getter of the dimensions\&. 
.PP
Definition at line 188 of file scalar_unit\&.hpp\&.
.PP
.nf
189             {
190                 return dimensions;
191             }
.fi
.SS "const float & scalar_unit::get_value () const\fC [inline]\fP"

.PP
Read-only getter of the value\&. 
.PP
Definition at line 193 of file scalar_unit\&.hpp\&.
.PP
.nf
194             {
195                 return value;
196             }
.fi
.SS "bool scalar_unit::has_dimensions (const \fBscalar_unit\fP & x) const"

.PP
Checks if the basic dimensions are the same as other \fBscalar_unit\fP\&. 
.PP
Definition at line 317 of file scalar_unit\&.cpp\&.
.PP
.nf
318     {
319         return equal_dimensions(dimensions,x\&.get_dimensions());
320     }
.fi
.SS "bool scalar_unit::has_dimensions (const string & init_dimensions) const"

.PP
Checks if the basic dimensions are the same as the initialization string of dimensions\&. 
.PP
Definition at line 306 of file scalar_unit\&.cpp\&.
.PP
.nf
307     {
308         vector<dimension> structure_dimensions = create_dimensions(init_dimensions);
309         return has_dimensions(structure_dimensions);
310     }
.fi
.SS "bool scalar_unit::has_dimensions (const vector< \fBdimension\fP > & x_dimensions) const"

.PP
Checks if the basic dimensions are the same as some set of dimensions\&. 
.PP
Definition at line 312 of file scalar_unit\&.cpp\&.
.PP
.nf
313     {
314         return equal_dimensions(dimensions,x_dimensions);
315     }
.fi
.SS "bool scalar_unit::has_empty_dimensions () const"

.PP
Checks if there aren't basic dimensions\&. 
.PP
Definition at line 322 of file scalar_unit\&.cpp\&.
.PP
.nf
323     {
324         vector<dimension> derived_dimensions = create_derived_dimensions(dimensions);
325         if(derived_dimensions\&.size() == 0)
326         {
327             return true;
328         }
329         else
330         {
331             return false;
332         }
333     }
.fi
.SS "void scalar_unit::initialize_from_string (string init_scalar)\fC [protected]\fP"

.PP
\fBInternal function\fP\&. It sets the value and the dimensions of the \fBscalar_unit\fP to the value and dimensions specified by the initialization string of \fBscalar_unit\fP\&. 
.PP
Definition at line 502 of file scalar_unit\&.cpp\&.
.PP
.nf
503     {
504         if(!isdigit(init_scalar[0]))
505         {
506             return;
507         }
508         else
509         {
510             int i = 0;
511             while(isdigit(init_scalar[i]) || init_scalar[i] == '\&.' || init_scalar[i] == ' ' || init_scalar[i] == '*' || init_scalar[i] == '^' || init_scalar[i] == 'e' || init_scalar[i] == 'E')
512             {
513                 if (init_scalar[i] == ' ')
514                 {
515                     break;
516                 }
517                 i++;
518             }
519             string string_value = init_scalar\&.substr(0, i);
520             boost::algorithm::erase_all(string_value, " ");
521             size_t search_e = string_value\&.find("E");
522             if (search_e != string::npos)
523             {
524                 string_value\&.replace(search_e,1,"e");
525             }
526             size_t search_10 = string_value\&.find("*10^");
527             if (search_10 != string::npos)
528             {
529                 string_value\&.replace(search_10,4,"e");
530             }
531             stringstream ss(string_value);
532             ss >> value;
533             dimensions = create_dimensions(init_scalar\&.substr(i));
534         }
535     }
.fi
.SS "scalar_unit::operator float () const\fC [explicit]\fP"

.PP
Cast the \fBscalar_unit\fP to their float equivalent, it discards the dimensions and copies the value to a float\&. 
.PP
Definition at line 96 of file scalar_unit\&.cpp\&.
.PP
.nf
97     {
98         return value;
99     }
.fi
.SS "\fBscalar_unit\fP scalar_unit::operator* (\fBscalar_unit\fP x) const"

.PP
Multiplication operator, it multiplies two \fBscalar_unit\fP classes, their dimensions are also multiplied\&. 
.PP
Definition at line 146 of file scalar_unit\&.cpp\&.
.PP
.nf
147     {
148         long double new_value = value;
149         new_value *= x\&.get_value();
150         vector<dimension> new_dimensions = multiply_dimensions(get_dimensions(),x\&.get_dimensions(),new_value);
151         return scalar_unit(new_value, new_dimensions);
152     }
.fi
.SS "template<typename T , typename  = typename enable_if<scifir::is_number<T>::value>::type> \fBscalar_unit\fP scalar_unit::operator* (T y) const\fC [inline]\fP"

.PP
Multiplication operator, it multiplies the numeric type with the value, independent of the dimensions\&. 
.PP
Definition at line 127 of file scalar_unit\&.hpp\&.
.PP
.nf
128             {
129                 scalar_unit x = *this;
130                 x *= y;
131                 return x;
132             }
.fi
.SS "template<typename T , typename  = typename enable_if<scifir::is_number<T>::value>::type> void scalar_unit::operator*= (T y)\fC [inline]\fP"

.PP
Multiplication operator, it multiplies the numeric type to the value, independent of the dimensions\&. 
.PP
Definition at line 161 of file scalar_unit\&.hpp\&.
.PP
.nf
162             {
163                 value *= y;
164             }
.fi
.SS "\fBscalar_unit\fP scalar_unit::operator+ (\fBscalar_unit\fP x) const"

.PP
Addition operator, it sums two \fBscalar_unit\fP classes, their dimensions are changed to be equal first\&. If the basic dimensions are different, it returns an empty \fBscalar_unit\fP class\&. 
.PP
Definition at line 114 of file scalar_unit\&.cpp\&.
.PP
.nf
115     {
116         if(has_dimensions(x))
117         {
118             x\&.change_dimensions(*this);
119             scalar_unit a = *this;
120             a += x\&.get_value();
121             return a;
122         }
123         else
124         {
125             cerr << "Cannot sum different dimensions" << endl;
126             return scalar_unit();
127         }
128     }
.fi
.SS "template<typename T , typename  = typename enable_if<scifir::is_number<T>::value>::type> \fBscalar_unit\fP scalar_unit::operator+ (T y) const\fC [inline]\fP"

.PP
Addition operator, it sums the numeric type to the value, independent of the dimensions\&. 
.PP
Definition at line 111 of file scalar_unit\&.hpp\&.
.PP
.nf
112             {
113                 scalar_unit x = *this;
114                 x += y;
115                 return x;
116             }
.fi
.SS "\fBscalar_unit\fP & scalar_unit::operator++ ()"

.PP
Increment operator, it increases the value by one\&. 
.PP
Definition at line 197 of file scalar_unit\&.cpp\&.
.PP
.nf
198     {
199         value++;
200         return *this;
201     }
.fi
.SS "\fBscalar_unit\fP & scalar_unit::operator++ (int)"

.PP
Increment operator, it increases the value by one\&. 
.PP
Definition at line 203 of file scalar_unit\&.cpp\&.
.PP
.nf
204     {
205         scalar_unit& tmp(*this);
206         operator++();
207         return tmp;
208     }
.fi
.SS "void scalar_unit::operator+= (\fBscalar_unit\fP x)"

.PP
Addition operator, it adds a \fBscalar_unit\fP class to another, by converting their dimensions to be equal first\&. If their basic dimensions are different, it doesn't sums to the value\&. 
.PP
Definition at line 175 of file scalar_unit\&.cpp\&.
.PP
.nf
176     {
177         if(!has_dimensions(x))
178         {
179             cerr << "Cannot sum different dimensions" << endl;
180             return;
181         }
182         x\&.change_dimensions(*this);
183         value += x\&.get_value();
184     }
.fi
.SS "template<typename T , typename  = typename enable_if<scifir::is_number<T>::value>::type> void scalar_unit::operator+= (T y)\fC [inline]\fP"

.PP
Addition operator, it adds the numeric type to the value, independent of the dimensions\&. 
.PP
Definition at line 149 of file scalar_unit\&.hpp\&.
.PP
.nf
150             {
151                 value += y;
152             }
.fi
.SS "\fBscalar_unit\fP scalar_unit::operator\- (\fBscalar_unit\fP x) const"

.PP
Substraction operator, it substracts one \fBscalar_unit\fP from the other, their dimensions are changed to be equal first\&. If the basic dimensions are different, it returns an empty \fBscalar_unit\fP class\&. 
.PP
Definition at line 130 of file scalar_unit\&.cpp\&.
.PP
.nf
131     {
132         if(has_dimensions(x))
133         {
134             x\&.change_dimensions(*this);
135             scalar_unit a = *this;
136             a -= x\&.get_value();
137             return a;
138         }
139         else
140         {
141             cerr << "Cannot substract different dimensions" << endl;
142             return scalar_unit();
143         }
144     }
.fi
.SS "template<typename T , typename  = typename enable_if<scifir::is_number<T>::value>::type> \fBscalar_unit\fP scalar_unit::operator\- (T y) const\fC [inline]\fP"

.PP
Substraction operator, it substracts the numeric type to the value, independent of the dimensions\&. 
.PP
Definition at line 119 of file scalar_unit\&.hpp\&.
.PP
.nf
120             {
121                 scalar_unit x = *this;
122                 x -= y;
123                 return x;
124             }
.fi
.SS "\fBscalar_unit\fP & scalar_unit::operator\-\- ()"

.PP
Decrement operator, it decreases the value by one\&. 
.PP
Definition at line 210 of file scalar_unit\&.cpp\&.
.PP
.nf
211     {
212         value--;
213         return *this;
214     }
.fi
.SS "\fBscalar_unit\fP & scalar_unit::operator\-\- (int)"

.PP
Decrement operator, it decreases the value by one\&. 
.PP
Definition at line 216 of file scalar_unit\&.cpp\&.
.PP
.nf
217     {
218         scalar_unit& tmp(*this);
219         operator\-\-();
220         return tmp;
221     }
.fi
.SS "void scalar_unit::operator\-= (\fBscalar_unit\fP x)"

.PP
Substraction operator, it substracts a \fBscalar_unit\fP class to another, by converting their dimensions to be equal first\&. If their basic dimensions are different, it doesn't substracts to the value\&. 
.PP
Definition at line 186 of file scalar_unit\&.cpp\&.
.PP
.nf
187     {
188         if(!has_dimensions(x))
189         {
190             cerr << "Cannot substract different dimensions" << endl;
191             return;
192         }
193         x\&.change_dimensions(*this);
194         value -= x\&.get_value();
195     }
.fi
.SS "template<typename T , typename  = typename enable_if<scifir::is_number<T>::value>::type> void scalar_unit::operator\-= (T y)\fC [inline]\fP"

.PP
Substraction operator, it substracts the numeric type to the value, independent of the dimensions\&. 
.PP
Definition at line 155 of file scalar_unit\&.hpp\&.
.PP
.nf
156             {
157                 value -= y;
158             }
.fi
.SS "\fBscalar_unit\fP scalar_unit::operator/ (\fBscalar_unit\fP x) const"

.PP
Division operator, it divides one \fBscalar_unit\fP class with the other, their dimensions are also divided\&. 
.PP
Definition at line 154 of file scalar_unit\&.cpp\&.
.PP
.nf
155     {
156         long double new_value = value;
157         new_value /= x\&.get_value();
158         vector<dimension> new_dimensions = divide_dimensions(get_dimensions(),x\&.get_dimensions(),new_value);
159         return scalar_unit(new_value, new_dimensions);
160     }
.fi
.SS "template<typename T , typename  = typename enable_if<scifir::is_number<T>::value>::type> \fBscalar_unit\fP scalar_unit::operator/ (T y) const\fC [inline]\fP"

.PP
Division operator, it divides the value with the numeric type, independent of the dimensions\&. 
.PP
Definition at line 135 of file scalar_unit\&.hpp\&.
.PP
.nf
136             {
137                 scalar_unit x = *this;
138                 x /= y;
139                 return x;
140             }
.fi
.SS "template<typename T , typename  = typename enable_if<scifir::is_number<T>::value>::type> void scalar_unit::operator/= (T y)\fC [inline]\fP"

.PP
Division operator, it divides the numeric type to the value, independent of the dimensions\&. 
.PP
Definition at line 167 of file scalar_unit\&.hpp\&.
.PP
.nf
168             {
169                 value /= y;
170             }
.fi
.SS "\fBscalar_unit\fP & scalar_unit::operator= (const \fBscalar_unit\fP & x)"

.PP
Copy assignment, it assigns a copy of the \fBscalar_unit\fP\&. 
.PP
Definition at line 62 of file scalar_unit\&.cpp\&.
.PP
.nf
63     {
64         if (has_dimensions(x))
65         {
66             dimensions = x\&.get_dimensions();
67             value = x\&.get_value();
68         }
69         else
70         {
71             cerr << "Cannot initialize to different dimensions" << endl;
72         }
73         return *this;
74     }
.fi
.SS "\fBscalar_unit\fP & scalar_unit::operator= (const string & init_scalar)"

.PP
Assignment with an initialization string, the value and the dimensions are both specified\&. 
.PP
Definition at line 90 of file scalar_unit\&.cpp\&.
.PP
.nf
91     {
92         initialize_from_string(init_scalar);
93         return *this;
94     }
.fi
.SS "\fBscalar_unit\fP & scalar_unit::operator= (\fBscalar_unit\fP && x)"

.PP
Move assignment, it moves the \fBscalar_unit\fP\&. 
.PP
Definition at line 76 of file scalar_unit\&.cpp\&.
.PP
.nf
77     {
78         if (has_dimensions(x))
79         {
80             dimensions = std::move(x\&.get_dimensions());
81             value = std::move(x\&.get_value());
82         }
83         else
84         {
85             cerr << "Cannot initialize to different dimensions" << endl;
86         }
87         return *this;
88     }
.fi
.SS "bool scalar_unit::operator== (\fBscalar_unit\fP x) const"

.PP
Comparison operator, two \fBscalar_unit\fP classes are considered equivalent if they have the same value given the same dimensions\&. 
.PP
Definition at line 101 of file scalar_unit\&.cpp\&.
.PP
.nf
102     {
103         x\&.change_dimensions(*this);
104         if(get_value() == x\&.get_value() and has_dimensions(x))
105         {
106             return true;
107         }
108         else
109         {
110             return false;
111         }
112     }
.fi
.SS "\fBscalar_unit\fP scalar_unit::operator^ (const \fBscalar_unit\fP & x) const"

.PP
Power operator, it powers a \fBscalar_unit\fP class with another, if that second \fBscalar_unit\fP class, which is the exponent, as empty dimensions\&. If the exponent doesn't has empty dimensions it returns an empty \fBscalar_unit\fP class\&. 
.PP
Definition at line 162 of file scalar_unit\&.cpp\&.
.PP
.nf
163     {
164         if(x\&.has_empty_dimensions())
165         {
166             return scalar_unit(std::pow(value,x\&.get_value()),power_dimensions(get_dimensions(),int(x\&.get_value())));
167         }
168         else
169         {
170             cerr << "Exponent of dimensions doesn't exist" << endl;
171             return scalar_unit();
172         }
173     }
.fi
.SS "template<typename T , typename  = typename enable_if<is_integer_number<T>::value>::type> \fBscalar_unit\fP scalar_unit::operator^ (T y) const\fC [inline]\fP"

.PP
Power operator, it powers the value with the numeric type, independent of the dimensions\&. 
.PP
Definition at line 143 of file scalar_unit\&.hpp\&.
.PP
.nf
144             {
145                 return scalar_unit(std::pow(get_value(),y),power_dimensions(get_dimensions(),y));
146             }
.fi
.SS "void scalar_unit::remove_dimension (const \fBdimension\fP & old_dimension)\fC [protected]\fP"

.PP
\fBInternal function\fP\&. It removes a dimension, changing the value according to the conversion factor of the removed dimension and the prefix\&. 
.PP
Definition at line 488 of file scalar_unit\&.cpp\&.
.PP
.nf
489     {
490         if (old_dimension\&.dimension_position == dimension::NUMERATOR)
491         {
492             value *= float(old_dimension\&.get_conversion_factor());
493             value *= float(old_dimension\&.prefix_math());
494         }
495         else if (old_dimension\&.dimension_position == dimension::DENOMINATOR)
496         {
497             value /= float(old_dimension\&.get_conversion_factor());
498             value /= float(old_dimension\&.prefix_math());
499         }
500     }
.fi
.SH "Member Data Documentation"
.PP 
.SS "scalar_unit::dimensions\fC [protected]\fP"

.PP
Dimensions of the \fBscalar_unit\fP\&. They can be basic dimensions or abbreviations\&. 
.PP
Definition at line 203 of file scalar_unit\&.hpp\&.
.SS "scalar_unit::value\fC [protected]\fP"

.PP
Value of the \fBscalar_unit\fP\&. It changes automatically when the dimensions change\&. 
.PP
Definition at line 204 of file scalar_unit\&.hpp\&.

.SH "Author"
.PP 
Generated automatically by Doxygen for scifir-units from the source code\&.
