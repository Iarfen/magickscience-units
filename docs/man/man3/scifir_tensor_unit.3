.TH "scifir::tensor_unit< T >" 3 "Version 2.0.0" "scifir-units" \" -*- nroff -*-
.ad l
.nh
.SH NAME
scifir::tensor_unit< T >
.SH SYNOPSIS
.br
.PP
.PP
\fC#include <tensor_unit\&.hpp>\fP
.SS "Public Types"

.in +1c
.ti -1c
.RI "enum \fBtype\fP { \fBSCALAR\fP, \fBVECTOR\fP, \fBMATRIX\fP }"
.br
.in -1c
.SS "Public Member Functions"

.in +1c
.ti -1c
.RI "\fBtensor_unit\fP ()"
.br
.ti -1c
.RI "\fBtensor_unit\fP (\fBconst\fP \fBtensor_unit\fP &x)"
.br
.ti -1c
.RI "\fBtensor_unit\fP (\fBtensor_unit\fP &&x)"
.br
.ti -1c
.RI "\fBtensor_unit\fP (\fBconst\fP vector< vector< T > > &x)"
.br
.ti -1c
.RI "\fBtensor_unit\fP (\fBconst\fP \fBscalar_unit\fP &x)"
.br
.ti -1c
.RI "\fBtensor_unit\fP (\fBconst\fP \fBvector_unit_2d\fP &x)"
.br
.ti -1c
.RI "\fBtensor_unit\fP (\fBconst\fP \fBvector_unit_3d\fP &x)"
.br
.ti -1c
.RI "\fBtensor_unit\fP (\fBconst\fP \fBvector_unit_nd\fP &x)"
.br
.ti -1c
.RI "\fBtensor_unit\fP & \fBoperator=\fP (\fBconst\fP \fBtensor_unit\fP &x)"
.br
.ti -1c
.RI "\fBtensor_unit\fP & \fBoperator=\fP (\fBtensor_unit\fP &&x)"
.br
.ti -1c
.RI "\fBint\fP \fBget_dimension\fP () \fBconst\fP"
.br
.ti -1c
.RI "\fBtensor_unit::type\fP \fBget_type\fP () \fBconst\fP"
.br
.ti -1c
.RI "\fBbool\fP \fBis_scalar\fP () \fBconst\fP"
.br
.ti -1c
.RI "\fBbool\fP \fBis_vector\fP () \fBconst\fP"
.br
.ti -1c
.RI "\fBbool\fP \fBis_matrix\fP () \fBconst\fP"
.br
.ti -1c
.RI "template<\fBtypename\fP \fBU\fP > \fBtensor_unit\fP< \fBscalar_unit\fP > \fBoperator+\fP (\fBconst\fP \fBtensor_unit\fP< \fBU\fP > &x) \fBconst\fP"
.br
.ti -1c
.RI "template<\fBtypename\fP \fBU\fP > \fBtensor_unit\fP< \fBscalar_unit\fP > \fBoperator\-\fP (\fBconst\fP \fBtensor_unit\fP< \fBU\fP > &x) \fBconst\fP"
.br
.in -1c
.SS "Public Attributes"

.in +1c
.ti -1c
.RI "vector< vector< T > > \fBvalues\fP"
.br
.in -1c
.SH "Detailed Description"
.PP 

.SS "template<\fBtypename\fP T>
.br
class scifir::tensor_unit< T >"
.PP
Definition at line \fB13\fP of file \fBtensor_unit\&.hpp\fP\&.
.SH "Member Enumeration Documentation"
.PP 
.SS "template<\fBtypename\fP T > \fBenum\fP \fBscifir::tensor_unit::type\fP"

.PP
\fBEnumerator\fP
.in +1c
.TP
\fB\fISCALAR \fP\fP
.TP
\fB\fIVECTOR \fP\fP
.TP
\fB\fIMATRIX \fP\fP
.PP
Definition at line \fB16\fP of file \fBtensor_unit\&.hpp\fP\&..PP
.nf
16 { SCALAR, VECTOR, MATRIX };
.fi

.SH "Constructor & Destructor Documentation"
.PP 
.SS "template<\fBtypename\fP T > \fBscifir::tensor_unit\fP< T >::tensor_unit ()\fC [inline]\fP"

.PP
Definition at line \fB18\fP of file \fBtensor_unit\&.hpp\fP\&..PP
.nf
18                           : values()
19             {}
.fi

.SS "template<\fBtypename\fP T > \fBscifir::tensor_unit\fP< T >::tensor_unit (\fBconst\fP \fBtensor_unit\fP< T > & x)\fC [inline]\fP"

.PP
Definition at line \fB21\fP of file \fBtensor_unit\&.hpp\fP\&..PP
.nf
21                                               : values(x\&.values)
22             {}
.fi

.SS "template<\fBtypename\fP T > \fBscifir::tensor_unit\fP< T >::tensor_unit (\fBtensor_unit\fP< T > && x)\fC [inline]\fP"

.PP
Definition at line \fB24\fP of file \fBtensor_unit\&.hpp\fP\&..PP
.nf
24                                          : values(std::move(x\&.values))
25             {}
.fi

.SS "template<\fBtypename\fP T > \fBscifir::tensor_unit\fP< T >::tensor_unit (\fBconst\fP vector< vector< T > > & x)\fC [inline]\fP, \fC [explicit]\fP"

.PP
Definition at line \fB27\fP of file \fBtensor_unit\&.hpp\fP\&..PP
.nf
27                                                              : values()
28             {}
.fi

.SS "template<\fBtypename\fP T > \fBscifir::tensor_unit\fP< T >::tensor_unit (\fBconst\fP \fBscalar_unit\fP & x)\fC [inline]\fP, \fC [explicit]\fP"

.PP
Definition at line \fB30\fP of file \fBtensor_unit\&.hpp\fP\&..PP
.nf
30                                                        : values()
31             {}
.fi

.SS "template<\fBtypename\fP T > \fBscifir::tensor_unit\fP< T >::tensor_unit (\fBconst\fP \fBvector_unit_2d\fP & x)\fC [inline]\fP, \fC [explicit]\fP"

.PP
Definition at line \fB33\fP of file \fBtensor_unit\&.hpp\fP\&..PP
.nf
33                                                           : values()
34             {}
.fi

.SS "template<\fBtypename\fP T > \fBscifir::tensor_unit\fP< T >::tensor_unit (\fBconst\fP \fBvector_unit_3d\fP & x)\fC [inline]\fP, \fC [explicit]\fP"

.PP
Definition at line \fB36\fP of file \fBtensor_unit\&.hpp\fP\&..PP
.nf
36                                                           : values()
37             {}
.fi

.SS "template<\fBtypename\fP T > \fBscifir::tensor_unit\fP< T >::tensor_unit (\fBconst\fP \fBvector_unit_nd\fP & x)\fC [inline]\fP, \fC [explicit]\fP"

.PP
Definition at line \fB39\fP of file \fBtensor_unit\&.hpp\fP\&..PP
.nf
39                                                           : values()
40             {}
.fi

.SH "Member Function Documentation"
.PP 
.SS "template<\fBtypename\fP T > \fBint\fP \fBscifir::tensor_unit\fP< T >::get_dimension () const\fC [inline]\fP"

.PP
Definition at line \fB54\fP of file \fBtensor_unit\&.hpp\fP\&..PP
.nf
55             {
56                 if (values\&.size() > 0)
57                 {
58                     if (values\&.size() == 1 and values[0]\&.size() == 1)
59                     {
60                         return 1;
61                     }
62                     else if (values\&.size() == 1 and values[0]\&.size() > 1)
63                     {
64                         return 2;
65                     }
66                     else
67                     {
68                         if (values[0]\&.size() == 1)
69                         {
70                             return 2;
71                         }
72                         else
73                         {
74                             return 3;
75                         }
76                     }
77                 }
78                 else
79                 {
80                     return \-1;
81                 }
82             }
.fi

.SS "template<\fBtypename\fP T > \fBtensor_unit::type\fP \fBscifir::tensor_unit\fP< T >::get_type () const\fC [inline]\fP"

.PP
Definition at line \fB84\fP of file \fBtensor_unit\&.hpp\fP\&..PP
.nf
85             {
86                 if (values\&.size() > 0)
87                 {
88                     if (values\&.size() == 1 and values[0]\&.size() == 1)
89                     {
90                         return tensor_unit::SCALAR;
91                     }
92                     else if (values\&.size() == 1 and values[0]\&.size() > 1)
93                     {
94                         return tensor_unit::VECTOR;
95                     }
96                     else
97                     {
98                         if (values[0]\&.size() == 1)
99                         {
100                             return tensor_unit::VECTOR;
101                         }
102                         else
103                         {
104                             return tensor_unit::MATRIX;
105                         }
106                     }
107                 }
108                 else
109                 {
110                     return \-1;
111                 }
112             }
.fi

.SS "template<\fBtypename\fP T > \fBbool\fP \fBscifir::tensor_unit\fP< T >::is_matrix () const\fC [inline]\fP"

.PP
Definition at line \fB138\fP of file \fBtensor_unit\&.hpp\fP\&..PP
.nf
139             {
140                 if (values\&.size() > 1 and values[0]\&.size() > 1)
141                 {
142                     return true;
143                 }
144                 else
145                 {
146                     return false;
147                 }
148             }
.fi

.SS "template<\fBtypename\fP T > \fBbool\fP \fBscifir::tensor_unit\fP< T >::is_scalar () const\fC [inline]\fP"

.PP
Definition at line \fB114\fP of file \fBtensor_unit\&.hpp\fP\&..PP
.nf
115             {
116                 if (values\&.size() == 1 and values[0]\&.size() == 1)
117                 {
118                     return true;
119                 }
120                 else
121                 {
122                     return false;
123                 }
124             }
.fi

.SS "template<\fBtypename\fP T > \fBbool\fP \fBscifir::tensor_unit\fP< T >::is_vector () const\fC [inline]\fP"

.PP
Definition at line \fB126\fP of file \fBtensor_unit\&.hpp\fP\&..PP
.nf
127             {
128                 if ((values\&.size() == 1 and values[0]\&.size() > 1) or (values\&.size() > 1 and values[0]\&.size() == 1))
129                 {
130                     return true;
131                 }
132                 else
133                 {
134                     return false;
135                 }
136             }
.fi

.SS "template<\fBtypename\fP T > template<\fBtypename\fP \fBU\fP > \fBtensor_unit\fP< \fBscalar_unit\fP > \fBscifir::tensor_unit\fP< T >::operator+ (\fBconst\fP \fBtensor_unit\fP< \fBU\fP > & x) const\fC [inline]\fP"

.PP
Definition at line \fB151\fP of file \fBtensor_unit\&.hpp\fP\&..PP
.nf
152             {
153                 tensor_unit::type this_type = get_type();
154                 tensor_unit::type x_type = x\&.get_type();
155                 if (this_type == tensor_unit::SCALAR and x_type == tensor_unit::SCALAR)
156                 {
157                     scalar_unit new_scalar = values[0][0] + x\&.values[0][0];
158                     return tensor_unit<scalar_unit>(new_scalar);
159                 }
160                 else if (this_type == tensor_unit::VECTOR and x_type == tensor_unit::VECTOR)
161                 {
162                     if (values\&.size() == x\&.values\&.size())
163                     {
164                         vector<vector<scalar_unit>> new_values();
165                         new_values\&.push_back(vector<scalar_unit>());
166                         for (int i = 0; i < values\&.size(); i++)
167                         {
168                             scalar_unit new_value = values[0][i] + x\&.values[0][i];
169                             new_values[0]\&.push_back(new_value);
170                         }
171                         return tensor_unit<scalar_unit>(new_values);
172                     }
173                     else
174                     {
175                         return tensor_unit<scalar_unit>();
176                     }
177                 }
178                 else if (this_type == tensor_unit::MATRIX and x_type == tensor_unit::MATRIX)
179                 {
180                     if (values\&.size() == x\&.values\&.size() and values[0]\&.size() == x\&.values[0]\&.size())
181                     {
182                         vector<vector<scalar_unit>> new_values();
183                         for (int i = 0; i < values\&.size(); i++)
184                         {
185                             new_values\&.push_back(vector<scalar_unit>());
186                             for (int j = 0; j < values[i]\&.size(); j++)
187                             {
188                                 scalar_unit new_value = values[i][j] + x\&.values[i][j];
189                                 new_values[i]\&.push_back(new_value);
190                             }
191                         }
192                         return tensor_unit<scalar_unit>(new_values);
193                     }
194                     else
195                     {
196                         return tensor_unit<scalar_unit>();
197                     }
198                 }
199                 else
200                 {
201                     return tensor_unit<scalar_unit>();
202                 }
203             }
.fi

.SS "template<\fBtypename\fP T > template<\fBtypename\fP \fBU\fP > \fBtensor_unit\fP< \fBscalar_unit\fP > \fBscifir::tensor_unit\fP< T >::operator\- (\fBconst\fP \fBtensor_unit\fP< \fBU\fP > & x) const\fC [inline]\fP"

.PP
Definition at line \fB206\fP of file \fBtensor_unit\&.hpp\fP\&..PP
.nf
207             {
208                 tensor_unit::type this_type = get_type();
209                 tensor_unit::type x_type = x\&.get_type();
210                 if (this_type == tensor_unit::SCALAR and x_type == tensor_unit::SCALAR)
211                 {
212                     scalar_unit new_scalar = values[0][0] \- x\&.values[0][0];
213                     return tensor_unit<scalar_unit>(new_scalar);
214                 }
215                 else if (this_type == tensor_unit::VECTOR and x_type == tensor_unit::VECTOR)
216                 {
217                     if (values\&.size() == x\&.values\&.size())
218                     {
219                         vector<vector<scalar_unit>> new_values();
220                         new_values\&.push_back(vector<scalar_unit>());
221                         for (int i = 0; i < values\&.size(); i++)
222                         {
223                             scalar_unit new_value = values[0][i] \- x\&.values[0][i];
224                             new_values[0]\&.push_back(new_value);
225                         }
226                         return tensor_unit<scalar_unit>(new_values);
227                     }
228                     else
229                     {
230                         return tensor_unit<scalar_unit>();
231                     }
232                 }
233                 else if (this_type == tensor_unit::MATRIX and x_type == tensor_unit::MATRIX)
234                 {
235                     if (values\&.size() == x\&.values\&.size() and values[0]\&.size() == x\&.values[0]\&.size())
236                     {
237                         vector<vector<scalar_unit>> new_values();
238                         for (int i = 0; i < values\&.size(); i++)
239                         {
240                             new_values\&.push_back(vector<scalar_unit>());
241                             for (int j = 0; j < values[i]\&.size(); j++)
242                             {
243                                 scalar_unit new_value = values[i][j] \- x\&.values[i][j];
244                                 new_values[i]\&.push_back(new_value);
245                             }
246                         }
247                         return tensor_unit<scalar_unit>(new_values);
248                     }
249                     else
250                     {
251                         return tensor_unit<scalar_unit>();
252                     }
253                 }
254                 else
255                 {
256                     return tensor_unit<scalar_unit>();
257                 }
258             }
.fi

.SS "template<\fBtypename\fP T > \fBtensor_unit\fP & \fBscifir::tensor_unit\fP< T >::operator= (\fBconst\fP \fBtensor_unit\fP< T > & x)\fC [inline]\fP"

.PP
Definition at line \fB42\fP of file \fBtensor_unit\&.hpp\fP\&..PP
.nf
43             {
44                 values = x\&.values;
45                 return *this;
46             }
.fi

.SS "template<\fBtypename\fP T > \fBtensor_unit\fP & \fBscifir::tensor_unit\fP< T >::operator= (\fBtensor_unit\fP< T > && x)\fC [inline]\fP"

.PP
Definition at line \fB48\fP of file \fBtensor_unit\&.hpp\fP\&..PP
.nf
49             {
50                 values = std::move(x\&.values);
51                 return *this;
52             }
.fi

.SH "Member Data Documentation"
.PP 
.SS "template<\fBtypename\fP T > vector<vector<T> > \fBscifir::tensor_unit\fP< T >::values"

.PP
Definition at line \fB260\fP of file \fBtensor_unit\&.hpp\fP\&.

.SH "Author"
.PP 
Generated automatically by Doxygen for scifir-units from the source code\&.
