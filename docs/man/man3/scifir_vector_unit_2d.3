.TH "scifir::vector_unit_2d" 3 "Sat Jul 13 2024" "Version 2.0.0" "scifir-units" \" -*- nroff -*-
.ad l
.nh
.SH NAME
scifir::vector_unit_2d \- Class that creates a vector unit in 2D\&. The vector is in \fBpolar coordinates\fP with a value and dimensions of the \fBscalar_unit\fP, and an angle theta for his direction\&.  

.SH SYNOPSIS
.br
.PP
.PP
\fC#include <vector_unit_2d\&.hpp>\fP
.PP
Inherits \fBscifir::scalar_unit\fP\&.
.SS "Public Member Functions"

.in +1c
.ti -1c
.RI "\fBvector_unit_2d\fP ()"
.br
.RI "Default constructor\&. The value is set to 0, the dimensions are empty and theta is 0\&. "
.ti -1c
.RI "\fBvector_unit_2d\fP (const \fBvector_unit_2d\fP &x)"
.br
.RI "Copy constructor\&. The member-variables are copied from the \fBvector_unit_2d\fP x\&. "
.ti -1c
.RI "\fBvector_unit_2d\fP (\fBvector_unit_2d\fP &&x)"
.br
.RI "Move constructor\&. The member-variables are moved from the \fBvector_unit_2d\fP x\&. "
.ti -1c
.RI "\fBvector_unit_2d\fP (float new_value, const string &init_dimensions, float new_theta)"
.br
.RI "The value is new_value, the dimensions are initialized with the initialization string of dimensions, and theta is new_theta\&. "
.ti -1c
.RI "\fBvector_unit_2d\fP (float new_value, const string &init_dimensions, const \fBangle\fP &new_theta)"
.br
.RI "The value is new_value, the dimensions are initialized with the initialization string of dimensions, and theta is new_theta\&. "
.ti -1c
.RI "\fBvector_unit_2d\fP (double new_value, const string &init_dimensions, float new_theta)"
.br
.RI "The value is new_value (the double is casted to a float), the dimensions are initialized with the initialization string of dimensions, and theta is new_theta\&. "
.ti -1c
.RI "\fBvector_unit_2d\fP (double new_value, const string &init_dimensions, const \fBangle\fP &new_theta)"
.br
.RI "The value is new_value (the double is casted to a float), the dimensions are initialized with the initialization string of dimensions, and theta is new_theta\&. "
.ti -1c
.RI "\fBvector_unit_2d\fP (long double new_value, const string &init_dimensions, float new_theta)"
.br
.RI "The value is new_value (the long double is casted to a float), the dimensions are initialized with the initialization string of dimensions, and theta is new_theta\&. "
.ti -1c
.RI "\fBvector_unit_2d\fP (long double new_value, const string &init_dimensions, const \fBangle\fP &new_theta)"
.br
.RI "The value is new_value (the long double is casted to a float), the dimensions are initialized with the initialization string of dimensions, and theta is new_theta\&. "
.ti -1c
.RI "\fBvector_unit_2d\fP (int new_value, const string &init_dimensions, float new_theta)"
.br
.RI "The value is new_value (the int is casted to a float), the dimensions are initialized with the initialization string of dimensions, and theta is new_theta\&. "
.ti -1c
.RI "\fBvector_unit_2d\fP (int new_value, const string &init_dimensions, const \fBangle\fP &new_theta)"
.br
.RI "The value is new_value (the int is casted to a float), the dimensions are initialized with the initialization string of dimensions, and theta is new_theta\&. "
.ti -1c
.RI "\fBvector_unit_2d\fP (float new_value, const vector< \fBdimension\fP > &new_dimensions, float new_theta)"
.br
.RI "The value is new_value, the dimensions are initialized with a vector of dimensions, and theta is new_theta\&. "
.ti -1c
.RI "\fBvector_unit_2d\fP (float new_value, const vector< \fBdimension\fP > &new_dimensions, const \fBangle\fP &new_theta)"
.br
.RI "The value is new_value, the dimensions are initialized with a vector of dimensions, and theta is new_theta\&. "
.ti -1c
.RI "\fBvector_unit_2d\fP (double new_value, const vector< \fBdimension\fP > &new_dimensions, float new_theta)"
.br
.RI "The value is new_value (the double is casted to a float), the dimensions are initialized with a vector of dimensions, and theta is new_theta\&. "
.ti -1c
.RI "\fBvector_unit_2d\fP (double new_value, const vector< \fBdimension\fP > &new_dimensions, const \fBangle\fP &new_theta)"
.br
.RI "The value is new_value (the double is casted to a float), the dimensions are initialized with a vector of dimensions, and theta is new_theta\&. "
.ti -1c
.RI "\fBvector_unit_2d\fP (long double new_value, const vector< \fBdimension\fP > &new_dimensions, float new_theta)"
.br
.RI "The value is new_value (the long double is casted to a float), the dimensions are initialized with a vector of dimensions, and theta is new_theta\&. "
.ti -1c
.RI "\fBvector_unit_2d\fP (long double new_value, const vector< \fBdimension\fP > &new_dimensions, const \fBangle\fP &new_theta)"
.br
.RI "The value is new_value (the long double is casted to a float), the dimensions are initialized with a vector of dimensions, and theta is new_theta\&. "
.ti -1c
.RI "\fBvector_unit_2d\fP (int new_value, const vector< \fBdimension\fP > &new_dimensions, float new_theta)"
.br
.RI "The value is new_value (the int is casted to a float), the dimensions are initialized with a vector of dimensions, and theta is new_theta\&. "
.ti -1c
.RI "\fBvector_unit_2d\fP (int new_value, const vector< \fBdimension\fP > &new_dimensions, const \fBangle\fP &new_theta)"
.br
.RI "The value is new_value (the int is casted to a float), the dimensions are initialized with a vector of dimensions, and theta is new_theta\&. "
.ti -1c
.RI "\fBvector_unit_2d\fP (const \fBscalar_unit\fP &x, float new_theta)"
.br
.RI "The value and the dimensions are copied from the \fBscalar_unit\fP x, theta is new_theta\&. "
.ti -1c
.RI "\fBvector_unit_2d\fP (const \fBscalar_unit\fP &x, const \fBangle\fP &new_theta)"
.br
.RI "The value and the dimensions are copied from the \fBscalar_unit\fP x, theta is new_theta\&. "
.ti -1c
.RI "\fBvector_unit_2d\fP (const string &init_scalar, float new_theta)"
.br
.RI "The value and the dimensions are copied from the initialization string of \fBscalar_unit\fP init_scalar, theta is new_theta\&. "
.ti -1c
.RI "\fBvector_unit_2d\fP (const string &init_scalar, const \fBangle\fP &new_theta)"
.br
.RI "The value and the dimensions are copied from the initialization string of \fBscalar_unit\fP init_scalar, theta is new_theta\&. "
.ti -1c
.RI "\fBvector_unit_2d\fP (const string &init_vector_2d)"
.br
.RI "The value, the dimensions and theta are initialized from the initialization string of \fBvector_unit_2d\fP init_vector_2d\&. "
.ti -1c
.RI "\fBvector_unit_2d\fP & \fBoperator=\fP (const \fBvector_unit_2d\fP &x)"
.br
.RI "Copy assignment\&. The member-variables are copied from the \fBvector_unit_2d\fP x\&. "
.ti -1c
.RI "\fBvector_unit_2d\fP & \fBoperator=\fP (\fBvector_unit_2d\fP &&x)"
.br
.RI "Move assignment\&. The member-variables are moved from the \fBvector_unit_2d\fP x\&. "
.ti -1c
.RI "\fBvector_unit_2d\fP & \fBoperator=\fP (const \fBscalar_unit\fP &x)"
.br
.RI "The value and the dimensions are copied from the \fBscalar_unit\fP x, theta is not changed\&. "
.ti -1c
.RI "\fBvector_unit_2d\fP & \fBoperator=\fP (\fBscalar_unit\fP &&x)"
.br
.RI "The value and the dimensions are moved from the \fBscalar_unit\fP x, theta is not changed\&. "
.ti -1c
.RI "\fBvector_unit_2d\fP & \fBoperator=\fP (const string &init_vector_2d)"
.br
.RI "The value, the dimensions and theta are set from the initialization string init_vector_2d\&. "
.ti -1c
.RI "bool \fBoperator==\fP (\fBvector_unit_2d\fP x) const"
.br
.RI "Comparison operator\&. Two \fBvector_unit_2d\fP are equal if their value, dimensions and theta are the same\&. "
.ti -1c
.RI "void \fBpoint_to\fP (\fBdirection::name\fP x)"
.br
.RI "Theta is set to the direction specified in 2D\&. Possible values are LEFT, RIGHT, TOP, BOTTOM, LEFT_TOP, RIGHT_TOP, RIGHT_BOTTOM, LEFT_BOTTOM\&. "
.ti -1c
.RI "void \fBoperator+=\fP (const \fBvector_unit_2d\fP &x)"
.br
.RI "The \fBvector_unit_2d\fP is summed as vector, in polar coordinates\&. The addition of vectors is used for the calculation\&. "
.ti -1c
.RI "void \fBoperator\-=\fP (\fBvector_unit_2d\fP x)"
.br
.RI "The \fBvector_unit_2d\fP is substracted as vector, in polar coordinates\&. The substraction of vectors is used for the calculation\&. "
.ti -1c
.RI "\fBvector_unit_2d\fP \fBoperator+\fP (const \fBvector_unit_2d\fP &x) const"
.br
.RI "Addition of vectors in 2D\&. It creates a new vector as the addition of the other two\&. "
.ti -1c
.RI "\fBvector_unit_2d\fP \fBoperator\-\fP (\fBvector_unit_2d\fP x) const"
.br
.RI "Substraction of vectors in 2D\&. It creates a new vector as the difference of the other two\&. "
.ti -1c
.RI "\fBvector_unit_2d\fP \fBoperator*\fP (const \fBscalar_unit\fP &x) const"
.br
.RI "It creates a new \fBvector_unit_2d\fP scaling a \fBvector_unit_2d\fP by the \fBscalar_unit\fP x\&. "
.ti -1c
.RI "\fBvector_unit_2d\fP \fBoperator/\fP (const \fBscalar_unit\fP &x) const"
.br
.RI "It creates a new \fBvector_unit_2d\fP scaling a \fBvector_unit_2d\fP by the inverse of the \fBscalar_unit\fP x\&. "
.ti -1c
.RI "\fBvector_unit_2d\fP \fBoperator^\fP (const \fBscalar_unit\fP &x) const"
.br
.RI "It powers a vector by a \fBscalar_unit\fP x if that \fBscalar_unit\fP has empty dimensions\&. "
.ti -1c
.RI "template<typename T , typename  = typename enable_if<scifir::is_number<T>::value>::type> \fBvector_unit_2d\fP \fBoperator+\fP (T x) const"
.br
.RI "It creates a new vector as the addition of the numeric type x to the value\&. Theta is not changed\&. "
.ti -1c
.RI "template<typename T , typename  = typename enable_if<scifir::is_number<T>::value>::type> \fBvector_unit_2d\fP \fBoperator\-\fP (T x) const"
.br
.RI "It creates a new vector as the substraction of the numeric type x to the value\&. Theta is not changed\&. "
.ti -1c
.RI "template<typename T , typename  = typename enable_if<scifir::is_number<T>::value>::type> \fBvector_unit_2d\fP \fBoperator*\fP (T x) const"
.br
.RI "It creates a new vector as the multiplication of the numeric type x to the value\&. Theta is not changed\&. "
.ti -1c
.RI "template<typename T , typename  = typename enable_if<scifir::is_number<T>::value>::type> \fBvector_unit_2d\fP \fBoperator/\fP (T x) const"
.br
.RI "It creates a new vector as the division of the numeric type x to the value\&. Theta is not changed\&. "
.ti -1c
.RI "template<typename T , typename  = typename enable_if<is_integer_number<T>::value>::type> \fBvector_unit_2d\fP \fBoperator^\fP (T x) const"
.br
.RI "It creates a new vector as the power of the numeric type x to the value\&. Theta is not changed\&. "
.ti -1c
.RI "template<typename T , typename  = typename enable_if<scifir::is_number<T>::value>::type> void \fBoperator+=\fP (T x)"
.br
.RI "It sums the numeric type x to the value\&. Theta is not changed\&. "
.ti -1c
.RI "template<typename T , typename  = typename enable_if<scifir::is_number<T>::value>::type> void \fBoperator\-=\fP (T x)"
.br
.RI "It substracts the numeric type x to the value\&. Theta is not changed\&. "
.ti -1c
.RI "template<typename T , typename  = typename enable_if<scifir::is_number<T>::value>::type> void \fBoperator*=\fP (T x)"
.br
.RI "It multiplies the numeric type x to the value\&. Theta is not changed\&. "
.ti -1c
.RI "template<typename T , typename  = typename enable_if<scifir::is_number<T>::value>::type> void \fBoperator/=\fP (T x)"
.br
.RI "It divides the numeric type x to the value\&. Theta is not changed\&. "
.ti -1c
.RI "\fBscalar_unit\fP \fBx_projection\fP () const"
.br
.RI "It creates the x projection of the vector, returning it as a \fBscalar_unit\fP of the same dimensions, and the value corresponds to the projection\&. "
.ti -1c
.RI "\fBscalar_unit\fP \fBy_projection\fP () const"
.br
.RI "It creates the y projection of the vector, returning it as a \fBscalar_unit\fP of the same dimensions, and the value corresponds to the projection\&. "
.ti -1c
.RI "void \fBinvert\fP ()"
.br
.RI "Changes the direction of the vector to the opposite direction\&. It does that by adding 180 degrees to theta\&. "
.ti -1c
.RI "string \fBvectorial_display\fP (int number_of_decimals=2) const"
.br
.RI "Displays the vector as the string representation of the scalar unit adding also the angle theta\&. "
.ti -1c
.RI "string \fBvectorial_derived_display\fP (int number_of_decimals=2) const"
.br
.RI "Displays the vector as the string representation of the scalar unit adding also the angle theta\&. It displays the dimensions with its derived dimensions\&. "
.ti -1c
.RI "string \fBvectorial_custom_display\fP (const string &init_dimensions, int number_of_decimals=2) const"
.br
.RI "Displays the vector as the string representation of the scalar unit adding also the angle theta\&. It displays the vector in the dimensions specified in the initialization string of dimensions init_dimensions\&. "
.in -1c
.SS "Static Public Member Functions"

.in +1c
.ti -1c
.RI "static \fBvector_unit_2d\fP \fBcartesian_2d\fP (const string &init_dimensions, float new_x, float new_y)"
.br
.RI "The dimensions are initialized from the initialization string of dimensions new_dimensions, the cartesian coordinates new_x and new_y are converted to polar coordinates and then set the value and theta\&. "
.in -1c
.SS "Public Attributes"

.in +1c
.ti -1c
.RI "\fBangle\fP \fBtheta\fP"
.br
.RI "Angle of the vector in 2D space, in polar coordinates\&. As all angles of scifir-units, it's stored in degrees\&. "
.in -1c
.SS "Private Member Functions"

.in +1c
.ti -1c
.RI "void \fBinitialize_from_string\fP (string init_vector_2d)"
.br
.RI "Initializes the member-variables with the initialization string of \fBvector_unit_2d\fP init_vector_2d\&. "
.in -1c
.SS "Additional Inherited Members"
.SH "Detailed Description"
.PP 
Class that creates a vector unit in 2D\&. The vector is in \fBpolar coordinates\fP with a value and dimensions of the \fBscalar_unit\fP, and an angle theta for his direction\&. 
.PP
Definition at line 55 of file vector_unit_2d\&.hpp\&.
.SH "Constructor & Destructor Documentation"
.PP 
.SS "vector_unit_2d::vector_unit_2d ()"

.PP
Default constructor\&. The value is set to 0, the dimensions are empty and theta is 0\&. 
.PP
Definition at line 12 of file vector_unit_2d\&.cpp\&.
.PP
.nf
12                                    : scalar_unit(),theta()
13     {}
.fi
.SS "vector_unit_2d::vector_unit_2d (const \fBvector_unit_2d\fP & x)"

.PP
Copy constructor\&. The member-variables are copied from the \fBvector_unit_2d\fP x\&. 
.PP
Definition at line 15 of file vector_unit_2d\&.cpp\&.
.PP
.nf
15                                                           : scalar_unit(x),theta(x\&.theta)
16     {}
.fi
.SS "vector_unit_2d::vector_unit_2d (\fBvector_unit_2d\fP && x)"

.PP
Move constructor\&. The member-variables are moved from the \fBvector_unit_2d\fP x\&. 
.PP
Definition at line 18 of file vector_unit_2d\&.cpp\&.
.PP
.nf
18                                                      : scalar_unit(std::move(x)),theta(std::move(x\&.theta))
19     {}
.fi
.SS "vector_unit_2d::vector_unit_2d (float new_value, const string & init_dimensions, float new_theta)\fC [explicit]\fP"

.PP
The value is new_value, the dimensions are initialized with the initialization string of dimensions, and theta is new_theta\&. 
.PP
Definition at line 21 of file vector_unit_2d\&.cpp\&.
.PP
.nf
21                                                                                                 : scalar_unit(new_value,init_dimensions),theta(new_theta)
22     {}
.fi
.SS "vector_unit_2d::vector_unit_2d (float new_value, const string & init_dimensions, const \fBangle\fP & new_theta)\fC [explicit]\fP"

.PP
The value is new_value, the dimensions are initialized with the initialization string of dimensions, and theta is new_theta\&. 
.PP
Definition at line 24 of file vector_unit_2d\&.cpp\&.
.PP
.nf
24                                                                                                        : scalar_unit(new_value,init_dimensions),theta(new_theta)
25     {}
.fi
.SS "vector_unit_2d::vector_unit_2d (double new_value, const string & init_dimensions, float new_theta)\fC [explicit]\fP"

.PP
The value is new_value (the double is casted to a float), the dimensions are initialized with the initialization string of dimensions, and theta is new_theta\&. 
.PP
Definition at line 27 of file vector_unit_2d\&.cpp\&.
.PP
.nf
27                                                                                                  : scalar_unit(new_value,init_dimensions),theta(new_theta)
28     {}
.fi
.SS "vector_unit_2d::vector_unit_2d (double new_value, const string & init_dimensions, const \fBangle\fP & new_theta)\fC [explicit]\fP"

.PP
The value is new_value (the double is casted to a float), the dimensions are initialized with the initialization string of dimensions, and theta is new_theta\&. 
.PP
Definition at line 30 of file vector_unit_2d\&.cpp\&.
.PP
.nf
30                                                                                                         : scalar_unit(new_value,init_dimensions),theta(new_theta)
31     {}
.fi
.SS "vector_unit_2d::vector_unit_2d (long double new_value, const string & init_dimensions, float new_theta)\fC [explicit]\fP"

.PP
The value is new_value (the long double is casted to a float), the dimensions are initialized with the initialization string of dimensions, and theta is new_theta\&. 
.PP
Definition at line 33 of file vector_unit_2d\&.cpp\&.
.PP
.nf
33                                                                                                       : scalar_unit(new_value,init_dimensions),theta(new_theta)
34     {}
.fi
.SS "vector_unit_2d::vector_unit_2d (long double new_value, const string & init_dimensions, const \fBangle\fP & new_theta)\fC [explicit]\fP"

.PP
The value is new_value (the long double is casted to a float), the dimensions are initialized with the initialization string of dimensions, and theta is new_theta\&. 
.PP
Definition at line 36 of file vector_unit_2d\&.cpp\&.
.PP
.nf
36                                                                                                              : scalar_unit(new_value,init_dimensions),theta(new_theta)
37     {}
.fi
.SS "vector_unit_2d::vector_unit_2d (int new_value, const string & init_dimensions, float new_theta)\fC [explicit]\fP"

.PP
The value is new_value (the int is casted to a float), the dimensions are initialized with the initialization string of dimensions, and theta is new_theta\&. 
.PP
Definition at line 39 of file vector_unit_2d\&.cpp\&.
.PP
.nf
39                                                                                               : scalar_unit(new_value,init_dimensions),theta(new_theta)
40     {}
.fi
.SS "vector_unit_2d::vector_unit_2d (int new_value, const string & init_dimensions, const \fBangle\fP & new_theta)\fC [explicit]\fP"

.PP
The value is new_value (the int is casted to a float), the dimensions are initialized with the initialization string of dimensions, and theta is new_theta\&. 
.PP
Definition at line 42 of file vector_unit_2d\&.cpp\&.
.PP
.nf
42                                                                                                      : scalar_unit(new_value,init_dimensions),theta(new_theta)
43     {}
.fi
.SS "vector_unit_2d::vector_unit_2d (float new_value, const vector< \fBdimension\fP > & new_dimensions, float new_theta)\fC [explicit]\fP"

.PP
The value is new_value, the dimensions are initialized with a vector of dimensions, and theta is new_theta\&. 
.PP
Definition at line 45 of file vector_unit_2d\&.cpp\&.
.PP
.nf
45                                                                                                           : scalar_unit(new_value,new_dimensions),theta(new_theta)
46     {}
.fi
.SS "vector_unit_2d::vector_unit_2d (float new_value, const vector< \fBdimension\fP > & new_dimensions, const \fBangle\fP & new_theta)\fC [explicit]\fP"

.PP
The value is new_value, the dimensions are initialized with a vector of dimensions, and theta is new_theta\&. 
.PP
Definition at line 48 of file vector_unit_2d\&.cpp\&.
.PP
.nf
48                                                                                                                  : scalar_unit(new_value,new_dimensions),theta(new_theta)
49     {}
.fi
.SS "vector_unit_2d::vector_unit_2d (double new_value, const vector< \fBdimension\fP > & new_dimensions, float new_theta)\fC [explicit]\fP"

.PP
The value is new_value (the double is casted to a float), the dimensions are initialized with a vector of dimensions, and theta is new_theta\&. 
.PP
Definition at line 51 of file vector_unit_2d\&.cpp\&.
.PP
.nf
51                                                                                                            : scalar_unit(new_value,new_dimensions),theta(new_theta)
52     {}
.fi
.SS "vector_unit_2d::vector_unit_2d (double new_value, const vector< \fBdimension\fP > & new_dimensions, const \fBangle\fP & new_theta)\fC [explicit]\fP"

.PP
The value is new_value (the double is casted to a float), the dimensions are initialized with a vector of dimensions, and theta is new_theta\&. 
.PP
Definition at line 54 of file vector_unit_2d\&.cpp\&.
.PP
.nf
54                                                                                                                   : scalar_unit(new_value,new_dimensions),theta(new_theta)
55     {}
.fi
.SS "vector_unit_2d::vector_unit_2d (long double new_value, const vector< \fBdimension\fP > & new_dimensions, float new_theta)\fC [explicit]\fP"

.PP
The value is new_value (the long double is casted to a float), the dimensions are initialized with a vector of dimensions, and theta is new_theta\&. 
.PP
Definition at line 57 of file vector_unit_2d\&.cpp\&.
.PP
.nf
57                                                                                                                 : scalar_unit(new_value,new_dimensions),theta(new_theta)
58     {}
.fi
.SS "vector_unit_2d::vector_unit_2d (long double new_value, const vector< \fBdimension\fP > & new_dimensions, const \fBangle\fP & new_theta)\fC [explicit]\fP"

.PP
The value is new_value (the long double is casted to a float), the dimensions are initialized with a vector of dimensions, and theta is new_theta\&. 
.PP
Definition at line 60 of file vector_unit_2d\&.cpp\&.
.PP
.nf
60                                                                                                                        : scalar_unit(new_value,new_dimensions),theta(new_theta)
61     {}
.fi
.SS "vector_unit_2d::vector_unit_2d (int new_value, const vector< \fBdimension\fP > & new_dimensions, float new_theta)\fC [explicit]\fP"

.PP
The value is new_value (the int is casted to a float), the dimensions are initialized with a vector of dimensions, and theta is new_theta\&. 
.PP
Definition at line 63 of file vector_unit_2d\&.cpp\&.
.PP
.nf
63                                                                                                         : scalar_unit(new_value,new_dimensions),theta(new_theta)
64     {}
.fi
.SS "vector_unit_2d::vector_unit_2d (int new_value, const vector< \fBdimension\fP > & new_dimensions, const \fBangle\fP & new_theta)\fC [explicit]\fP"

.PP
The value is new_value (the int is casted to a float), the dimensions are initialized with a vector of dimensions, and theta is new_theta\&. 
.PP
Definition at line 66 of file vector_unit_2d\&.cpp\&.
.PP
.nf
66                                                                                                                : scalar_unit(new_value,new_dimensions),theta(new_theta)
67     {}
.fi
.SS "vector_unit_2d::vector_unit_2d (const \fBscalar_unit\fP & x, float new_theta)\fC [explicit]\fP"

.PP
The value and the dimensions are copied from the \fBscalar_unit\fP x, theta is new_theta\&. 
.PP
Definition at line 69 of file vector_unit_2d\&.cpp\&.
.PP
.nf
69                                                                        : scalar_unit(x),theta(new_theta)
70     {}
.fi
.SS "vector_unit_2d::vector_unit_2d (const \fBscalar_unit\fP & x, const \fBangle\fP & new_theta)\fC [explicit]\fP"

.PP
The value and the dimensions are copied from the \fBscalar_unit\fP x, theta is new_theta\&. 
.PP
Definition at line 72 of file vector_unit_2d\&.cpp\&.
.PP
.nf
72                                                                               : scalar_unit(x),theta(new_theta)
73     {}
.fi
.SS "vector_unit_2d::vector_unit_2d (const string & init_scalar, float new_theta)\fC [explicit]\fP"

.PP
The value and the dimensions are copied from the initialization string of \fBscalar_unit\fP init_scalar, theta is new_theta\&. 
.PP
Definition at line 75 of file vector_unit_2d\&.cpp\&.
.PP
.nf
75                                                                             : scalar_unit(init_scalar),theta(new_theta)
76     {}
.fi
.SS "vector_unit_2d::vector_unit_2d (const string & init_scalar, const \fBangle\fP & new_theta)\fC [explicit]\fP"

.PP
The value and the dimensions are copied from the initialization string of \fBscalar_unit\fP init_scalar, theta is new_theta\&. 
.PP
Definition at line 78 of file vector_unit_2d\&.cpp\&.
.PP
.nf
78                                                                                    : scalar_unit(init_scalar),theta(new_theta)
79     {}
.fi
.SS "vector_unit_2d::vector_unit_2d (const string & init_vector_2d)\fC [explicit]\fP"

.PP
The value, the dimensions and theta are initialized from the initialization string of \fBvector_unit_2d\fP init_vector_2d\&. 
.PP
Definition at line 81 of file vector_unit_2d\&.cpp\&.
.PP
.nf
81                                                                : vector_unit_2d()
82     {
83         vector_unit_2d::initialize_from_string(init_vector_2d);
84     }
.fi
.SH "Member Function Documentation"
.PP 
.SS "\fBvector_unit_2d\fP vector_unit_2d::cartesian_2d (const string & init_dimensions, float new_x, float new_y)\fC [inline]\fP, \fC [static]\fP"

.PP
The dimensions are initialized from the initialization string of dimensions new_dimensions, the cartesian coordinates new_x and new_y are converted to polar coordinates and then set the value and theta\&. 
.PP
Definition at line 83 of file vector_unit_2d\&.hpp\&.
.PP
.nf
84             {
85                 float new_value = float(std::sqrt(std::pow(new_x,2) + std::pow(new_y,2)));
86                 float new_theta = scifir::atan_degree(new_y / new_x);
87                 return vector_unit_2d(new_value,init_dimensions,angle(new_theta));
88             }
.fi
.SS "void vector_unit_2d::initialize_from_string (string init_vector_2d)\fC [private]\fP"

.PP
Initializes the member-variables with the initialization string of \fBvector_unit_2d\fP init_vector_2d\&. 
.PP
Definition at line 310 of file vector_unit_2d\&.cpp\&.
.PP
.nf
311     {
312         vector<string> values;
313         boost::split(values,init_vector_2d,boost::is_any_of(" "));
314         if (values\&.size() == 3)
315         {
316             scalar_unit::initialize_from_string(values[0] + " " + values[1]);
317             theta = angle(values[2]);
318         }
319     }
.fi
.SS "void vector_unit_2d::invert ()\fC [inline]\fP"

.PP
Changes the direction of the vector to the opposite direction\&. It does that by adding 180 degrees to theta\&. 
.PP
Definition at line 190 of file vector_unit_2d\&.hpp\&.
.PP
.nf
191             {
192                 theta\&.invert();
193             }
.fi
.SS "\fBvector_unit_2d\fP vector_unit_2d::operator* (const \fBscalar_unit\fP & x) const"

.PP
It creates a new \fBvector_unit_2d\fP scaling a \fBvector_unit_2d\fP by the \fBscalar_unit\fP x\&. 
.PP
Definition at line 228 of file vector_unit_2d\&.cpp\&.
.PP
.nf
229     {
230         long double new_value = (long double)(scalar_unit::value * x\&.get_value());
231         vector<dimension> new_dimensions = multiply_dimensions(get_dimensions(), x\&.get_dimensions(),new_value);
232         return vector_unit_2d(new_value, new_dimensions, theta);
233     }
.fi
.SS "template<typename T , typename  = typename enable_if<scifir::is_number<T>::value>::type> \fBvector_unit_2d\fP vector_unit_2d::operator* (T x) const\fC [inline]\fP"

.PP
It creates a new vector as the multiplication of the numeric type x to the value\&. Theta is not changed\&. 
.PP
Definition at line 127 of file vector_unit_2d\&.hpp\&.
.PP
.nf
128             {
129                 vector_unit_2d y = *this;
130                 y *= x;
131                 return y;
132             }
.fi
.SS "template<typename T , typename  = typename enable_if<scifir::is_number<T>::value>::type> void vector_unit_2d::operator*= (T x)\fC [inline]\fP"

.PP
It multiplies the numeric type x to the value\&. Theta is not changed\&. 
.PP
Definition at line 161 of file vector_unit_2d\&.hpp\&.
.PP
.nf
162             {
163                 scalar_unit::value *= std::abs(x);
164                 if(x < 0)
165                 {
166                     theta\&.invert();
167                 }
168             }
.fi
.SS "\fBvector_unit_2d\fP vector_unit_2d::operator+ (const \fBvector_unit_2d\fP & x) const"

.PP
Addition of vectors in 2D\&. It creates a new vector as the addition of the other two\&. 
.PP
Definition at line 195 of file vector_unit_2d\&.cpp\&.
.PP
.nf
196     {
197         if (has_dimensions(x))
198         {
199             float new_x = float(x_projection() + x\&.x_projection());
200             float new_y = float(y_projection() + x\&.y_projection());
201             float value = cartesian_2d_to_polar_p(new_x, new_y);
202             angle theta = cartesian_2d_to_polar_theta(new_x, new_y);
203             return vector_unit_2d(value,get_dimensions(),theta);
204         }
205         else
206         {
207             return vector_unit_2d();
208         }
209     }
.fi
.SS "template<typename T , typename  = typename enable_if<scifir::is_number<T>::value>::type> \fBvector_unit_2d\fP vector_unit_2d::operator+ (T x) const\fC [inline]\fP"

.PP
It creates a new vector as the addition of the numeric type x to the value\&. Theta is not changed\&. 
.PP
Definition at line 111 of file vector_unit_2d\&.hpp\&.
.PP
.nf
112             {
113                 vector_unit_2d y = *this;
114                 y += x;
115                 return y;
116             }
.fi
.SS "void vector_unit_2d::operator+= (const \fBvector_unit_2d\fP & x)"

.PP
The \fBvector_unit_2d\fP is summed as vector, in polar coordinates\&. The addition of vectors is used for the calculation\&. 
.PP
Definition at line 167 of file vector_unit_2d\&.cpp\&.
.PP
.nf
168     {
169         if(has_dimensions(x))
170         {
171                 float new_x = float(x_projection() + x\&.x_projection());
172                 float new_y = float(y_projection() + x\&.y_projection());
173                 scalar_unit::value = cartesian_2d_to_polar_p(new_x, new_y);
174                 theta = cartesian_2d_to_polar_theta(new_x, new_y);
175         }
176         else
177         {
178             cerr << "Cannot sum vectors of different dimensions" << endl;
179         }
180     }
.fi
.SS "template<typename T , typename  = typename enable_if<scifir::is_number<T>::value>::type> void vector_unit_2d::operator+= (T x)\fC [inline]\fP"

.PP
It sums the numeric type x to the value\&. Theta is not changed\&. 
.PP
Definition at line 149 of file vector_unit_2d\&.hpp\&.
.PP
.nf
150             {
151                 scalar_unit::value += x;
152             }
.fi
.SS "template<typename T , typename  = typename enable_if<scifir::is_number<T>::value>::type> \fBvector_unit_2d\fP vector_unit_2d::operator\- (T x) const\fC [inline]\fP"

.PP
It creates a new vector as the substraction of the numeric type x to the value\&. Theta is not changed\&. 
.PP
Definition at line 119 of file vector_unit_2d\&.hpp\&.
.PP
.nf
120             {
121                 vector_unit_2d y = *this;
122                 y -= x;
123                 return y;
124             }
.fi
.SS "\fBvector_unit_2d\fP vector_unit_2d::operator\- (\fBvector_unit_2d\fP x) const"

.PP
Substraction of vectors in 2D\&. It creates a new vector as the difference of the other two\&. 
.PP
Definition at line 211 of file vector_unit_2d\&.cpp\&.
.PP
.nf
212     {
213         if (has_dimensions(x))
214         {
215             x\&.invert();
216             float new_x = float(x_projection() + x\&.x_projection());
217             float new_y = float(y_projection() + x\&.y_projection());
218             float value = cartesian_2d_to_polar_p(new_x, new_y);
219             angle theta = cartesian_2d_to_polar_theta(new_x, new_y);
220             return vector_unit_2d(value,get_dimensions(),theta);
221         }
222         else
223         {
224             return vector_unit_2d();
225         }
226     }
.fi
.SS "template<typename T , typename  = typename enable_if<scifir::is_number<T>::value>::type> void vector_unit_2d::operator\-= (T x)\fC [inline]\fP"

.PP
It substracts the numeric type x to the value\&. Theta is not changed\&. 
.PP
Definition at line 155 of file vector_unit_2d\&.hpp\&.
.PP
.nf
156             {
157                 scalar_unit::value -= x;
158             }
.fi
.SS "void vector_unit_2d::operator\-= (\fBvector_unit_2d\fP x)"

.PP
The \fBvector_unit_2d\fP is substracted as vector, in polar coordinates\&. The substraction of vectors is used for the calculation\&. 
.PP
Definition at line 182 of file vector_unit_2d\&.cpp\&.
.PP
.nf
183     {
184         if(has_dimensions(x))
185         {
186             x\&.invert();
187             *this += x;
188         }
189         else
190         {
191             cerr << "Cannot substract vectors of different dimensions" << endl;
192         }
193     }
.fi
.SS "\fBvector_unit_2d\fP vector_unit_2d::operator/ (const \fBscalar_unit\fP & x) const"

.PP
It creates a new \fBvector_unit_2d\fP scaling a \fBvector_unit_2d\fP by the inverse of the \fBscalar_unit\fP x\&. 
.PP
Definition at line 235 of file vector_unit_2d\&.cpp\&.
.PP
.nf
236     {
237         long double new_value = (long double)(scalar_unit::value / x\&.get_value());
238         vector<dimension> new_dimensions = divide_dimensions(get_dimensions(), x\&.get_dimensions(),new_value);
239         return vector_unit_2d(new_value, new_dimensions, theta);
240     }
.fi
.SS "template<typename T , typename  = typename enable_if<scifir::is_number<T>::value>::type> \fBvector_unit_2d\fP vector_unit_2d::operator/ (T x) const\fC [inline]\fP"

.PP
It creates a new vector as the division of the numeric type x to the value\&. Theta is not changed\&. 
.PP
Definition at line 135 of file vector_unit_2d\&.hpp\&.
.PP
.nf
136             {
137                 vector_unit_2d y = *this;
138                 y /= x;
139                 return y;
140             }
.fi
.SS "template<typename T , typename  = typename enable_if<scifir::is_number<T>::value>::type> void vector_unit_2d::operator/= (T x)\fC [inline]\fP"

.PP
It divides the numeric type x to the value\&. Theta is not changed\&. 
.PP
Definition at line 171 of file vector_unit_2d\&.hpp\&.
.PP
.nf
172             {
173                 scalar_unit::value /= std::abs(x);
174                 if(x < 0)
175                 {
176                     theta\&.invert();
177                 }
178             }
.fi
.SS "\fBvector_unit_2d\fP & vector_unit_2d::operator= (const \fBscalar_unit\fP & x)"

.PP
The value and the dimensions are copied from the \fBscalar_unit\fP x, theta is not changed\&. 
.PP
Definition at line 100 of file vector_unit_2d\&.cpp\&.
.PP
.nf
101     {
102         scalar_unit::operator =(x);
103         return *this;
104     }
.fi
.SS "\fBvector_unit_2d\fP & vector_unit_2d::operator= (const string & init_vector_2d)"

.PP
The value, the dimensions and theta are set from the initialization string init_vector_2d\&. 
.PP
Definition at line 112 of file vector_unit_2d\&.cpp\&.
.PP
.nf
113     {
114         vector_unit_2d::initialize_from_string(init_vector_2d);
115         return *this;
116     }
.fi
.SS "\fBvector_unit_2d\fP & vector_unit_2d::operator= (const \fBvector_unit_2d\fP & x)"

.PP
Copy assignment\&. The member-variables are copied from the \fBvector_unit_2d\fP x\&. 
.PP
Definition at line 86 of file vector_unit_2d\&.cpp\&.
.PP
.nf
87     {
88         scalar_unit::operator =(x);
89         theta = x\&.theta;
90         return *this;
91     }
.fi
.SS "\fBvector_unit_2d\fP & vector_unit_2d::operator= (\fBscalar_unit\fP && x)"

.PP
The value and the dimensions are moved from the \fBscalar_unit\fP x, theta is not changed\&. 
.PP
Definition at line 106 of file vector_unit_2d\&.cpp\&.
.PP
.nf
107     {
108         scalar_unit::operator =(std::move(x));
109         return *this;
110     }
.fi
.SS "\fBvector_unit_2d\fP & vector_unit_2d::operator= (\fBvector_unit_2d\fP && x)"

.PP
Move assignment\&. The member-variables are moved from the \fBvector_unit_2d\fP x\&. 
.PP
Definition at line 93 of file vector_unit_2d\&.cpp\&.
.PP
.nf
94     {
95         scalar_unit::operator =(std::move(x));
96         theta = std::move(x\&.theta);
97         return *this;
98     }
.fi
.SS "bool vector_unit_2d::operator== (\fBscifir::vector_unit_2d\fP x) const"

.PP
Comparison operator\&. Two \fBvector_unit_2d\fP are equal if their value, dimensions and theta are the same\&. 
.PP
Definition at line 118 of file vector_unit_2d\&.cpp\&.
.PP
.nf
119     {
120         x\&.change_dimensions(*this);
121         if(get_value() == x\&.get_value() and scifir::same_direction(*this,x) and has_dimensions(x))
122         {
123             return true;
124         }
125         else
126         {
127             return false;
128         }
129     }
.fi
.SS "\fBvector_unit_2d\fP vector_unit_2d::operator^ (const \fBscalar_unit\fP & x) const"

.PP
It powers a vector by a \fBscalar_unit\fP x if that \fBscalar_unit\fP has empty dimensions\&. 
.PP
Definition at line 242 of file vector_unit_2d\&.cpp\&.
.PP
.nf
243     {
244         if(x\&.has_empty_dimensions())
245         {
246             scalar_unit new_unit = scalar_unit::operator ^(x);
247             return vector_unit_2d(new_unit, theta);
248         }
249         else
250         {
251             cerr << "Cannot power with as exponent a unit with dimensions" << endl;
252             return vector_unit_2d();
253         }
254     }
.fi
.SS "template<typename T , typename  = typename enable_if<is_integer_number<T>::value>::type> \fBvector_unit_2d\fP vector_unit_2d::operator^ (T x) const\fC [inline]\fP"

.PP
It creates a new vector as the power of the numeric type x to the value\&. Theta is not changed\&. 
.PP
Definition at line 143 of file vector_unit_2d\&.hpp\&.
.PP
.nf
144             {
145                 return vector_unit_2d(std::pow(get_value(),x),power_dimensions(get_dimensions(),x),theta);
146             }
.fi
.SS "void vector_unit_2d::point_to (\fBdirection::name\fP x)"

.PP
Theta is set to the direction specified in 2D\&. Possible values are LEFT, RIGHT, TOP, BOTTOM, LEFT_TOP, RIGHT_TOP, RIGHT_BOTTOM, LEFT_BOTTOM\&. 
.PP
Definition at line 131 of file vector_unit_2d\&.cpp\&.
.PP
.nf
132     {
133         if (x == direction::LEFT)
134         {
135             theta = 180\&.0f;
136         }
137         else if(x == direction::RIGHT)
138         {
139             theta = 0\&.0f;
140         }
141         else if(x == direction::TOP)
142         {
143             theta = 90\&.0f;
144         }
145         else if(x == direction::BOTTOM)
146         {
147             theta = 270\&.0f;
148         }
149         else if(x == direction::LEFT_TOP)
150         {
151             theta = 135\&.0f;
152         }
153         else if(x == direction::RIGHT_TOP)
154         {
155             theta = 45\&.0f;
156         }
157         else if(x == direction::RIGHT_BOTTOM)
158         {
159             theta = 315\&.0f;
160         }
161         else if(x == direction::LEFT_BOTTOM)
162         {
163             theta = 225\&.0f;
164         }
165     }
.fi
.SS "string vector_unit_2d::vectorial_custom_display (const string & init_dimensions, int number_of_decimals = \fC2\fP) const"

.PP
Displays the vector as the string representation of the scalar unit adding also the angle theta\&. It displays the vector in the dimensions specified in the initialization string of dimensions init_dimensions\&. 
.SS "string vector_unit_2d::vectorial_derived_display (int number_of_decimals = \fC2\fP) const"

.PP
Displays the vector as the string representation of the scalar unit adding also the angle theta\&. It displays the dimensions with its derived dimensions\&. 
.SS "string vector_unit_2d::vectorial_display (int number_of_decimals = \fC2\fP) const"

.PP
Displays the vector as the string representation of the scalar unit adding also the angle theta\&. 
.SS "\fBscalar_unit\fP vector_unit_2d::x_projection () const\fC [inline]\fP"

.PP
It creates the x projection of the vector, returning it as a \fBscalar_unit\fP of the same dimensions, and the value corresponds to the projection\&. 
.PP
Definition at line 180 of file vector_unit_2d\&.hpp\&.
.PP
.nf
181             {
182                 return scalar_unit(scalar_unit::value * scifir::cos(theta),get_dimensions());
183             }
.fi
.SS "\fBscalar_unit\fP vector_unit_2d::y_projection () const\fC [inline]\fP"

.PP
It creates the y projection of the vector, returning it as a \fBscalar_unit\fP of the same dimensions, and the value corresponds to the projection\&. 
.PP
Definition at line 185 of file vector_unit_2d\&.hpp\&.
.PP
.nf
186             {
187                 return scalar_unit(scalar_unit::value * scifir::sin(theta),get_dimensions());
188             }
.fi
.SH "Member Data Documentation"
.PP 
.SS "\fBangle\fP vector_unit_2d::theta"

.PP
Angle of the vector in 2D space, in polar coordinates\&. As all angles of scifir-units, it's stored in degrees\&. 
.PP
Definition at line 199 of file vector_unit_2d\&.hpp\&.

.SH "Author"
.PP 
Generated automatically by Doxygen for scifir-units from the source code\&.
