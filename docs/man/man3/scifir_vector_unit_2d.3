.TH "scifir::vector_unit_2d" 3 "Version 2.0.0" "scifir-units" \" -*- nroff -*-
.ad l
.nh
.SH NAME
scifir::vector_unit_2d
.SH SYNOPSIS
.br
.PP
.PP
\fC#include <vector_unit_2d\&.hpp>\fP
.PP
Inherits \fBscifir::scalar_unit\fP\&.
.SS "Public Member Functions"

.in +1c
.ti -1c
.RI "\fBvector_unit_2d\fP ()"
.br
.ti -1c
.RI "\fBvector_unit_2d\fP (\fBconst\fP \fBvector_unit_2d\fP &x)"
.br
.ti -1c
.RI "\fBvector_unit_2d\fP (\fBvector_unit_2d\fP &&x)"
.br
.ti -1c
.RI "\fBvector_unit_2d\fP (\fBfloat\fP \fBnew_value\fP, \fBconst\fP \fBstring\fP &\fBinit_dimensions\fP, \fBfloat\fP \fBnew_theta\fP)"
.br
.ti -1c
.RI "\fBvector_unit_2d\fP (\fBfloat\fP \fBnew_value\fP, \fBconst\fP \fBstring\fP &\fBinit_dimensions\fP, \fBconst\fP \fBangle\fP &\fBnew_theta\fP)"
.br
.ti -1c
.RI "\fBvector_unit_2d\fP (\fBdouble\fP \fBnew_value\fP, \fBconst\fP \fBstring\fP &\fBinit_dimensions\fP, \fBfloat\fP \fBnew_theta\fP)"
.br
.ti -1c
.RI "\fBvector_unit_2d\fP (\fBdouble\fP \fBnew_value\fP, \fBconst\fP \fBstring\fP &\fBinit_dimensions\fP, \fBconst\fP \fBangle\fP &\fBnew_theta\fP)"
.br
.ti -1c
.RI "\fBvector_unit_2d\fP (\fBlong\fP \fBdouble\fP \fBnew_value\fP, \fBconst\fP \fBstring\fP &\fBinit_dimensions\fP, \fBfloat\fP \fBnew_theta\fP)"
.br
.ti -1c
.RI "\fBvector_unit_2d\fP (\fBlong\fP \fBdouble\fP \fBnew_value\fP, \fBconst\fP \fBstring\fP &\fBinit_dimensions\fP, \fBconst\fP \fBangle\fP &\fBnew_theta\fP)"
.br
.ti -1c
.RI "\fBvector_unit_2d\fP (\fBint\fP \fBnew_value\fP, \fBconst\fP \fBstring\fP &\fBinit_dimensions\fP, \fBfloat\fP \fBnew_theta\fP)"
.br
.ti -1c
.RI "\fBvector_unit_2d\fP (\fBint\fP \fBnew_value\fP, \fBconst\fP \fBstring\fP &\fBinit_dimensions\fP, \fBconst\fP \fBangle\fP &\fBnew_theta\fP)"
.br
.ti -1c
.RI "\fBvector_unit_2d\fP (\fBfloat\fP \fBnew_value\fP, \fBconst\fP vector< \fBdimension\fP > &\fBnew_dimensions\fP, \fBfloat\fP \fBnew_theta\fP)"
.br
.ti -1c
.RI "\fBvector_unit_2d\fP (\fBfloat\fP \fBnew_value\fP, \fBconst\fP vector< \fBdimension\fP > &\fBnew_dimensions\fP, \fBconst\fP \fBangle\fP &\fBnew_theta\fP)"
.br
.ti -1c
.RI "\fBvector_unit_2d\fP (\fBdouble\fP \fBnew_value\fP, \fBconst\fP vector< \fBdimension\fP > &\fBnew_dimensions\fP, \fBfloat\fP \fBnew_theta\fP)"
.br
.ti -1c
.RI "\fBvector_unit_2d\fP (\fBdouble\fP \fBnew_value\fP, \fBconst\fP vector< \fBdimension\fP > &\fBnew_dimensions\fP, \fBconst\fP \fBangle\fP &\fBnew_theta\fP)"
.br
.ti -1c
.RI "\fBvector_unit_2d\fP (\fBlong\fP \fBdouble\fP \fBnew_value\fP, \fBconst\fP vector< \fBdimension\fP > &\fBnew_dimensions\fP, \fBfloat\fP \fBnew_theta\fP)"
.br
.ti -1c
.RI "\fBvector_unit_2d\fP (\fBlong\fP \fBdouble\fP \fBnew_value\fP, \fBconst\fP vector< \fBdimension\fP > &\fBnew_dimensions\fP, \fBconst\fP \fBangle\fP &\fBnew_theta\fP)"
.br
.ti -1c
.RI "\fBvector_unit_2d\fP (\fBint\fP \fBnew_value\fP, \fBconst\fP vector< \fBdimension\fP > &\fBnew_dimensions\fP, \fBfloat\fP \fBnew_theta\fP)"
.br
.ti -1c
.RI "\fBvector_unit_2d\fP (\fBint\fP \fBnew_value\fP, \fBconst\fP vector< \fBdimension\fP > &\fBnew_dimensions\fP, \fBconst\fP \fBangle\fP &\fBnew_theta\fP)"
.br
.ti -1c
.RI "\fBvector_unit_2d\fP (\fBconst\fP \fBscalar_unit\fP &x, \fBfloat\fP \fBnew_theta\fP)"
.br
.ti -1c
.RI "\fBvector_unit_2d\fP (\fBconst\fP \fBscalar_unit\fP &x, \fBconst\fP \fBangle\fP &\fBnew_theta\fP)"
.br
.ti -1c
.RI "\fBvector_unit_2d\fP (\fBconst\fP \fBstring\fP &\fBinit_scalar\fP, \fBfloat\fP \fBnew_theta\fP)"
.br
.ti -1c
.RI "\fBvector_unit_2d\fP (\fBconst\fP \fBstring\fP &\fBinit_scalar\fP, \fBconst\fP \fBangle\fP &\fBnew_theta\fP)"
.br
.ti -1c
.RI "\fBvector_unit_2d\fP (\fBconst\fP \fBstring\fP &\fBinit_vector_2d\fP)"
.br
.ti -1c
.RI "\fBvector_unit_2d\fP & \fBoperator=\fP (\fBconst\fP \fBvector_unit_2d\fP &x)"
.br
.ti -1c
.RI "\fBvector_unit_2d\fP & \fBoperator=\fP (\fBvector_unit_2d\fP &&x)"
.br
.ti -1c
.RI "\fBvector_unit_2d\fP & \fBoperator=\fP (\fBconst\fP \fBscalar_unit\fP &x)"
.br
.ti -1c
.RI "\fBvector_unit_2d\fP & \fBoperator=\fP (\fBscalar_unit\fP &&x)"
.br
.ti -1c
.RI "\fBvector_unit_2d\fP & \fBoperator=\fP (\fBconst\fP \fBstring\fP &\fBinit_vector_2d\fP)"
.br
.ti -1c
.RI "\fBbool\fP \fBoperator==\fP (\fBvector_unit_2d\fP x) \fBconst\fP"
.br
.ti -1c
.RI "\fBvoid\fP \fBpoint_to\fP (\fBdirection::name\fP x)"
.br
.ti -1c
.RI "\fBvoid\fP \fBoperator+=\fP (\fBconst\fP \fBvector_unit_2d\fP &x)"
.br
.ti -1c
.RI "\fBvoid\fP \fBoperator\-=\fP (\fBvector_unit_2d\fP x)"
.br
.ti -1c
.RI "\fBvector_unit_2d\fP \fBoperator+\fP (\fBconst\fP \fBvector_unit_2d\fP &x) \fBconst\fP"
.br
.ti -1c
.RI "\fBvector_unit_2d\fP \fBoperator\-\fP (\fBvector_unit_2d\fP x) \fBconst\fP"
.br
.ti -1c
.RI "\fBvector_unit_2d\fP \fBoperator*\fP (\fBconst\fP \fBscalar_unit\fP &x) \fBconst\fP"
.br
.ti -1c
.RI "\fBvector_unit_2d\fP \fBoperator/\fP (\fBconst\fP \fBscalar_unit\fP &x) \fBconst\fP"
.br
.ti -1c
.RI "\fBvector_unit_2d\fP \fBoperator^\fP (\fBconst\fP \fBscalar_unit\fP &x) \fBconst\fP"
.br
.ti -1c
.RI "template<\fBtypename\fP \fBU\fP , \fBtypename\fP  = typename enable_if<scifir::is_number<U>::value>::type> \fBvector_unit_2d\fP \fBoperator+\fP (\fBU\fP x) \fBconst\fP"
.br
.ti -1c
.RI "template<\fBtypename\fP \fBU\fP , \fBtypename\fP  = typename enable_if<scifir::is_number<U>::value>::type> \fBvector_unit_2d\fP \fBoperator\-\fP (\fBU\fP x) \fBconst\fP"
.br
.ti -1c
.RI "template<\fBtypename\fP \fBU\fP , \fBtypename\fP  = typename enable_if<scifir::is_number<U>::value>::type> \fBvector_unit_2d\fP \fBoperator*\fP (\fBU\fP x) \fBconst\fP"
.br
.ti -1c
.RI "template<\fBtypename\fP \fBU\fP , \fBtypename\fP  = typename enable_if<scifir::is_number<U>::value>::type> \fBvector_unit_2d\fP \fBoperator/\fP (\fBU\fP x) \fBconst\fP"
.br
.ti -1c
.RI "template<\fBtypename\fP \fBU\fP , \fBtypename\fP  = typename enable_if<is_integer_number<U>::value>::type> \fBvector_unit_2d\fP \fBoperator^\fP (\fBU\fP x) \fBconst\fP"
.br
.ti -1c
.RI "template<\fBtypename\fP \fBU\fP , \fBtypename\fP  = typename enable_if<scifir::is_number<U>::value>::type> \fBvoid\fP \fBoperator+=\fP (\fBU\fP x)"
.br
.ti -1c
.RI "template<\fBtypename\fP \fBU\fP , \fBtypename\fP  = typename enable_if<scifir::is_number<U>::value>::type> \fBvoid\fP \fBoperator\-=\fP (\fBU\fP x)"
.br
.ti -1c
.RI "template<\fBtypename\fP \fBU\fP , \fBtypename\fP  = typename enable_if<scifir::is_number<U>::value>::type> \fBvoid\fP \fBoperator*=\fP (\fBU\fP x)"
.br
.ti -1c
.RI "template<\fBtypename\fP \fBU\fP , \fBtypename\fP  = typename enable_if<scifir::is_number<U>::value>::type> \fBvoid\fP \fBoperator/=\fP (\fBU\fP x)"
.br
.ti -1c
.RI "\fBscalar_unit\fP \fBx_projection\fP () \fBconst\fP"
.br
.ti -1c
.RI "\fBscalar_unit\fP \fBy_projection\fP () \fBconst\fP"
.br
.ti -1c
.RI "\fBvoid\fP \fBinvert\fP ()"
.br
.ti -1c
.RI "\fBstring\fP \fBvectorial_display\fP (\fBint\fP \fBnumber_of_decimals\fP=2) \fBconst\fP"
.br
.ti -1c
.RI "\fBstring\fP \fBvectorial_derived_display\fP (\fBint\fP \fBnumber_of_decimals\fP=2) \fBconst\fP"
.br
.ti -1c
.RI "\fBstring\fP \fBvectorial_custom_display\fP (\fBconst\fP \fBstring\fP &\fBinit_dimensions\fP, \fBint\fP \fBnumber_of_decimals\fP=2) \fBconst\fP"
.br
.in -1c

Public Member Functions inherited from \fBscifir::scalar_unit\fP
.in +1c
.ti -1c
.RI "\fBscalar_unit\fP ()"
.br
.RI "Default constructor, the value is 0 and the dimensions are empty\&. "
.ti -1c
.RI "\fBscalar_unit\fP (\fBconst\fP \fBscalar_unit\fP &x)"
.br
.RI "Copy constructor, copies the value and the dimensions\&. "
.ti -1c
.RI "\fBscalar_unit\fP (\fBscalar_unit\fP &&x)"
.br
.RI "Move constructor, moves the value and the dimensions\&. "
.ti -1c
.RI "\fBscalar_unit\fP (\fBfloat\fP \fBnew_value\fP, \fBconst\fP \fBstring\fP &\fBinit_dimensions\fP)"
.br
.RI "Creates a new \fBscalar_unit\fP with the value and with the dimensions specified in the string\&. "
.ti -1c
.RI "\fBscalar_unit\fP (\fBdouble\fP \fBnew_value\fP, \fBconst\fP \fBstring\fP &\fBinit_dimensions\fP)"
.br
.RI "Creates a new \fBscalar_unit\fP, the double is casted to a float\&. "
.ti -1c
.RI "\fBscalar_unit\fP (\fBlong\fP \fBdouble\fP \fBnew_value\fP, \fBconst\fP \fBstring\fP &\fBinit_dimensions\fP)"
.br
.RI "Creates a new \fBscalar_unit\fP, the long double is casted to a float\&. "
.ti -1c
.RI "\fBscalar_unit\fP (\fBint\fP \fBnew_value\fP, \fBconst\fP \fBstring\fP &\fBinit_dimensions\fP)"
.br
.RI "Creates a new \fBscalar_unit\fP, the int is casted to a float\&. "
.ti -1c
.RI "\fBscalar_unit\fP (\fBfloat\fP \fBnew_value\fP, \fBconst\fP vector< \fBdimension\fP > &\fBnew_dimensions\fP)"
.br
.RI "Creates a new \fBscalar_unit\fP with the value given and copying the dimensions\&. "
.ti -1c
.RI "\fBscalar_unit\fP (\fBdouble\fP \fBnew_value\fP, \fBconst\fP vector< \fBdimension\fP > &\fBnew_dimensions\fP)"
.br
.RI "Creates a new \fBscalar_unit\fP, the double is casted to a float, the dimensions are copied\&. "
.ti -1c
.RI "\fBscalar_unit\fP (\fBlong\fP \fBdouble\fP \fBnew_value\fP, \fBconst\fP vector< \fBdimension\fP > &\fBnew_dimensions\fP)"
.br
.RI "Creates a new \fBscalar_unit\fP, the long double is casted to a float, the dimensions are copied\&. "
.ti -1c
.RI "\fBscalar_unit\fP (\fBint\fP \fBnew_value\fP, \fBconst\fP vector< \fBdimension\fP > &\fBnew_dimensions\fP)"
.br
.RI "Creates a new \fBscalar_unit\fP, the int is casted to a float, the dimensions are copied\&. "
.ti -1c
.RI "\fBscalar_unit\fP (\fBconst\fP \fBstring\fP &\fBinit_scalar\fP)"
.br
.RI "Creates a new \fBscalar_unit\fP, the initialization string specifies both the value and the dimensions\&. "
.ti -1c
.RI "\fBscalar_unit\fP & \fBoperator=\fP (\fBconst\fP \fBscalar_unit\fP &x)"
.br
.RI "Copy assignment, it assigns a copy of the \fBscalar_unit\fP\&. "
.ti -1c
.RI "\fBscalar_unit\fP & \fBoperator=\fP (\fBscalar_unit\fP &&x)"
.br
.RI "Move assignment, it moves the \fBscalar_unit\fP\&. "
.ti -1c
.RI "\fBscalar_unit\fP & \fBoperator=\fP (\fBconst\fP \fBstring\fP &\fBinit_scalar\fP)"
.br
.RI "Assignment with an initialization string, the value and the dimensions are both specified\&. "
.ti -1c
.RI "\fBoperator float\fP () \fBconst\fP"
.br
.RI "Cast the \fBscalar_unit\fP to their float equivalent, it discards the dimensions and copies the value to a float\&. "
.ti -1c
.RI "\fBbool\fP \fBoperator==\fP (\fBscalar_unit\fP x) \fBconst\fP"
.br
.RI "Comparison operator, two \fBscalar_unit\fP classes are considered equivalent if they have the same value given the same dimensions\&. "
.ti -1c
.RI "\fBscalar_unit\fP \fBoperator+\fP (\fBscalar_unit\fP x) \fBconst\fP"
.br
.RI "Addition operator, it sums two \fBscalar_unit\fP classes, their dimensions are changed to be equal first\&. If the basic dimensions are different, it returns an empty \fBscalar_unit\fP class\&. "
.ti -1c
.RI "\fBscalar_unit\fP \fBoperator\-\fP (\fBscalar_unit\fP x) \fBconst\fP"
.br
.RI "Substraction operator, it substracts one \fBscalar_unit\fP from the other, their dimensions are changed to be equal first\&. If the basic dimensions are different, it returns an empty \fBscalar_unit\fP class\&. "
.ti -1c
.RI "\fBscalar_unit\fP \fBoperator*\fP (\fBscalar_unit\fP x) \fBconst\fP"
.br
.RI "Multiplication operator, it multiplies two \fBscalar_unit\fP classes, their dimensions are also multiplied\&. "
.ti -1c
.RI "\fBscalar_unit\fP \fBoperator/\fP (\fBscalar_unit\fP x) \fBconst\fP"
.br
.RI "Division operator, it divides one \fBscalar_unit\fP class with the other, their dimensions are also divided\&. "
.ti -1c
.RI "\fBscalar_unit\fP \fBoperator^\fP (\fBconst\fP \fBscalar_unit\fP &x) \fBconst\fP"
.br
.RI "Power operator, it powers a \fBscalar_unit\fP class with another, if that second \fBscalar_unit\fP class, which is the exponent, as empty dimensions\&. If the exponent doesn't has empty dimensions it returns an empty \fBscalar_unit\fP class\&. "
.ti -1c
.RI "\fBvoid\fP \fBoperator+=\fP (\fBscalar_unit\fP x)"
.br
.RI "Addition operator, it adds a \fBscalar_unit\fP class to another, by converting their dimensions to be equal first\&. If their basic dimensions are different, it doesn't sums to the value\&. "
.ti -1c
.RI "\fBvoid\fP \fBoperator\-=\fP (\fBscalar_unit\fP x)"
.br
.RI "Substraction operator, it substracts a \fBscalar_unit\fP class to another, by converting their dimensions to be equal first\&. If their basic dimensions are different, it doesn't substracts to the value\&. "
.ti -1c
.RI "template<\fBtypename\fP T , \fBtypename\fP  = typename enable_if<scifir::is_number<T>::value>::type> \fBscalar_unit\fP \fBoperator+\fP (T y) \fBconst\fP"
.br
.RI "Addition operator, it sums the numeric type to the value, independent of the dimensions\&. "
.ti -1c
.RI "template<\fBtypename\fP T , \fBtypename\fP  = typename enable_if<scifir::is_number<T>::value>::type> \fBscalar_unit\fP \fBoperator\-\fP (T y) \fBconst\fP"
.br
.RI "Substraction operator, it substracts the numeric type to the value, independent of the dimensions\&. "
.ti -1c
.RI "template<\fBtypename\fP T , \fBtypename\fP  = typename enable_if<scifir::is_number<T>::value>::type> \fBscalar_unit\fP \fBoperator*\fP (T y) \fBconst\fP"
.br
.RI "Multiplication operator, it multiplies the numeric type with the value, independent of the dimensions\&. "
.ti -1c
.RI "template<\fBtypename\fP T , \fBtypename\fP  = typename enable_if<scifir::is_number<T>::value>::type> \fBscalar_unit\fP \fBoperator/\fP (T y) \fBconst\fP"
.br
.RI "Division operator, it divides the value with the numeric type, independent of the dimensions\&. "
.ti -1c
.RI "template<\fBtypename\fP T , \fBtypename\fP  = typename enable_if<is_integer_number<T>::value>::type> \fBscalar_unit\fP \fBoperator^\fP (T y) \fBconst\fP"
.br
.RI "Power operator, it powers the value with the numeric type, independent of the dimensions\&. "
.ti -1c
.RI "template<\fBtypename\fP T , \fBtypename\fP  = typename enable_if<scifir::is_number<T>::value>::type> \fBvoid\fP \fBoperator+=\fP (T y)"
.br
.RI "Addition operator, it adds the numeric type to the value, independent of the dimensions\&. "
.ti -1c
.RI "template<\fBtypename\fP T , \fBtypename\fP  = typename enable_if<scifir::is_number<T>::value>::type> \fBvoid\fP \fBoperator\-=\fP (T y)"
.br
.RI "Substraction operator, it substracts the numeric type to the value, independent of the dimensions\&. "
.ti -1c
.RI "template<\fBtypename\fP T , \fBtypename\fP  = typename enable_if<scifir::is_number<T>::value>::type> \fBvoid\fP \fBoperator*=\fP (T y)"
.br
.RI "Multiplication operator, it multiplies the numeric type to the value, independent of the dimensions\&. "
.ti -1c
.RI "template<\fBtypename\fP T , \fBtypename\fP  = typename enable_if<scifir::is_number<T>::value>::type> \fBvoid\fP \fBoperator/=\fP (T y)"
.br
.RI "Division operator, it divides the numeric type to the value, independent of the dimensions\&. "
.ti -1c
.RI "\fBscalar_unit\fP & \fBoperator++\fP ()"
.br
.RI "Increment operator, it increases the value by one\&. "
.ti -1c
.RI "\fBscalar_unit\fP & \fBoperator++\fP (\fBint\fP)"
.br
.RI "Increment operator, it increases the value by one\&. "
.ti -1c
.RI "\fBscalar_unit\fP & \fBoperator\-\-\fP ()"
.br
.RI "Decrement operator, it decreases the value by one\&. "
.ti -1c
.RI "\fBscalar_unit\fP & \fBoperator\-\-\fP (\fBint\fP)"
.br
.RI "Decrement operator, it decreases the value by one\&. "
.ti -1c
.RI "\fBvoid\fP \fBchange_dimensions\fP (\fBconst\fP \fBstring\fP &\fBinit_dimensions\fP)"
.br
.RI "Changes the dimensions to the dimensions specified by the initialization string of dimensions\&. "
.ti -1c
.RI "\fBvoid\fP \fBchange_dimensions\fP (\fBconst\fP \fBscalar_unit\fP &x)"
.br
.RI "Changes the dimensions to the same dimensions of the \fBscalar_unit\fP\&. "
.ti -1c
.RI "\fBbool\fP \fBhas_dimensions\fP (\fBconst\fP \fBstring\fP &\fBinit_dimensions\fP) \fBconst\fP"
.br
.RI "Checks if the basic dimensions are the same as the initialization string of dimensions\&. "
.ti -1c
.RI "\fBbool\fP \fBhas_dimensions\fP (\fBconst\fP vector< \fBdimension\fP > &\fBx_dimensions\fP) \fBconst\fP"
.br
.RI "Checks if the basic dimensions are the same as some set of dimensions\&. "
.ti -1c
.RI "\fBbool\fP \fBhas_dimensions\fP (\fBconst\fP \fBscalar_unit\fP &x) \fBconst\fP"
.br
.RI "Checks if the basic dimensions are the same as other \fBscalar_unit\fP\&. "
.ti -1c
.RI "\fBbool\fP \fBhas_empty_dimensions\fP () \fBconst\fP"
.br
.RI "Checks if there aren't basic dimensions\&. "
.ti -1c
.RI "\fBstring\fP \fBdisplay_dimensions\fP () \fBconst\fP"
.br
.RI "Generates an string of the dimensions of the \fBscalar_unit\fP, with the same format as the initialization string of dimensions\&. "
.ti -1c
.RI "vector< \fBdimension\fP > \fBget_derived_dimensions\fP () \fBconst\fP"
.br
.RI "Generates a set of the derived dimensions of the dimensions of the \fBscalar_unit\fP\&. "
.ti -1c
.RI "\fBconst\fP vector< \fBdimension\fP > & \fBget_dimensions\fP () \fBconst\fP"
.br
.RI "Read-only getter of the dimensions\&. "
.ti -1c
.RI "\fBconst\fP \fBfloat\fP & \fBget_value\fP () \fBconst\fP"
.br
.RI "Read-only getter of the value\&. "
.ti -1c
.RI "\fBstring\fP \fBdisplay\fP (\fBint\fP \fBnumber_of_decimals\fP=2, \fBbool\fP \fBwith_brackets\fP=\fBfalse\fP, \fBbool\fP \fBuse_close_prefix\fP=\fBfalse\fP) \fBconst\fP"
.br
.RI "Generates an string of the \fBscalar_unit\fP, with the value and the dimensions\&. The dimensions can be enclosed by brackets, and the value can be set to have the closest prefix\&. "
.ti -1c
.RI "\fBstring\fP \fBderived_display\fP (\fBint\fP \fBnumber_of_decimals\fP=2, \fBbool\fP \fBwith_brackets\fP=\fBfalse\fP, \fBbool\fP \fBuse_close_prefix\fP=\fBfalse\fP) \fBconst\fP"
.br
.RI "Generates an string of the \fBscalar_unit\fP, with all dimensions converted to their derived counterpart\&. "
.ti -1c
.RI "\fBstring\fP \fBcustom_display\fP (\fBconst\fP \fBstring\fP &\fBinit_dimensions\fP, \fBint\fP \fBnumber_of_decimals\fP=2, \fBbool\fP \fBwith_brackets\fP=\fBfalse\fP) \fBconst\fP"
.br
.RI "Generates an string of the \fBscalar_unit\fP, with the dimensions changed to any set of dimensions, specified by an initialization string of dimensions\&. "
.in -1c
.SS "Static Public Member Functions"

.in +1c
.ti -1c
.RI "\fBstatic\fP \fBvector_unit_2d\fP \fBcartesian_2d\fP (\fBconst\fP \fBstring\fP &\fBnew_dimensions\fP, \fBfloat\fP \fBnew_x\fP, \fBfloat\fP \fBnew_y\fP)"
.br
.in -1c
.SS "Public Attributes"

.in +1c
.ti -1c
.RI "\fBangle\fP \fBtheta\fP"
.br
.in -1c
.SS "Private Member Functions"

.in +1c
.ti -1c
.RI "\fBvoid\fP \fBinitialize_from_string\fP (\fBstring\fP \fBinit_vector_2d\fP)"
.br
.in -1c
.SS "Additional Inherited Members"


Protected Member Functions inherited from \fBscifir::scalar_unit\fP
.in +1c
.ti -1c
.RI "\fBvoid\fP \fBadd_dimension\fP (\fBconst\fP \fBdimension\fP &\fBnew_dimension\fP)"
.br
.RI "Internal function\&. It adds a dimension, changing the value according to the conversion factor of the added dimension and the prefix\&. "
.ti -1c
.RI "\fBvoid\fP \fBremove_dimension\fP (\fBconst\fP \fBdimension\fP &\fBold_dimension\fP)"
.br
.RI "Internal function\&. It removes a dimension, changing the value according to the conversion factor of the removed dimension and the prefix\&. "
.ti -1c
.RI "\fBvoid\fP \fBinitialize_from_string\fP (\fBstring\fP \fBinit_scalar\fP)"
.br
.RI "Internal function\&. It sets the value and the dimensions of the \fBscalar_unit\fP to the value and dimensions specified by the initialization string of \fBscalar_unit\fP\&. "
.in -1c

Protected Attributes inherited from \fBscifir::scalar_unit\fP
.in +1c
.ti -1c
.RI "vector< \fBdimension\fP > \fBdimensions\fP"
.br
.RI "Dimensions of the \fBscalar_unit\fP\&. They can be basic dimensions or abbreviations\&. "
.ti -1c
.RI "\fBfloat\fP \fBvalue\fP"
.br
.RI "Value of the \fBscalar_unit\fP\&. It changes automatically when the dimensions change\&. "
.in -1c
.SH "Detailed Description"
.PP 
Definition at line \fB55\fP of file \fBvector_unit_2d\&.hpp\fP\&.
.SH "Constructor & Destructor Documentation"
.PP 
.SS "scifir::vector_unit_2d::vector_unit_2d ()"

.PP
Definition at line \fB12\fP of file \fBvector_unit_2d\&.cpp\fP\&..PP
.nf
12                                    : scalar_unit(),theta()
13     {}
.fi

.SS "scifir::vector_unit_2d::vector_unit_2d (\fBconst\fP \fBvector_unit_2d\fP & x)"

.PP
Definition at line \fB15\fP of file \fBvector_unit_2d\&.cpp\fP\&..PP
.nf
15                                                           : scalar_unit(x),theta(x\&.theta)
16     {}
.fi

.SS "scifir::vector_unit_2d::vector_unit_2d (\fBvector_unit_2d\fP && x)"

.PP
Definition at line \fB18\fP of file \fBvector_unit_2d\&.cpp\fP\&..PP
.nf
18                                                      : scalar_unit(std::move(x)),theta(std::move(x\&.theta))
19     {}
.fi

.SS "scifir::vector_unit_2d::vector_unit_2d (\fBfloat\fP new_value, \fBconst\fP \fBstring\fP & init_dimensions, \fBfloat\fP new_theta)\fC [explicit]\fP"

.PP
Definition at line \fB21\fP of file \fBvector_unit_2d\&.cpp\fP\&..PP
.nf
21                                                                                                 : scalar_unit(new_value,init_dimensions),theta(new_theta)
22     {}
.fi

.SS "scifir::vector_unit_2d::vector_unit_2d (\fBfloat\fP new_value, \fBconst\fP \fBstring\fP & init_dimensions, \fBconst\fP \fBangle\fP & new_theta)\fC [explicit]\fP"

.PP
Definition at line \fB24\fP of file \fBvector_unit_2d\&.cpp\fP\&..PP
.nf
24                                                                                                        : scalar_unit(new_value,init_dimensions),theta(new_theta)
25     {}
.fi

.SS "scifir::vector_unit_2d::vector_unit_2d (\fBdouble\fP new_value, \fBconst\fP \fBstring\fP & init_dimensions, \fBfloat\fP new_theta)\fC [explicit]\fP"

.PP
Definition at line \fB27\fP of file \fBvector_unit_2d\&.cpp\fP\&..PP
.nf
27                                                                                                  : scalar_unit(new_value,init_dimensions),theta(new_theta)
28     {}
.fi

.SS "scifir::vector_unit_2d::vector_unit_2d (\fBdouble\fP new_value, \fBconst\fP \fBstring\fP & init_dimensions, \fBconst\fP \fBangle\fP & new_theta)\fC [explicit]\fP"

.PP
Definition at line \fB30\fP of file \fBvector_unit_2d\&.cpp\fP\&..PP
.nf
30                                                                                                         : scalar_unit(new_value,init_dimensions),theta(new_theta)
31     {}
.fi

.SS "scifir::vector_unit_2d::vector_unit_2d (\fBlong\fP \fBdouble\fP new_value, \fBconst\fP \fBstring\fP & init_dimensions, \fBfloat\fP new_theta)\fC [explicit]\fP"

.PP
Definition at line \fB33\fP of file \fBvector_unit_2d\&.cpp\fP\&..PP
.nf
33                                                                                                       : scalar_unit(new_value,init_dimensions),theta(new_theta)
34     {}
.fi

.SS "scifir::vector_unit_2d::vector_unit_2d (\fBlong\fP \fBdouble\fP new_value, \fBconst\fP \fBstring\fP & init_dimensions, \fBconst\fP \fBangle\fP & new_theta)\fC [explicit]\fP"

.PP
Definition at line \fB36\fP of file \fBvector_unit_2d\&.cpp\fP\&..PP
.nf
36                                                                                                              : scalar_unit(new_value,init_dimensions),theta(new_theta)
37     {}
.fi

.SS "scifir::vector_unit_2d::vector_unit_2d (\fBint\fP new_value, \fBconst\fP \fBstring\fP & init_dimensions, \fBfloat\fP new_theta)\fC [explicit]\fP"

.PP
Definition at line \fB39\fP of file \fBvector_unit_2d\&.cpp\fP\&..PP
.nf
39                                                                                               : scalar_unit(new_value,init_dimensions),theta(new_theta)
40     {}
.fi

.SS "scifir::vector_unit_2d::vector_unit_2d (\fBint\fP new_value, \fBconst\fP \fBstring\fP & init_dimensions, \fBconst\fP \fBangle\fP & new_theta)\fC [explicit]\fP"

.PP
Definition at line \fB42\fP of file \fBvector_unit_2d\&.cpp\fP\&..PP
.nf
42                                                                                                      : scalar_unit(new_value,init_dimensions),theta(new_theta)
43     {}
.fi

.SS "scifir::vector_unit_2d::vector_unit_2d (\fBfloat\fP new_value, \fBconst\fP vector< \fBdimension\fP > & new_dimensions, \fBfloat\fP new_theta)\fC [explicit]\fP"

.PP
Definition at line \fB45\fP of file \fBvector_unit_2d\&.cpp\fP\&..PP
.nf
45                                                                                                           : scalar_unit(new_value,new_dimensions),theta(new_theta)
46     {}
.fi

.SS "scifir::vector_unit_2d::vector_unit_2d (\fBfloat\fP new_value, \fBconst\fP vector< \fBdimension\fP > & new_dimensions, \fBconst\fP \fBangle\fP & new_theta)\fC [explicit]\fP"

.PP
Definition at line \fB48\fP of file \fBvector_unit_2d\&.cpp\fP\&..PP
.nf
48                                                                                                                  : scalar_unit(new_value,new_dimensions),theta(new_theta)
49     {}
.fi

.SS "scifir::vector_unit_2d::vector_unit_2d (\fBdouble\fP new_value, \fBconst\fP vector< \fBdimension\fP > & new_dimensions, \fBfloat\fP new_theta)\fC [explicit]\fP"

.PP
Definition at line \fB51\fP of file \fBvector_unit_2d\&.cpp\fP\&..PP
.nf
51                                                                                                            : scalar_unit(new_value,new_dimensions),theta(new_theta)
52     {}
.fi

.SS "scifir::vector_unit_2d::vector_unit_2d (\fBdouble\fP new_value, \fBconst\fP vector< \fBdimension\fP > & new_dimensions, \fBconst\fP \fBangle\fP & new_theta)\fC [explicit]\fP"

.PP
Definition at line \fB54\fP of file \fBvector_unit_2d\&.cpp\fP\&..PP
.nf
54                                                                                                                   : scalar_unit(new_value,new_dimensions),theta(new_theta)
55     {}
.fi

.SS "scifir::vector_unit_2d::vector_unit_2d (\fBlong\fP \fBdouble\fP new_value, \fBconst\fP vector< \fBdimension\fP > & new_dimensions, \fBfloat\fP new_theta)\fC [explicit]\fP"

.PP
Definition at line \fB57\fP of file \fBvector_unit_2d\&.cpp\fP\&..PP
.nf
57                                                                                                                 : scalar_unit(new_value,new_dimensions),theta(new_theta)
58     {}
.fi

.SS "scifir::vector_unit_2d::vector_unit_2d (\fBlong\fP \fBdouble\fP new_value, \fBconst\fP vector< \fBdimension\fP > & new_dimensions, \fBconst\fP \fBangle\fP & new_theta)\fC [explicit]\fP"

.PP
Definition at line \fB60\fP of file \fBvector_unit_2d\&.cpp\fP\&..PP
.nf
60                                                                                                                        : scalar_unit(new_value,new_dimensions),theta(new_theta)
61     {}
.fi

.SS "scifir::vector_unit_2d::vector_unit_2d (\fBint\fP new_value, \fBconst\fP vector< \fBdimension\fP > & new_dimensions, \fBfloat\fP new_theta)\fC [explicit]\fP"

.PP
Definition at line \fB63\fP of file \fBvector_unit_2d\&.cpp\fP\&..PP
.nf
63                                                                                                         : scalar_unit(new_value,new_dimensions),theta(new_theta)
64     {}
.fi

.SS "scifir::vector_unit_2d::vector_unit_2d (\fBint\fP new_value, \fBconst\fP vector< \fBdimension\fP > & new_dimensions, \fBconst\fP \fBangle\fP & new_theta)\fC [explicit]\fP"

.PP
Definition at line \fB66\fP of file \fBvector_unit_2d\&.cpp\fP\&..PP
.nf
66                                                                                                                : scalar_unit(new_value,new_dimensions),theta(new_theta)
67     {}
.fi

.SS "scifir::vector_unit_2d::vector_unit_2d (\fBconst\fP \fBscalar_unit\fP & x, \fBfloat\fP new_theta)\fC [explicit]\fP"

.PP
Definition at line \fB69\fP of file \fBvector_unit_2d\&.cpp\fP\&..PP
.nf
69                                                                        : scalar_unit(x),theta(new_theta)
70     {}
.fi

.SS "scifir::vector_unit_2d::vector_unit_2d (\fBconst\fP \fBscalar_unit\fP & x, \fBconst\fP \fBangle\fP & new_theta)\fC [explicit]\fP"

.PP
Definition at line \fB72\fP of file \fBvector_unit_2d\&.cpp\fP\&..PP
.nf
72                                                                               : scalar_unit(x),theta(new_theta)
73     {}
.fi

.SS "scifir::vector_unit_2d::vector_unit_2d (\fBconst\fP \fBstring\fP & init_scalar, \fBfloat\fP new_theta)\fC [explicit]\fP"

.PP
Definition at line \fB75\fP of file \fBvector_unit_2d\&.cpp\fP\&..PP
.nf
75                                                                             : scalar_unit(init_scalar),theta(new_theta)
76     {}
.fi

.SS "scifir::vector_unit_2d::vector_unit_2d (\fBconst\fP \fBstring\fP & init_scalar, \fBconst\fP \fBangle\fP & new_theta)\fC [explicit]\fP"

.PP
Definition at line \fB78\fP of file \fBvector_unit_2d\&.cpp\fP\&..PP
.nf
78                                                                                    : scalar_unit(init_scalar),theta(new_theta)
79     {}
.fi

.SS "scifir::vector_unit_2d::vector_unit_2d (\fBconst\fP \fBstring\fP & init_vector_2d)\fC [explicit]\fP"

.PP
Definition at line \fB81\fP of file \fBvector_unit_2d\&.cpp\fP\&..PP
.nf
81                                                                : vector_unit_2d()
82     {
83         vector_unit_2d::initialize_from_string(init_vector_2d);
84     }
.fi

.SH "Member Function Documentation"
.PP 
.SS "\fBstatic\fP \fBvector_unit_2d\fP scifir::vector_unit_2d::cartesian_2d (\fBconst\fP \fBstring\fP & new_dimensions, \fBfloat\fP new_x, \fBfloat\fP new_y)\fC [inline]\fP, \fC [static]\fP"

.PP
Definition at line \fB83\fP of file \fBvector_unit_2d\&.hpp\fP\&..PP
.nf
84             {
85                 float new_value = float(std::sqrt(std::pow(new_x,2) + std::pow(new_y,2)));
86                 float new_theta = scifir::atan_grade(new_y / new_x);
87                 return vector_unit_2d(new_value,new_dimensions,angle(new_theta));
88             }
.fi

.SS "\fBvoid\fP scifir::vector_unit_2d::initialize_from_string (\fBstring\fP init_vector_2d)\fC [private]\fP"

.PP
Definition at line \fB310\fP of file \fBvector_unit_2d\&.cpp\fP\&..PP
.nf
311     {
312         vector<string> values;
313         boost::split(values,init_vector_2d,boost::is_any_of(" "));
314         if (values\&.size() == 3)
315         {
316             scalar_unit::initialize_from_string(values[0] + " " + values[1]);
317             theta = angle(values[2]);
318         }
319     }
.fi

.SS "\fBvoid\fP scifir::vector_unit_2d::invert ()\fC [inline]\fP"

.PP
Definition at line \fB190\fP of file \fBvector_unit_2d\&.hpp\fP\&..PP
.nf
191             {
192                 theta\&.invert();
193             }
.fi

.SS "\fBvector_unit_2d\fP scifir::vector_unit_2d::operator* (\fBconst\fP \fBscalar_unit\fP & x) const"

.PP
Definition at line \fB228\fP of file \fBvector_unit_2d\&.cpp\fP\&..PP
.nf
229     {
230         long double new_value = (long double)(scalar_unit::value * x\&.get_value());
231         vector<dimension> new_dimensions = multiply_dimensions(get_dimensions(), x\&.get_dimensions(),new_value);
232         return vector_unit_2d(new_value, new_dimensions, theta);
233     }
.fi

.SS "template<\fBtypename\fP \fBU\fP , \fBtypename\fP  = typename enable_if<scifir::is_number<U>::value>::type> \fBvector_unit_2d\fP scifir::vector_unit_2d::operator* (\fBU\fP x) const\fC [inline]\fP"

.PP
Definition at line \fB127\fP of file \fBvector_unit_2d\&.hpp\fP\&..PP
.nf
128             {
129                 vector_unit_2d y = *this;
130                 y *= x;
131                 return y;
132             }
.fi

.SS "template<\fBtypename\fP \fBU\fP , \fBtypename\fP  = typename enable_if<scifir::is_number<U>::value>::type> \fBvoid\fP scifir::vector_unit_2d::operator*= (\fBU\fP x)\fC [inline]\fP"

.PP
Definition at line \fB161\fP of file \fBvector_unit_2d\&.hpp\fP\&..PP
.nf
162             {
163                 scalar_unit::value *= std::abs(x);
164                 if(x < 0)
165                 {
166                     theta\&.invert();
167                 }
168             }
.fi

.SS "\fBvector_unit_2d\fP scifir::vector_unit_2d::operator+ (\fBconst\fP \fBvector_unit_2d\fP & x) const"

.PP
Definition at line \fB195\fP of file \fBvector_unit_2d\&.cpp\fP\&..PP
.nf
196     {
197         if (has_dimensions(x))
198         {
199             float new_x = float(x_projection() + x\&.x_projection());
200             float new_y = float(y_projection() + x\&.y_projection());
201             float value = cartesian_2d_to_polar_p(new_x, new_y);
202             angle theta = cartesian_2d_to_polar_theta(new_x, new_y);
203             return vector_unit_2d(value,get_dimensions(),theta);
204         }
205         else
206         {
207             return vector_unit_2d();
208         }
209     }
.fi

.SS "template<\fBtypename\fP \fBU\fP , \fBtypename\fP  = typename enable_if<scifir::is_number<U>::value>::type> \fBvector_unit_2d\fP scifir::vector_unit_2d::operator+ (\fBU\fP x) const\fC [inline]\fP"

.PP
Definition at line \fB111\fP of file \fBvector_unit_2d\&.hpp\fP\&..PP
.nf
112             {
113                 vector_unit_2d y = *this;
114                 y += x;
115                 return y;
116             }
.fi

.SS "\fBvoid\fP scifir::vector_unit_2d::operator+= (\fBconst\fP \fBvector_unit_2d\fP & x)"

.PP
Definition at line \fB167\fP of file \fBvector_unit_2d\&.cpp\fP\&..PP
.nf
168     {
169         if(has_dimensions(x))
170         {
171                 float new_x = float(x_projection() + x\&.x_projection());
172                 float new_y = float(y_projection() + x\&.y_projection());
173                 scalar_unit::value = cartesian_2d_to_polar_p(new_x, new_y);
174                 theta = cartesian_2d_to_polar_theta(new_x, new_y);
175         }
176         else
177         {
178             cerr << "Cannot sum vectors of different dimensions" << endl;
179         }
180     }
.fi

.SS "template<\fBtypename\fP \fBU\fP , \fBtypename\fP  = typename enable_if<scifir::is_number<U>::value>::type> \fBvoid\fP scifir::vector_unit_2d::operator+= (\fBU\fP x)\fC [inline]\fP"

.PP
Definition at line \fB149\fP of file \fBvector_unit_2d\&.hpp\fP\&..PP
.nf
150             {
151                 scalar_unit::value += x;
152             }
.fi

.SS "template<\fBtypename\fP \fBU\fP , \fBtypename\fP  = typename enable_if<scifir::is_number<U>::value>::type> \fBvector_unit_2d\fP scifir::vector_unit_2d::operator\- (\fBU\fP x) const\fC [inline]\fP"

.PP
Definition at line \fB119\fP of file \fBvector_unit_2d\&.hpp\fP\&..PP
.nf
120             {
121                 vector_unit_2d y = *this;
122                 y \-= x;
123                 return y;
124             }
.fi

.SS "\fBvector_unit_2d\fP scifir::vector_unit_2d::operator\- (\fBvector_unit_2d\fP x) const"

.PP
Definition at line \fB211\fP of file \fBvector_unit_2d\&.cpp\fP\&..PP
.nf
212     {
213         if (has_dimensions(x))
214         {
215             x\&.invert();
216             float new_x = float(x_projection() + x\&.x_projection());
217             float new_y = float(y_projection() + x\&.y_projection());
218             float value = cartesian_2d_to_polar_p(new_x, new_y);
219             angle theta = cartesian_2d_to_polar_theta(new_x, new_y);
220             return vector_unit_2d(value,get_dimensions(),theta);
221         }
222         else
223         {
224             return vector_unit_2d();
225         }
226     }
.fi

.SS "template<\fBtypename\fP \fBU\fP , \fBtypename\fP  = typename enable_if<scifir::is_number<U>::value>::type> \fBvoid\fP scifir::vector_unit_2d::operator\-= (\fBU\fP x)\fC [inline]\fP"

.PP
Definition at line \fB155\fP of file \fBvector_unit_2d\&.hpp\fP\&..PP
.nf
156             {
157                 scalar_unit::value \-= x;
158             }
.fi

.SS "\fBvoid\fP scifir::vector_unit_2d::operator\-= (\fBvector_unit_2d\fP x)"

.PP
Definition at line \fB182\fP of file \fBvector_unit_2d\&.cpp\fP\&..PP
.nf
183     {
184         if(has_dimensions(x))
185         {
186             x\&.invert();
187             *this += x;
188         }
189         else
190         {
191             cerr << "Cannot substract vectors of different dimensions" << endl;
192         }
193     }
.fi

.SS "\fBvector_unit_2d\fP scifir::vector_unit_2d::operator/ (\fBconst\fP \fBscalar_unit\fP & x) const"

.PP
Definition at line \fB235\fP of file \fBvector_unit_2d\&.cpp\fP\&..PP
.nf
236     {
237         long double new_value = (long double)(scalar_unit::value / x\&.get_value());
238         vector<dimension> new_dimensions = divide_dimensions(get_dimensions(), x\&.get_dimensions(),new_value);
239         return vector_unit_2d(new_value, new_dimensions, theta);
240     }
.fi

.SS "template<\fBtypename\fP \fBU\fP , \fBtypename\fP  = typename enable_if<scifir::is_number<U>::value>::type> \fBvector_unit_2d\fP scifir::vector_unit_2d::operator/ (\fBU\fP x) const\fC [inline]\fP"

.PP
Definition at line \fB135\fP of file \fBvector_unit_2d\&.hpp\fP\&..PP
.nf
136             {
137                 vector_unit_2d y = *this;
138                 y /= x;
139                 return y;
140             }
.fi

.SS "template<\fBtypename\fP \fBU\fP , \fBtypename\fP  = typename enable_if<scifir::is_number<U>::value>::type> \fBvoid\fP scifir::vector_unit_2d::operator/= (\fBU\fP x)\fC [inline]\fP"

.PP
Definition at line \fB171\fP of file \fBvector_unit_2d\&.hpp\fP\&..PP
.nf
172             {
173                 scalar_unit::value /= std::abs(x);
174                 if(x < 0)
175                 {
176                     theta\&.invert();
177                 }
178             }
.fi

.SS "\fBvector_unit_2d\fP & scifir::vector_unit_2d::operator= (\fBconst\fP \fBscalar_unit\fP & x)"

.PP
Definition at line \fB100\fP of file \fBvector_unit_2d\&.cpp\fP\&..PP
.nf
101     {
102         scalar_unit::operator=(x);
103         return *this;
104     }
.fi

.SS "\fBvector_unit_2d\fP & scifir::vector_unit_2d::operator= (\fBconst\fP \fBstring\fP & init_vector_2d)"

.PP
Definition at line \fB112\fP of file \fBvector_unit_2d\&.cpp\fP\&..PP
.nf
113     {
114         vector_unit_2d::initialize_from_string(init_vector_2d);
115         return *this;
116     }
.fi

.SS "\fBvector_unit_2d\fP & scifir::vector_unit_2d::operator= (\fBconst\fP \fBvector_unit_2d\fP & x)"

.PP
Definition at line \fB86\fP of file \fBvector_unit_2d\&.cpp\fP\&..PP
.nf
87     {
88         scalar_unit::operator=(x);
89         theta = x\&.theta;
90         return *this;
91     }
.fi

.SS "\fBvector_unit_2d\fP & scifir::vector_unit_2d::operator= (\fBscalar_unit\fP && x)"

.PP
Definition at line \fB106\fP of file \fBvector_unit_2d\&.cpp\fP\&..PP
.nf
107     {
108         scalar_unit::operator=(std::move(x));
109         return *this;
110     }
.fi

.SS "\fBvector_unit_2d\fP & scifir::vector_unit_2d::operator= (\fBvector_unit_2d\fP && x)"

.PP
Definition at line \fB93\fP of file \fBvector_unit_2d\&.cpp\fP\&..PP
.nf
94     {
95         scalar_unit::operator=(std::move(x));
96         theta = std::move(x\&.theta);
97         return *this;
98     }
.fi

.SS "\fBbool\fP scifir::vector_unit_2d::operator== (\fBscifir::vector_unit_2d\fP x) const"

.PP
Definition at line \fB118\fP of file \fBvector_unit_2d\&.cpp\fP\&..PP
.nf
119     {
120         x\&.change_dimensions(*this);
121         if(get_value() == x\&.get_value() and scifir::same_direction(*this,x) and has_dimensions(x))
122         {
123             return true;
124         }
125         else
126         {
127             return false;
128         }
129     }
.fi

.SS "\fBvector_unit_2d\fP scifir::vector_unit_2d::operator^ (\fBconst\fP \fBscalar_unit\fP & x) const"

.PP
Definition at line \fB242\fP of file \fBvector_unit_2d\&.cpp\fP\&..PP
.nf
243     {
244         if(x\&.has_empty_dimensions())
245         {
246             scalar_unit new_unit = scalar_unit::operator^(x);
247             return vector_unit_2d(new_unit, theta);
248         }
249         else
250         {
251             cerr << "Cannot power with as exponent a unit with dimensions" << endl;
252             return vector_unit_2d();
253         }
254     }
.fi

.SS "template<\fBtypename\fP \fBU\fP , \fBtypename\fP  = typename enable_if<is_integer_number<U>::value>::type> \fBvector_unit_2d\fP scifir::vector_unit_2d::operator^ (\fBU\fP x) const\fC [inline]\fP"

.PP
Definition at line \fB143\fP of file \fBvector_unit_2d\&.hpp\fP\&..PP
.nf
144             {
145                 return vector_unit_2d(std::pow(get_value(),x),power_dimensions(get_dimensions(),x),theta);
146             }
.fi

.SS "\fBvoid\fP scifir::vector_unit_2d::point_to (\fBdirection::name\fP x)"

.PP
Definition at line \fB131\fP of file \fBvector_unit_2d\&.cpp\fP\&..PP
.nf
132     {
133         if (x == direction::LEFT)
134         {
135             theta = 180\&.0f;
136         }
137         else if(x == direction::RIGHT)
138         {
139             theta = 0\&.0f;
140         }
141         else if(x == direction::TOP)
142         {
143             theta = 90\&.0f;
144         }
145         else if(x == direction::BOTTOM)
146         {
147             theta = 270\&.0f;
148         }
149         else if(x == direction::LEFT_TOP)
150         {
151             theta = 135\&.0f;
152         }
153         else if(x == direction::RIGHT_TOP)
154         {
155             theta = 45\&.0f;
156         }
157         else if(x == direction::RIGHT_BOTTOM)
158         {
159             theta = 315\&.0f;
160         }
161         else if(x == direction::LEFT_BOTTOM)
162         {
163             theta = 225\&.0f;
164         }
165     }
.fi

.SS "\fBstring\fP scifir::vector_unit_2d::vectorial_custom_display (\fBconst\fP \fBstring\fP & init_dimensions, \fBint\fP number_of_decimals = \fC2\fP) const"

.SS "\fBstring\fP scifir::vector_unit_2d::vectorial_derived_display (\fBint\fP number_of_decimals = \fC2\fP) const"

.SS "\fBstring\fP scifir::vector_unit_2d::vectorial_display (\fBint\fP number_of_decimals = \fC2\fP) const"

.SS "\fBscalar_unit\fP scifir::vector_unit_2d::x_projection () const\fC [inline]\fP"

.PP
Definition at line \fB180\fP of file \fBvector_unit_2d\&.hpp\fP\&..PP
.nf
181             {
182                 return scalar_unit(scalar_unit::value * scifir::cos(theta),get_dimensions());
183             }
.fi

.SS "\fBscalar_unit\fP scifir::vector_unit_2d::y_projection () const\fC [inline]\fP"

.PP
Definition at line \fB185\fP of file \fBvector_unit_2d\&.hpp\fP\&..PP
.nf
186             {
187                 return scalar_unit(scalar_unit::value * scifir::sin(theta),get_dimensions());
188             }
.fi

.SH "Member Data Documentation"
.PP 
.SS "\fBangle\fP scifir::vector_unit_2d::theta"

.PP
Definition at line \fB199\fP of file \fBvector_unit_2d\&.hpp\fP\&.

.SH "Author"
.PP 
Generated automatically by Doxygen for scifir-units from the source code\&.
