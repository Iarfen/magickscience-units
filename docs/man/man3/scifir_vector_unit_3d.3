.TH "scifir::vector_unit_3d" 3 "Sat Jul 13 2024" "Version 2.0.0" "scifir-units" \" -*- nroff -*-
.ad l
.nh
.SH NAME
scifir::vector_unit_3d \- Class that creates a vector unit in 3D\&. The vector is in \fBspherical coordinates\fP with a value and dimensions of the \fBscalar_unit\fP, and an angle theta and another angle phi for his direction\&.  

.SH SYNOPSIS
.br
.PP
.PP
\fC#include <vector_unit_3d\&.hpp>\fP
.PP
Inherits \fBscifir::scalar_unit\fP\&.
.SS "Public Member Functions"

.in +1c
.ti -1c
.RI "\fBvector_unit_3d\fP ()"
.br
.RI "Default constructor\&. The value is set to 0, the dimensions are empty and theta and phi are 0\&. "
.ti -1c
.RI "\fBvector_unit_3d\fP (const \fBvector_unit_3d\fP &x)"
.br
.RI "Copy constructor\&. The member-variables are copied from \fBvector_unit_3d\fP x\&. "
.ti -1c
.RI "\fBvector_unit_3d\fP (\fBvector_unit_3d\fP &&x)"
.br
.RI "Move constructor\&. The member-variables are moved from \fBvector_unit_3d\fP x\&. "
.ti -1c
.RI "\fBvector_unit_3d\fP (float new_value, const string &init_dimensions, float new_theta, float new_phi)"
.br
.RI "The value is new_value, the dimensions are initialized with the initialization string of dimensions, theta is new_theta and phi is new_phi\&. "
.ti -1c
.RI "\fBvector_unit_3d\fP (float new_value, const string &init_dimensions, const \fBangle\fP &new_theta, const \fBangle\fP &new_phi)"
.br
.RI "The value is new_value, the dimensions are initialized with the initialization string of dimensions, theta is new_theta and phi is new_phi\&. "
.ti -1c
.RI "\fBvector_unit_3d\fP (double new_value, const string &init_dimensions, float new_theta, float new_phi)"
.br
.RI "The value is new_value (the double is casted to a float), the dimensions are initialized with the initialization string of dimensions, theta is new_theta and phi is new_phi\&. "
.ti -1c
.RI "\fBvector_unit_3d\fP (double new_value, const string &init_dimensions, const \fBangle\fP &new_theta, const \fBangle\fP &new_phi)"
.br
.RI "The value is new_value (the double is casted to a float), the dimensions are initialized with the initialization string of dimensions, theta is new_theta and phi is new_phi\&. "
.ti -1c
.RI "\fBvector_unit_3d\fP (long double new_value, const string &init_dimensions, float new_theta, float new_phi)"
.br
.RI "The value is new_value (the long double is casted to a float), the dimensions are initialized with the initialization string of dimensions, theta is new_theta and phi is new_phi\&. "
.ti -1c
.RI "\fBvector_unit_3d\fP (long double new_value, const string &init_dimensions, const \fBangle\fP &new_theta, const \fBangle\fP &new_phi)"
.br
.RI "The value is new_value (the long double is casted to a float), the dimensions are initialized with the initialization string of dimensions, theta is new_theta and phi is new_phi\&. "
.ti -1c
.RI "\fBvector_unit_3d\fP (int new_value, const string &init_dimensions, float new_theta, float new_phi)"
.br
.RI "The value is new_value (the int is casted to a float), the dimensions are initialized with the initialization string of dimensions, theta is new_theta and phi is new_phi\&. "
.ti -1c
.RI "\fBvector_unit_3d\fP (int new_value, const string &init_dimensions, const \fBangle\fP &new_theta, const \fBangle\fP &new_phi)"
.br
.RI "The value is new_value (the int is casted to a float), the dimensions are initialized with the initialization string of dimensions, theta is new_theta and phi is new_phi\&. "
.ti -1c
.RI "\fBvector_unit_3d\fP (float new_value, const vector< \fBdimension\fP > &new_dimensions, float new_theta, float new_phi)"
.br
.RI "The value is new_value, the dimensions are initialized with a vector of dimensions, theta is new_theta and phi is new_phi\&. "
.ti -1c
.RI "\fBvector_unit_3d\fP (float new_value, const vector< \fBdimension\fP > &new_dimensions, const \fBangle\fP &new_theta, const \fBangle\fP &new_phi)"
.br
.RI "The value is new_value, the dimensions are initialized with a vector of dimensions, theta is new_theta and phi is new_phi\&. "
.ti -1c
.RI "\fBvector_unit_3d\fP (double new_value, const vector< \fBdimension\fP > &new_dimensions, float new_theta, float new_phi)"
.br
.RI "The value is new_value (the double is casted to a float), the dimensions are initialized with a vector of dimensions, theta is new_theta and phi is new_phi\&. "
.ti -1c
.RI "\fBvector_unit_3d\fP (double new_value, const vector< \fBdimension\fP > &new_dimensions, const \fBangle\fP &new_theta, const \fBangle\fP &new_phi)"
.br
.RI "The value is new_value (the double is casted to a float), the dimensions are initialized with a vector of dimensions, theta is new_theta and phi is new_phi\&. "
.ti -1c
.RI "\fBvector_unit_3d\fP (long double new_value, const vector< \fBdimension\fP > &new_dimensions, float new_theta, float new_phi)"
.br
.RI "The value is new_value (the long double is casted to a float), the dimensions are initialized with a vector of dimensions, theta is new_theta and phi is new_phi\&. "
.ti -1c
.RI "\fBvector_unit_3d\fP (long double new_value, const vector< \fBdimension\fP > &new_dimensions, const \fBangle\fP &new_theta, const \fBangle\fP &new_phi)"
.br
.RI "The value is new_value (the long double is casted to a float), the dimensions are initialized with a vector of dimensions, theta is new_theta and phi is new_phi\&. "
.ti -1c
.RI "\fBvector_unit_3d\fP (int new_value, const vector< \fBdimension\fP > &new_dimensions, float new_theta, float new_phi)"
.br
.RI "The value is new_value (the int is casted to a float), the dimensions are initialized with a vector of dimensions, theta is new_theta and phi is new_phi\&. "
.ti -1c
.RI "\fBvector_unit_3d\fP (int new_value, const vector< \fBdimension\fP > &new_dimensions, const \fBangle\fP &new_theta, const \fBangle\fP &new_phi)"
.br
.RI "The value is new_value (the int is casted to a float), the dimensions are initialized with a vector of dimensions, theta is new_theta and phi is new_phi\&. "
.ti -1c
.RI "\fBvector_unit_3d\fP (const \fBscalar_unit\fP &x, float new_theta, float new_phi)"
.br
.RI "The value and the dimensions are copied from the \fBscalar_unit\fP x, theta is new_theta, phi is new_phi\&. "
.ti -1c
.RI "\fBvector_unit_3d\fP (const \fBscalar_unit\fP &x, const \fBangle\fP &new_theta, const \fBangle\fP &new_phi)"
.br
.RI "The value and the dimensions are copied from the \fBscalar_unit\fP x, theta is new_theta, phi is new_phi\&. "
.ti -1c
.RI "\fBvector_unit_3d\fP (const string &init_scalar, float new_theta, float new_phi)"
.br
.RI "The value and the dimensions are copied from the initialization string of \fBscalar_unit\fP init_scalar, theta is new_theta, phi is new_phi\&. "
.ti -1c
.RI "\fBvector_unit_3d\fP (const string &init_scalar, const \fBangle\fP &new_theta, const \fBangle\fP &new_phi)"
.br
.RI "The value and the dimensions are copied from the initialization string of \fBscalar_unit\fP init_scalar, theta is new_theta, phi is new_phi\&. "
.ti -1c
.RI "\fBvector_unit_3d\fP (const string &init_vector_3d)"
.br
.RI "The value, the dimensions, theta and phi are initialized from the initialization string of \fBvector_unit_3d\fP init_vector_3d\&. "
.ti -1c
.RI "\fBvector_unit_3d\fP & \fBoperator=\fP (const \fBvector_unit_3d\fP &x)"
.br
.RI "Copy assignment\&. The member-variables are copied from the \fBvector_unit_3d\fP x\&. "
.ti -1c
.RI "\fBvector_unit_3d\fP & \fBoperator=\fP (\fBvector_unit_3d\fP &&x)"
.br
.RI "Move assignment\&. The member-variables are moved from the \fBvector_unit_3d\fP x\&. "
.ti -1c
.RI "\fBvector_unit_3d\fP & \fBoperator=\fP (const \fBscalar_unit\fP &x)"
.br
.RI "The value and the dimensions are copied from the \fBscalar_unit\fP x, theta and phi are not changed\&. "
.ti -1c
.RI "\fBvector_unit_3d\fP & \fBoperator=\fP (\fBscalar_unit\fP &&x)"
.br
.RI "The value and the dimensions are moved from the \fBscalar_unit\fP x, theta and phi are not changed\&. "
.ti -1c
.RI "\fBvector_unit_3d\fP & \fBoperator=\fP (const string &init_vector_3d)"
.br
.RI "The value, the dimensions, theta and phi are set from the initialization string init_vector_3d\&. "
.ti -1c
.RI "bool \fBoperator==\fP (\fBvector_unit_3d\fP x) const"
.br
.RI "Comparison operator\&. Two \fBvector_unit_3d\fP are equal if their value, dimensions, theta and phi are the same\&. "
.ti -1c
.RI "void \fBpoint_to\fP (\fBdirection::name\fP x)"
.br
.RI "Theta is set to the direction specified in 3D\&. Possible values are LEFT, RIGHT, TOP, BOTTOM, LEFT_TOP, RIGHT_TOP, RIGHT_BOTTOM, LEFT_BOTTOM, FRONT, BACK, LEFT_FRONT, RIGHT_FRONT, TOP_FRONT, BOTTOM_FRONT, LEFT_BACK, RIGHT_BACK, TOP_BACK, BOTTOM_BACK, LEFT_TOP_FRONT, RIGHT_TOP_FRONT, LEFT_BOTTOM_FRONT, RIGHT_BOTTOM_FRONT, LEFT_TOP_BACK, RIGHT_TOP_BACK, LEFT_BOTTOM_BACK, RIGHT_BOTTOM_BACK\&. "
.ti -1c
.RI "void \fBoperator+=\fP (const \fBvector_unit_3d\fP &x)"
.br
.RI "The \fBvector_unit_3d\fP is summed as vector, in spherical coordinates\&. The addition of vectors is used for the calculation\&. "
.ti -1c
.RI "void \fBoperator\-=\fP (\fBvector_unit_3d\fP x)"
.br
.RI "The \fBvector_unit_3d\fP is substracted as vector, in spherical coordinates\&. The substraction of vectors is used for the calculation\&. "
.ti -1c
.RI "\fBvector_unit_3d\fP \fBoperator+\fP (const \fBvector_unit_3d\fP &x) const"
.br
.RI "Addition of vectors in 3D\&. It creates a new vector as the addition of the other two\&. "
.ti -1c
.RI "\fBvector_unit_3d\fP \fBoperator\-\fP (\fBvector_unit_3d\fP x) const"
.br
.RI "Substraction of vectors in 3D\&. It creates a new vector as the difference of the other two\&. "
.ti -1c
.RI "\fBvector_unit_3d\fP \fBoperator*\fP (const \fBscalar_unit\fP &x) const"
.br
.RI "It creates a new \fBvector_unit_3d\fP scaling a \fBvector_unit_3d\fP by the \fBscalar_unit\fP x\&. "
.ti -1c
.RI "\fBvector_unit_3d\fP \fBoperator/\fP (const \fBscalar_unit\fP &x) const"
.br
.RI "It creates a new \fBvector_unit_3d\fP scaling a \fBvector_unit_3d\fP by the inverse of the \fBscalar_unit\fP x\&. "
.ti -1c
.RI "\fBvector_unit_3d\fP \fBoperator^\fP (const \fBscalar_unit\fP &x) const"
.br
.RI "It powers a vector by a \fBscalar_unit\fP x if that \fBscalar_unit\fP has empty dimensions\&. "
.ti -1c
.RI "template<typename T , typename  = typename enable_if<scifir::is_number<T>::value>::type> \fBvector_unit_3d\fP \fBoperator+\fP (T x) const"
.br
.RI "It creates a new vector as the addition of the numeric type x to the value\&. Theta and phi are not changed\&. "
.ti -1c
.RI "template<typename T , typename  = typename enable_if<scifir::is_number<T>::value>::type> \fBvector_unit_3d\fP \fBoperator\-\fP (T x) const"
.br
.RI "It creates a new vector as the substraction of the numeric type x to the value\&. Theta and phi are not changed\&. "
.ti -1c
.RI "template<typename T , typename  = typename enable_if<scifir::is_number<T>::value>::type> \fBvector_unit_3d\fP \fBoperator*\fP (T x) const"
.br
.RI "It creates a new vector as the multiplication of the numeric type x to the value\&. Theta and phi are not changed\&. "
.ti -1c
.RI "template<typename T , typename  = typename enable_if<scifir::is_number<T>::value>::type> \fBvector_unit_3d\fP \fBoperator/\fP (T x) const"
.br
.RI "It creates a new vector as the division of the value with the numeric type x\&. Theta and phi are not changed\&. "
.ti -1c
.RI "template<typename T , typename  = typename enable_if<is_integer_number<T>::value>::type> \fBvector_unit_3d\fP \fBoperator^\fP (T x) const"
.br
.RI "It creates a new vector as the power of the value with the numeric type x\&. Theta and phi are not changed\&. "
.ti -1c
.RI "template<typename T , typename  = typename enable_if<scifir::is_number<T>::value>::type> void \fBoperator+=\fP (T x)"
.br
.RI "It sums the numeric type x to the value\&. Theta and phi are not changed\&. "
.ti -1c
.RI "template<typename T , typename  = typename enable_if<scifir::is_number<T>::value>::type> void \fBoperator\-=\fP (T x)"
.br
.RI "It substracts the numeric type x to the value\&. Theta and phi are not changed\&. "
.ti -1c
.RI "template<typename T , typename  = typename enable_if<scifir::is_number<T>::value>::type> void \fBoperator*=\fP (T x)"
.br
.RI "It multiplies the numeric type x to the value\&. Theta and phi are not changed\&. "
.ti -1c
.RI "template<typename T , typename  = typename enable_if<scifir::is_number<T>::value>::type> void \fBoperator/=\fP (T x)"
.br
.RI "It divides the numeric type x to the value\&. Theta and phi are not changed\&. "
.ti -1c
.RI "\fBscalar_unit\fP \fBx_projection\fP () const"
.br
.RI "It creates the x projection of the vector, returning it as a \fBscalar_unit\fP of the same dimensions, and the value corresponds to the projection\&. "
.ti -1c
.RI "\fBscalar_unit\fP \fBy_projection\fP () const"
.br
.RI "It creates the y projection of the vector, returning it as a \fBscalar_unit\fP of the same dimensions, and the value corresponds to the projection\&. "
.ti -1c
.RI "\fBscalar_unit\fP \fBz_projection\fP () const"
.br
.RI "It creates the z projection of the vector, returning it as a \fBscalar_unit\fP of the same dimensions, and the value corresponds to the projection\&. "
.ti -1c
.RI "void \fBinvert\fP ()"
.br
.RI "Changes the direction of the vector to the opposite direction\&. It does that by adding 180 degrees to theta and calculating the new phi as '180 - phi'\&. "
.ti -1c
.RI "string \fBvectorial_display\fP (int number_of_decimals=2) const"
.br
.RI "Displays the vector as the string representation of the scalar unit adding also the angle theta and the angle phi\&. "
.ti -1c
.RI "string \fBvectorial_derived_display\fP (int number_of_decimals=2) const"
.br
.RI "Displays the vector as the string representation of the scalar unit adding also the angle theta and the angle phi\&. It displays the dimensions with its derived dimensions\&. "
.ti -1c
.RI "string \fBvectorial_custom_display\fP (const string &init_dimensions, int number_of_decimals=2) const"
.br
.RI "Displays the vector as the string representation of the scalar unit adding also the angle theta and the angle phi\&. It displays the vector in the dimensions specified in the initialization string of dimensions init_dimensions\&. "
.in -1c
.SS "Static Public Member Functions"

.in +1c
.ti -1c
.RI "static \fBvector_unit_3d\fP \fBcartesian_3d\fP (const string &init_dimensions, float new_x, float new_y, float new_z)"
.br
.RI "The dimensions are initialized from the initialization string of dimensions new_dimensions, the cartesian coordinates new_x, new_y and new_z are converted to spherical coordinates and then set the value, theta and phi\&. "
.ti -1c
.RI "static \fBvector_unit_3d\fP \fBcylindrical\fP (const string &init_dimensions, float new_p, \fBangle\fP new_theta, float new_z)"
.br
.RI "The dimensions are initialized from the initialization string of dimensions new_dimensions, the cylindrical coordinates new_p, new_theta and new_z are converted to spherical coordinates and then set the value, theta and phi\&. "
.in -1c
.SS "Public Attributes"

.in +1c
.ti -1c
.RI "\fBangle\fP \fBtheta\fP"
.br
.RI "Angle theta of the vector in 3D space, in spherical coordinates\&. As all angles of scifir-units, it's stored in degrees\&. "
.ti -1c
.RI "\fBangle\fP \fBphi\fP"
.br
.RI "Angle phi of the vector in 3D space, in spherical coordinates\&. As all angles of scifir-units, it's stored in degrees\&. "
.in -1c
.SS "Private Member Functions"

.in +1c
.ti -1c
.RI "void \fBinitialize_from_string\fP (string init_vector_3d)"
.br
.RI "Initializes the member-variables with the initialization string of \fBvector_unit_3d\fP init_vector_3d\&. "
.in -1c
.SS "Additional Inherited Members"
.SH "Detailed Description"
.PP 
Class that creates a vector unit in 3D\&. The vector is in \fBspherical coordinates\fP with a value and dimensions of the \fBscalar_unit\fP, and an angle theta and another angle phi for his direction\&. 
.PP
Definition at line 72 of file vector_unit_3d\&.hpp\&.
.SH "Constructor & Destructor Documentation"
.PP 
.SS "vector_unit_3d::vector_unit_3d ()"

.PP
Default constructor\&. The value is set to 0, the dimensions are empty and theta and phi are 0\&. 
.PP
Definition at line 10 of file vector_unit_3d\&.cpp\&.
.PP
.nf
10                                    : scalar_unit(),theta(),phi()
11     {}
.fi
.SS "vector_unit_3d::vector_unit_3d (const \fBvector_unit_3d\fP & x)"

.PP
Copy constructor\&. The member-variables are copied from \fBvector_unit_3d\fP x\&. 
.PP
Definition at line 13 of file vector_unit_3d\&.cpp\&.
.PP
.nf
13                                                           : scalar_unit(x),theta(x\&.theta),phi(x\&.phi)
14     {}
.fi
.SS "vector_unit_3d::vector_unit_3d (\fBvector_unit_3d\fP && x)"

.PP
Move constructor\&. The member-variables are moved from \fBvector_unit_3d\fP x\&. 
.PP
Definition at line 16 of file vector_unit_3d\&.cpp\&.
.PP
.nf
16                                                      : scalar_unit(std::move(x)),theta(std::move(x\&.theta)),phi(std::move(x\&.phi))
17     {}
.fi
.SS "vector_unit_3d::vector_unit_3d (float new_value, const string & init_dimensions, float new_theta, float new_phi)\fC [explicit]\fP"

.PP
The value is new_value, the dimensions are initialized with the initialization string of dimensions, theta is new_theta and phi is new_phi\&. 
.PP
Definition at line 19 of file vector_unit_3d\&.cpp\&.
.PP
.nf
19                                                                                                               : scalar_unit(new_value,init_dimensions),theta(new_theta),phi(new_phi)
20     {}
.fi
.SS "vector_unit_3d::vector_unit_3d (float new_value, const string & init_dimensions, const \fBangle\fP & new_theta, const \fBangle\fP & new_phi)\fC [explicit]\fP"

.PP
The value is new_value, the dimensions are initialized with the initialization string of dimensions, theta is new_theta and phi is new_phi\&. 
.PP
Definition at line 22 of file vector_unit_3d\&.cpp\&.
.PP
.nf
22                                                                                                                             : scalar_unit(new_value,init_dimensions),theta(new_theta),phi(new_phi)
23     {}
.fi
.SS "vector_unit_3d::vector_unit_3d (double new_value, const string & init_dimensions, float new_theta, float new_phi)\fC [explicit]\fP"

.PP
The value is new_value (the double is casted to a float), the dimensions are initialized with the initialization string of dimensions, theta is new_theta and phi is new_phi\&. 
.PP
Definition at line 25 of file vector_unit_3d\&.cpp\&.
.PP
.nf
25                                                                                                                : scalar_unit(new_value,init_dimensions),theta(new_theta),phi(new_phi)
26     {}
.fi
.SS "vector_unit_3d::vector_unit_3d (double new_value, const string & init_dimensions, const \fBangle\fP & new_theta, const \fBangle\fP & new_phi)\fC [explicit]\fP"

.PP
The value is new_value (the double is casted to a float), the dimensions are initialized with the initialization string of dimensions, theta is new_theta and phi is new_phi\&. 
.PP
Definition at line 28 of file vector_unit_3d\&.cpp\&.
.PP
.nf
28                                                                                                                              : scalar_unit(new_value,init_dimensions),theta(new_theta),phi(new_phi)
29     {}
.fi
.SS "vector_unit_3d::vector_unit_3d (long double new_value, const string & init_dimensions, float new_theta, float new_phi)\fC [explicit]\fP"

.PP
The value is new_value (the long double is casted to a float), the dimensions are initialized with the initialization string of dimensions, theta is new_theta and phi is new_phi\&. 
.PP
Definition at line 31 of file vector_unit_3d\&.cpp\&.
.PP
.nf
31                                                                                                                     : scalar_unit(new_value,init_dimensions),theta(new_theta),phi(new_phi)
32     {}
.fi
.SS "vector_unit_3d::vector_unit_3d (long double new_value, const string & init_dimensions, const \fBangle\fP & new_theta, const \fBangle\fP & new_phi)\fC [explicit]\fP"

.PP
The value is new_value (the long double is casted to a float), the dimensions are initialized with the initialization string of dimensions, theta is new_theta and phi is new_phi\&. 
.PP
Definition at line 34 of file vector_unit_3d\&.cpp\&.
.PP
.nf
34                                                                                                                                   : scalar_unit(new_value,init_dimensions),theta(new_theta),phi(new_phi)
35     {}
.fi
.SS "vector_unit_3d::vector_unit_3d (int new_value, const string & init_dimensions, float new_theta, float new_phi)\fC [explicit]\fP"

.PP
The value is new_value (the int is casted to a float), the dimensions are initialized with the initialization string of dimensions, theta is new_theta and phi is new_phi\&. 
.PP
Definition at line 37 of file vector_unit_3d\&.cpp\&.
.PP
.nf
37                                                                                                             : scalar_unit(new_value,init_dimensions),theta(new_theta),phi(new_phi)
38     {}
.fi
.SS "vector_unit_3d::vector_unit_3d (int new_value, const string & init_dimensions, const \fBangle\fP & new_theta, const \fBangle\fP & new_phi)\fC [explicit]\fP"

.PP
The value is new_value (the int is casted to a float), the dimensions are initialized with the initialization string of dimensions, theta is new_theta and phi is new_phi\&. 
.PP
Definition at line 40 of file vector_unit_3d\&.cpp\&.
.PP
.nf
40                                                                                                                           : scalar_unit(new_value,init_dimensions),theta(new_theta),phi(new_phi)
41     {}
.fi
.SS "vector_unit_3d::vector_unit_3d (float new_value, const vector< \fBdimension\fP > & new_dimensions, float new_theta, float new_phi)\fC [explicit]\fP"

.PP
The value is new_value, the dimensions are initialized with a vector of dimensions, theta is new_theta and phi is new_phi\&. 
.PP
Definition at line 43 of file vector_unit_3d\&.cpp\&.
.PP
.nf
43                                                                                                                         : scalar_unit(new_value,new_dimensions),theta(new_theta),phi(new_phi)
44     {}
.fi
.SS "vector_unit_3d::vector_unit_3d (float new_value, const vector< \fBdimension\fP > & new_dimensions, const \fBangle\fP & new_theta, const \fBangle\fP & new_phi)\fC [explicit]\fP"

.PP
The value is new_value, the dimensions are initialized with a vector of dimensions, theta is new_theta and phi is new_phi\&. 
.PP
Definition at line 46 of file vector_unit_3d\&.cpp\&.
.PP
.nf
46                                                                                                                                       : scalar_unit(new_value,new_dimensions),theta(new_theta),phi(new_phi)
47     {}
.fi
.SS "vector_unit_3d::vector_unit_3d (double new_value, const vector< \fBdimension\fP > & new_dimensions, float new_theta, float new_phi)\fC [explicit]\fP"

.PP
The value is new_value (the double is casted to a float), the dimensions are initialized with a vector of dimensions, theta is new_theta and phi is new_phi\&. 
.PP
Definition at line 49 of file vector_unit_3d\&.cpp\&.
.PP
.nf
49                                                                                                                          : scalar_unit(new_value,new_dimensions),theta(new_theta),phi(new_phi)
50     {}
.fi
.SS "vector_unit_3d::vector_unit_3d (double new_value, const vector< \fBdimension\fP > & new_dimensions, const \fBangle\fP & new_theta, const \fBangle\fP & new_phi)\fC [explicit]\fP"

.PP
The value is new_value (the double is casted to a float), the dimensions are initialized with a vector of dimensions, theta is new_theta and phi is new_phi\&. 
.PP
Definition at line 52 of file vector_unit_3d\&.cpp\&.
.PP
.nf
52                                                                                                                                        : scalar_unit(new_value,new_dimensions),theta(new_theta),phi(new_phi)
53     {}
.fi
.SS "vector_unit_3d::vector_unit_3d (long double new_value, const vector< \fBdimension\fP > & new_dimensions, float new_theta, float new_phi)\fC [explicit]\fP"

.PP
The value is new_value (the long double is casted to a float), the dimensions are initialized with a vector of dimensions, theta is new_theta and phi is new_phi\&. 
.PP
Definition at line 55 of file vector_unit_3d\&.cpp\&.
.PP
.nf
55                                                                                                                               : scalar_unit(new_value,new_dimensions),theta(new_theta),phi(new_phi)
56     {}
.fi
.SS "vector_unit_3d::vector_unit_3d (long double new_value, const vector< \fBdimension\fP > & new_dimensions, const \fBangle\fP & new_theta, const \fBangle\fP & new_phi)\fC [explicit]\fP"

.PP
The value is new_value (the long double is casted to a float), the dimensions are initialized with a vector of dimensions, theta is new_theta and phi is new_phi\&. 
.PP
Definition at line 58 of file vector_unit_3d\&.cpp\&.
.PP
.nf
58                                                                                                                                             : scalar_unit(new_value,new_dimensions),theta(new_theta),phi(new_phi)
59     {}
.fi
.SS "vector_unit_3d::vector_unit_3d (int new_value, const vector< \fBdimension\fP > & new_dimensions, float new_theta, float new_phi)\fC [explicit]\fP"

.PP
The value is new_value (the int is casted to a float), the dimensions are initialized with a vector of dimensions, theta is new_theta and phi is new_phi\&. 
.PP
Definition at line 61 of file vector_unit_3d\&.cpp\&.
.PP
.nf
61                                                                                                                       : scalar_unit(new_value,new_dimensions),theta(new_theta),phi(new_phi)
62     {}
.fi
.SS "vector_unit_3d::vector_unit_3d (int new_value, const vector< \fBdimension\fP > & new_dimensions, const \fBangle\fP & new_theta, const \fBangle\fP & new_phi)\fC [explicit]\fP"

.PP
The value is new_value (the int is casted to a float), the dimensions are initialized with a vector of dimensions, theta is new_theta and phi is new_phi\&. 
.PP
Definition at line 64 of file vector_unit_3d\&.cpp\&.
.PP
.nf
64                                                                                                                                     : scalar_unit(new_value,new_dimensions),theta(new_theta),phi(new_phi)
65     {}
.fi
.SS "vector_unit_3d::vector_unit_3d (const \fBscalar_unit\fP & x, float new_theta, float new_phi)\fC [explicit]\fP"

.PP
The value and the dimensions are copied from the \fBscalar_unit\fP x, theta is new_theta, phi is new_phi\&. 
.PP
Definition at line 67 of file vector_unit_3d\&.cpp\&.
.PP
.nf
67                                                                                      : scalar_unit(x),theta(new_theta),phi(new_phi)
68     {}
.fi
.SS "vector_unit_3d::vector_unit_3d (const \fBscalar_unit\fP & x, const \fBangle\fP & new_theta, const \fBangle\fP & new_phi)\fC [explicit]\fP"

.PP
The value and the dimensions are copied from the \fBscalar_unit\fP x, theta is new_theta, phi is new_phi\&. 
.PP
Definition at line 70 of file vector_unit_3d\&.cpp\&.
.PP
.nf
70                                                                                                    : scalar_unit(x),theta(new_theta),phi(new_phi)
71     {}
.fi
.SS "vector_unit_3d::vector_unit_3d (const string & init_scalar, float new_theta, float new_phi)\fC [explicit]\fP"

.PP
The value and the dimensions are copied from the initialization string of \fBscalar_unit\fP init_scalar, theta is new_theta, phi is new_phi\&. 
.PP
Definition at line 73 of file vector_unit_3d\&.cpp\&.
.PP
.nf
73                                                                                           : scalar_unit(init_scalar),theta(new_theta),phi(new_phi)
74     {}
.fi
.SS "vector_unit_3d::vector_unit_3d (const string & init_scalar, const \fBangle\fP & new_theta, const \fBangle\fP & new_phi)\fC [explicit]\fP"

.PP
The value and the dimensions are copied from the initialization string of \fBscalar_unit\fP init_scalar, theta is new_theta, phi is new_phi\&. 
.PP
Definition at line 76 of file vector_unit_3d\&.cpp\&.
.PP
.nf
76                                                                                                         : scalar_unit(init_scalar),theta(new_theta),phi(new_phi)
77     {}
.fi
.SS "vector_unit_3d::vector_unit_3d (const string & init_vector_3d)\fC [explicit]\fP"

.PP
The value, the dimensions, theta and phi are initialized from the initialization string of \fBvector_unit_3d\fP init_vector_3d\&. 
.PP
Definition at line 79 of file vector_unit_3d\&.cpp\&.
.PP
.nf
79                                                                : vector_unit_3d()
80     {
81         vector_unit_3d::initialize_from_string(init_vector_3d);
82     }
.fi
.SH "Member Function Documentation"
.PP 
.SS "\fBvector_unit_3d\fP vector_unit_3d::cartesian_3d (const string & init_dimensions, float new_x, float new_y, float new_z)\fC [inline]\fP, \fC [static]\fP"

.PP
The dimensions are initialized from the initialization string of dimensions new_dimensions, the cartesian coordinates new_x, new_y and new_z are converted to spherical coordinates and then set the value, theta and phi\&. 
.PP
Definition at line 100 of file vector_unit_3d\&.hpp\&.
.PP
.nf
101             {
102                 float new_value = float(std::sqrt(std::pow(new_x,2) + std::pow(new_y,2) + std::pow(new_z,2)));
103                 float new_theta = scifir::atan_degree(new_y / new_x);
104                 float new_phi = scifir::acos_degree(new_z / new_value);
105                 return vector_unit_3d(new_value,init_dimensions,angle(new_theta),angle(new_phi));
106             }
.fi
.SS "\fBvector_unit_3d\fP vector_unit_3d::cylindrical (const string & init_dimensions, float new_p, \fBangle\fP new_theta, float new_z)\fC [inline]\fP, \fC [static]\fP"

.PP
The dimensions are initialized from the initialization string of dimensions new_dimensions, the cylindrical coordinates new_p, new_theta and new_z are converted to spherical coordinates and then set the value, theta and phi\&. 
.PP
Definition at line 108 of file vector_unit_3d\&.hpp\&.
.PP
.nf
109             {
110                 float new_value = float(std::sqrt(std::pow(new_p,2) + std::pow(new_z,2)));
111                 float new_phi = scifir::atan_degree(new_p / new_z);
112                 return vector_unit_3d(new_value,init_dimensions,new_theta,angle(new_phi));
113             }
.fi
.SS "void vector_unit_3d::initialize_from_string (string init_vector_3d)\fC [private]\fP"

.PP
Initializes the member-variables with the initialization string of \fBvector_unit_3d\fP init_vector_3d\&. 
.PP
Definition at line 414 of file vector_unit_3d\&.cpp\&.
.PP
.nf
415     {
416         vector<string> values;
417         boost::split(values,init_vector_3d,boost::is_any_of(" "));
418         if (values\&.size() == 4)
419         {
420             scalar_unit::initialize_from_string(values[0] + " " + values[1]);
421             theta = angle(values[2]);
422             phi = angle(values[3]);
423         }
424     }
.fi
.SS "void vector_unit_3d::invert ()\fC [inline]\fP"

.PP
Changes the direction of the vector to the opposite direction\&. It does that by adding 180 degrees to theta and calculating the new phi as '180 - phi'\&. 
.PP
Definition at line 220 of file vector_unit_3d\&.hpp\&.
.PP
.nf
221             {
222                 theta\&.invert();
223                 phi = 180\&.0f - phi;
224             }
.fi
.SS "\fBvector_unit_3d\fP vector_unit_3d::operator* (const \fBscalar_unit\fP & x) const"

.PP
It creates a new \fBvector_unit_3d\fP scaling a \fBvector_unit_3d\fP by the \fBscalar_unit\fP x\&. 
.PP
Definition at line 332 of file vector_unit_3d\&.cpp\&.
.PP
.nf
333     {
334         long double new_value = scalar_unit::value * x\&.get_value();
335         vector<dimension> new_dimensions = multiply_dimensions(get_dimensions(), x\&.get_dimensions(),new_value);
336         return vector_unit_3d(float(new_value), new_dimensions, theta, phi);
337     }
.fi
.SS "template<typename T , typename  = typename enable_if<scifir::is_number<T>::value>::type> \fBvector_unit_3d\fP vector_unit_3d::operator* (T x) const\fC [inline]\fP"

.PP
It creates a new vector as the multiplication of the numeric type x to the value\&. Theta and phi are not changed\&. 
.PP
Definition at line 152 of file vector_unit_3d\&.hpp\&.
.PP
.nf
153             {
154                 vector_unit_3d y = *this;
155                 y *= x;
156                 return y;
157             }
.fi
.SS "template<typename T , typename  = typename enable_if<scifir::is_number<T>::value>::type> void vector_unit_3d::operator*= (T x)\fC [inline]\fP"

.PP
It multiplies the numeric type x to the value\&. Theta and phi are not changed\&. 
.PP
Definition at line 186 of file vector_unit_3d\&.hpp\&.
.PP
.nf
187             {
188                 scalar_unit::value *= std::abs(x);
189                 if(x < 0)
190                 {
191                     invert();
192                 }
193             }
.fi
.SS "\fBvector_unit_3d\fP vector_unit_3d::operator+ (const \fBvector_unit_3d\fP & x) const"

.PP
Addition of vectors in 3D\&. It creates a new vector as the addition of the other two\&. 
.PP
Definition at line 295 of file vector_unit_3d\&.cpp\&.
.PP
.nf
296     {
297         if (has_dimensions(x))
298         {
299             float new_x = float(x_projection() + x\&.x_projection());
300             float new_y = float(y_projection() + x\&.y_projection());
301             float new_z = float(z_projection() + x\&.z_projection());
302             float new_value = cartesian_3d_to_spherical_r(new_x, new_y, new_z);
303             angle new_theta = angle(cartesian_3d_to_spherical_theta(new_x, new_y, new_z));
304             angle new_phi = angle(cartesian_3d_to_spherical_phi(new_x, new_y, new_z));
305             return vector_unit_3d(new_value,get_dimensions(),new_theta,new_phi);
306         }
307         else
308         {
309             return vector_unit_3d();
310         }
311     }
.fi
.SS "template<typename T , typename  = typename enable_if<scifir::is_number<T>::value>::type> \fBvector_unit_3d\fP vector_unit_3d::operator+ (T x) const\fC [inline]\fP"

.PP
It creates a new vector as the addition of the numeric type x to the value\&. Theta and phi are not changed\&. 
.PP
Definition at line 136 of file vector_unit_3d\&.hpp\&.
.PP
.nf
137             {
138                 vector_unit_3d y = *this;
139                 y += x;
140                 return y;
141             }
.fi
.SS "void vector_unit_3d::operator+= (const \fBvector_unit_3d\fP & x)"

.PP
The \fBvector_unit_3d\fP is summed as vector, in spherical coordinates\&. The addition of vectors is used for the calculation\&. 
.PP
Definition at line 265 of file vector_unit_3d\&.cpp\&.
.PP
.nf
266     {
267         if(has_dimensions(x))
268         {
269             float new_x = float(x_projection() + x\&.x_projection());
270             float new_y = float(y_projection() + x\&.y_projection());
271             float new_z = float(z_projection() + x\&.z_projection());
272             scalar_unit::value = cartesian_3d_to_spherical_r(new_x, new_y, new_z);
273             theta = angle(cartesian_3d_to_spherical_theta(new_x, new_y, new_z));
274             phi = angle(cartesian_3d_to_spherical_phi(new_x, new_y, new_z));
275         }
276         else
277         {
278             cerr << "Cannot sum vectors of different dimensions" << endl;
279         }
280     }
.fi
.SS "template<typename T , typename  = typename enable_if<scifir::is_number<T>::value>::type> void vector_unit_3d::operator+= (T x)\fC [inline]\fP"

.PP
It sums the numeric type x to the value\&. Theta and phi are not changed\&. 
.PP
Definition at line 174 of file vector_unit_3d\&.hpp\&.
.PP
.nf
175             {
176                 scalar_unit::value += x;
177             }
.fi
.SS "template<typename T , typename  = typename enable_if<scifir::is_number<T>::value>::type> \fBvector_unit_3d\fP vector_unit_3d::operator\- (T x) const\fC [inline]\fP"

.PP
It creates a new vector as the substraction of the numeric type x to the value\&. Theta and phi are not changed\&. 
.PP
Definition at line 144 of file vector_unit_3d\&.hpp\&.
.PP
.nf
145             {
146                 vector_unit_3d y = *this;
147                 y -= x;
148                 return y;
149             }
.fi
.SS "\fBvector_unit_3d\fP vector_unit_3d::operator\- (\fBvector_unit_3d\fP x) const"

.PP
Substraction of vectors in 3D\&. It creates a new vector as the difference of the other two\&. 
.PP
Definition at line 313 of file vector_unit_3d\&.cpp\&.
.PP
.nf
314     {
315         if (has_dimensions(x))
316         {
317             x\&.invert();
318             float new_x = float(x_projection() + x\&.x_projection());
319             float new_y = float(y_projection() + x\&.y_projection());
320             float new_z = float(z_projection() + x\&.z_projection());
321             float new_value = cartesian_3d_to_spherical_r(new_x, new_y, new_z);
322             angle new_theta = angle(cartesian_3d_to_spherical_theta(new_x, new_y, new_z));
323             angle new_phi = angle(cartesian_3d_to_spherical_phi(new_x, new_y, new_z));
324             return vector_unit_3d(new_value,get_dimensions(),new_theta,new_phi);
325         }
326         else
327         {
328             return vector_unit_3d();
329         }
330     }
.fi
.SS "template<typename T , typename  = typename enable_if<scifir::is_number<T>::value>::type> void vector_unit_3d::operator\-= (T x)\fC [inline]\fP"

.PP
It substracts the numeric type x to the value\&. Theta and phi are not changed\&. 
.PP
Definition at line 180 of file vector_unit_3d\&.hpp\&.
.PP
.nf
181             {
182                 scalar_unit::value -= x;
183             }
.fi
.SS "void vector_unit_3d::operator\-= (\fBvector_unit_3d\fP x)"

.PP
The \fBvector_unit_3d\fP is substracted as vector, in spherical coordinates\&. The substraction of vectors is used for the calculation\&. 
.PP
Definition at line 282 of file vector_unit_3d\&.cpp\&.
.PP
.nf
283     {
284         if(has_dimensions(x))
285         {
286             x\&.invert();
287             *this += x;
288         }
289         else
290         {
291             cerr << "Cannot substract vectors of different dimensions" << endl;
292         }
293     }
.fi
.SS "\fBvector_unit_3d\fP vector_unit_3d::operator/ (const \fBscalar_unit\fP & x) const"

.PP
It creates a new \fBvector_unit_3d\fP scaling a \fBvector_unit_3d\fP by the inverse of the \fBscalar_unit\fP x\&. 
.PP
Definition at line 339 of file vector_unit_3d\&.cpp\&.
.PP
.nf
340     {
341         long double new_value = scalar_unit::value / x\&.get_value();
342         vector<dimension> new_dimensions = divide_dimensions(get_dimensions(), x\&.get_dimensions(),new_value);
343         return vector_unit_3d(float(new_value), new_dimensions, theta, phi);
344     }
.fi
.SS "template<typename T , typename  = typename enable_if<scifir::is_number<T>::value>::type> \fBvector_unit_3d\fP vector_unit_3d::operator/ (T x) const\fC [inline]\fP"

.PP
It creates a new vector as the division of the value with the numeric type x\&. Theta and phi are not changed\&. 
.PP
Definition at line 160 of file vector_unit_3d\&.hpp\&.
.PP
.nf
161             {
162                 vector_unit_3d y = *this;
163                 y /= x;
164                 return y;
165             }
.fi
.SS "template<typename T , typename  = typename enable_if<scifir::is_number<T>::value>::type> void vector_unit_3d::operator/= (T x)\fC [inline]\fP"

.PP
It divides the numeric type x to the value\&. Theta and phi are not changed\&. 
.PP
Definition at line 196 of file vector_unit_3d\&.hpp\&.
.PP
.nf
197             {
198                 scalar_unit::value /= std::abs(x);
199                 if(x < 0)
200                 {
201                     invert();
202                 }
203             }
.fi
.SS "\fBvector_unit_3d\fP & vector_unit_3d::operator= (const \fBscalar_unit\fP & x)"

.PP
The value and the dimensions are copied from the \fBscalar_unit\fP x, theta and phi are not changed\&. 
.PP
Definition at line 100 of file vector_unit_3d\&.cpp\&.
.PP
.nf
101     {
102         scalar_unit::operator =(x);
103         return *this;
104     }
.fi
.SS "\fBvector_unit_3d\fP & vector_unit_3d::operator= (const string & init_vector_3d)"

.PP
The value, the dimensions, theta and phi are set from the initialization string init_vector_3d\&. 
.PP
Definition at line 112 of file vector_unit_3d\&.cpp\&.
.PP
.nf
113     {
114         vector_unit_3d::initialize_from_string(init_vector_3d);
115         return *this;
116     }
.fi
.SS "\fBvector_unit_3d\fP & vector_unit_3d::operator= (const \fBvector_unit_3d\fP & x)"

.PP
Copy assignment\&. The member-variables are copied from the \fBvector_unit_3d\fP x\&. 
.PP
Definition at line 84 of file vector_unit_3d\&.cpp\&.
.PP
.nf
85     {
86         scalar_unit::operator =(x);
87         theta = x\&.theta;
88         phi = x\&.phi;
89         return *this;
90     }
.fi
.SS "\fBvector_unit_3d\fP & vector_unit_3d::operator= (\fBscalar_unit\fP && x)"

.PP
The value and the dimensions are moved from the \fBscalar_unit\fP x, theta and phi are not changed\&. 
.PP
Definition at line 106 of file vector_unit_3d\&.cpp\&.
.PP
.nf
107     {
108         scalar_unit::operator =(std::move(x));
109         return *this;
110     }
.fi
.SS "\fBvector_unit_3d\fP & vector_unit_3d::operator= (\fBvector_unit_3d\fP && x)"

.PP
Move assignment\&. The member-variables are moved from the \fBvector_unit_3d\fP x\&. 
.PP
Definition at line 92 of file vector_unit_3d\&.cpp\&.
.PP
.nf
93     {
94         scalar_unit::operator =(std::move(x));
95         theta = std::move(x\&.theta);
96         phi = std::move(x\&.phi);
97         return *this;
98     }
.fi
.SS "bool vector_unit_3d::operator== (\fBscifir::vector_unit_3d\fP x) const"

.PP
Comparison operator\&. Two \fBvector_unit_3d\fP are equal if their value, dimensions, theta and phi are the same\&. 
.PP
Definition at line 118 of file vector_unit_3d\&.cpp\&.
.PP
.nf
119     {
120         x\&.change_dimensions(*this);
121         if(get_value() == x\&.get_value() and scifir::same_direction(*this,x) and has_dimensions(x))
122         {
123             return true;
124         }
125         else
126         {
127             return false;
128         }
129     }
.fi
.SS "\fBvector_unit_3d\fP vector_unit_3d::operator^ (const \fBscalar_unit\fP & x) const"

.PP
It powers a vector by a \fBscalar_unit\fP x if that \fBscalar_unit\fP has empty dimensions\&. 
.PP
Definition at line 346 of file vector_unit_3d\&.cpp\&.
.PP
.nf
347     {
348         if(x\&.has_empty_dimensions())
349         {
350             scalar_unit new_unit = scalar_unit::operator^(x);
351             return vector_unit_3d(new_unit, theta, phi);
352         }
353         else
354         {
355             cerr << "Cannot power with as exponent a unit with dimensions" << endl;
356             return vector_unit_3d();
357         }
358     }
.fi
.SS "template<typename T , typename  = typename enable_if<is_integer_number<T>::value>::type> \fBvector_unit_3d\fP vector_unit_3d::operator^ (T x) const\fC [inline]\fP"

.PP
It creates a new vector as the power of the value with the numeric type x\&. Theta and phi are not changed\&. 
.PP
Definition at line 168 of file vector_unit_3d\&.hpp\&.
.PP
.nf
169             {
170                 return vector_unit_3d(std::pow(get_value(),x),power_dimensions(get_dimensions(),x),theta,phi);
171             }
.fi
.SS "void vector_unit_3d::point_to (\fBdirection::name\fP x)"

.PP
Theta is set to the direction specified in 3D\&. Possible values are LEFT, RIGHT, TOP, BOTTOM, LEFT_TOP, RIGHT_TOP, RIGHT_BOTTOM, LEFT_BOTTOM, FRONT, BACK, LEFT_FRONT, RIGHT_FRONT, TOP_FRONT, BOTTOM_FRONT, LEFT_BACK, RIGHT_BACK, TOP_BACK, BOTTOM_BACK, LEFT_TOP_FRONT, RIGHT_TOP_FRONT, LEFT_BOTTOM_FRONT, RIGHT_BOTTOM_FRONT, LEFT_TOP_BACK, RIGHT_TOP_BACK, LEFT_BOTTOM_BACK, RIGHT_BOTTOM_BACK\&. 
.PP
Definition at line 131 of file vector_unit_3d\&.cpp\&.
.PP
.nf
132     {
133         if (x == direction::LEFT)
134         {
135             theta = 270\&.0f;
136             phi = 90\&.0f;
137         }
138         else if(x == direction::RIGHT)
139         {
140             theta = 90\&.0f;
141             phi = 90\&.0f;
142         }
143         else if(x == direction::TOP)
144         {
145             theta = 0\&.0f;
146             phi = 0\&.0f;
147         }
148         else if(x == direction::BOTTOM)
149         {
150             theta = 0\&.0f;
151             phi = 180\&.0f;
152         }
153         else if(x == direction::LEFT_TOP)
154         {
155             theta = 270\&.0f;
156             phi = 45\&.0f;
157         }
158         else if(x == direction::RIGHT_TOP)
159         {
160             theta = 90\&.0f;
161             phi = 45\&.0f;
162         }
163         else if(x == direction::RIGHT_BOTTOM)
164         {
165             theta = 90\&.0f;
166             phi = 135\&.0f;
167         }
168         else if(x == direction::LEFT_BOTTOM)
169         {
170             theta = 270\&.0f;
171             phi = 135\&.0f;
172         }
173         else if(x == direction::FRONT)
174         {
175             theta = 0\&.0f;
176             phi = 90\&.0f;
177         }
178         else if(x == direction::BACK)
179         {
180             theta = 180\&.0f;
181             phi = 90\&.0f;
182         }
183         else if(x == direction::LEFT_FRONT)
184         {
185             theta = 315\&.0f;
186             phi = 90\&.0f;
187         }
188         else if(x == direction::RIGHT_FRONT)
189         {
190             theta = 45\&.0f;
191             phi = 90\&.0f;
192         }
193         else if(x == direction::TOP_FRONT)
194         {
195             theta = 0\&.0f;
196             phi = 45\&.0f;
197         }
198         else if(x == direction::BOTTOM_FRONT)
199         {
200             theta = 0\&.0f;
201             phi = 135\&.0f;
202         }
203         else if(x == direction::LEFT_BACK)
204         {
205             theta = 225\&.0f;
206             phi = 90\&.0f;
207         }
208         else if(x == direction::RIGHT_BACK)
209         {
210             theta = 135\&.0f;
211             phi = 90\&.0f;
212         }
213         else if(x == direction::TOP_BACK)
214         {
215             theta = 180\&.0f;
216             phi = 45\&.0f;
217         }
218         else if(x == direction::BOTTOM_BACK)
219         {
220             theta = 180\&.0f;
221             phi = 135\&.0f;
222         }
223         else if(x == direction::LEFT_TOP_FRONT)
224         {
225             theta = 315\&.0f;
226             phi = 45\&.0f;
227         }
228         else if(x == direction::RIGHT_TOP_FRONT)
229         {
230             theta = 45\&.0f;
231             phi = 45\&.0f;
232         }
233         else if(x == direction::LEFT_BOTTOM_FRONT)
234         {
235             theta = 315\&.0f;
236             phi = 135\&.0f;
237         }
238         else if(x == direction::RIGHT_BOTTOM_FRONT)
239         {
240             theta = 45\&.0f;
241             phi = 135\&.0f;
242         }
243         else if(x == direction::LEFT_TOP_BACK)
244         {
245             theta = 225\&.0f;
246             phi = 45\&.0f;
247         }
248         else if(x == direction::RIGHT_TOP_BACK)
249         {
250             theta = 135\&.0f;
251             phi = 45\&.0f;
252         }
253         else if(x == direction::LEFT_BOTTOM_BACK)
254         {
255             theta = 225\&.0f;
256             phi = 135\&.0f;
257         }
258         else if(x == direction::RIGHT_BOTTOM_BACK)
259         {
260             theta = 135\&.0f;
261             phi = 135\&.0f;
262         }
263     }
.fi
.SS "string vector_unit_3d::vectorial_custom_display (const string & init_dimensions, int number_of_decimals = \fC2\fP) const"

.PP
Displays the vector as the string representation of the scalar unit adding also the angle theta and the angle phi\&. It displays the vector in the dimensions specified in the initialization string of dimensions init_dimensions\&. 
.SS "string vector_unit_3d::vectorial_derived_display (int number_of_decimals = \fC2\fP) const"

.PP
Displays the vector as the string representation of the scalar unit adding also the angle theta and the angle phi\&. It displays the dimensions with its derived dimensions\&. 
.SS "string vector_unit_3d::vectorial_display (int number_of_decimals = \fC2\fP) const"

.PP
Displays the vector as the string representation of the scalar unit adding also the angle theta and the angle phi\&. 
.SS "\fBscalar_unit\fP vector_unit_3d::x_projection () const\fC [inline]\fP"

.PP
It creates the x projection of the vector, returning it as a \fBscalar_unit\fP of the same dimensions, and the value corresponds to the projection\&. 
.PP
Definition at line 205 of file vector_unit_3d\&.hpp\&.
.PP
.nf
206             {
207                 return scalar_unit(scalar_unit::value * scifir::cos(theta) * scifir::sin(phi),get_dimensions());
208             }
.fi
.SS "\fBscalar_unit\fP vector_unit_3d::y_projection () const\fC [inline]\fP"

.PP
It creates the y projection of the vector, returning it as a \fBscalar_unit\fP of the same dimensions, and the value corresponds to the projection\&. 
.PP
Definition at line 210 of file vector_unit_3d\&.hpp\&.
.PP
.nf
211             {
212                 return scalar_unit(scalar_unit::value * scifir::sin(theta) * scifir::sin(phi),get_dimensions());
213             }
.fi
.SS "\fBscalar_unit\fP vector_unit_3d::z_projection () const\fC [inline]\fP"

.PP
It creates the z projection of the vector, returning it as a \fBscalar_unit\fP of the same dimensions, and the value corresponds to the projection\&. 
.PP
Definition at line 215 of file vector_unit_3d\&.hpp\&.
.PP
.nf
216             {
217                 return scalar_unit(scalar_unit::value * scifir::cos(phi),get_dimensions());
218             }
.fi
.SH "Member Data Documentation"
.PP 
.SS "\fBangle\fP vector_unit_3d::phi"

.PP
Angle phi of the vector in 3D space, in spherical coordinates\&. As all angles of scifir-units, it's stored in degrees\&. 
.PP
Definition at line 231 of file vector_unit_3d\&.hpp\&.
.SS "\fBangle\fP vector_unit_3d::theta"

.PP
Angle theta of the vector in 3D space, in spherical coordinates\&. As all angles of scifir-units, it's stored in degrees\&. 
.PP
Definition at line 230 of file vector_unit_3d\&.hpp\&.

.SH "Author"
.PP 
Generated automatically by Doxygen for scifir-units from the source code\&.
