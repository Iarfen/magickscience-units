.TH "scifir::vector_unit_nd" 3 "Sat Jul 13 2024" "Version 2.0.0" "scifir-units" \" -*- nroff -*-
.ad l
.nh
.SH NAME
scifir::vector_unit_nd
.SH SYNOPSIS
.br
.PP
.PP
\fC#include <vector_unit_nd\&.hpp>\fP
.PP
Inherits \fBscifir::scalar_unit\fP\&.
.SS "Public Member Functions"

.in +1c
.ti -1c
.RI "\fBvector_unit_nd\fP ()"
.br
.RI "Default constructor\&. The value is 0, the dimensions are empty and the angles are empty\&. "
.ti -1c
.RI "\fBvector_unit_nd\fP (const \fBvector_unit_nd\fP &x)"
.br
.RI "Copy constructor\&. The member-variables are copied from \fBvector_unit_nd\fP x\&. "
.ti -1c
.RI "\fBvector_unit_nd\fP (\fBvector_unit_nd\fP &&x)"
.br
.RI "Move constructor\&. The member-variables are moved from \fBvector_unit_nd\fP x\&. "
.ti -1c
.RI "\fBvector_unit_nd\fP (float new_value, const string &init_dimensions)"
.br
.RI "Constructor\&. The value is new_value and the dimensions are initialized with the initialization string of dimensions init_dimensions\&. "
.ti -1c
.RI "\fBvector_unit_nd\fP (float new_value, const string &init_dimensions, const vector< float > &new_angles)"
.br
.RI "Constructor\&. The value is new_value, the dimensions are initialized with the initialization string of dimensions init_dimensions, the angles are constructed with new_angles\&. With 1 angle the vector will be in 2D, with 2 angles it will be in 3D\&. "
.ti -1c
.RI "\fBvector_unit_nd\fP (float new_value, const string &init_dimensions, const vector< \fBangle\fP > &new_angles)"
.br
.RI "Constructor\&. The value is new_value, the dimensions are initialized with the initialization string of dimensions init_dimensions, the angles are new_angles\&. With 1 angle the vector will be in 2D, with 2 angles it will be in 3D\&. "
.ti -1c
.RI "\fBvector_unit_nd\fP (double new_value, const string &init_dimensions)"
.br
.RI "Constructor\&. The value is new_value (the double is casted to a float) and the dimensions are initialized with the initialization string of dimensions init_dimensions\&. "
.ti -1c
.RI "\fBvector_unit_nd\fP (double new_value, const string &init_dimensions, const vector< float > &new_angles)"
.br
.RI "Constructor\&. The value is new_value (the double is casted to a float), the dimensions are initialized with the initialization string of dimensions init_dimensions, the angles are constructed with new_angles\&. With 1 angle the vector will be in 2D, with 2 angles it will be in 3D\&. "
.ti -1c
.RI "\fBvector_unit_nd\fP (double new_value, const string &init_dimensions, const vector< \fBangle\fP > &new_angles)"
.br
.RI "Constructor\&. The value is new_value (the double is casted to a float), the dimensions are initialized with the initialization string of dimensions init_dimensions, the angles are new_angles\&. With 1 angle the vector will be in 2D, with 2 angles it will be in 3D\&. "
.ti -1c
.RI "\fBvector_unit_nd\fP (long double new_value, const string &init_dimensions)"
.br
.RI "Constructor\&. The value is new_value (the long double is casted to a float) and the dimensions are initialized with the initialization string of dimensions init_dimensions\&. "
.ti -1c
.RI "\fBvector_unit_nd\fP (long double new_value, const string &init_dimensions, const vector< float > &new_angles)"
.br
.RI "Constructor\&. The value is new_value (the long double is casted to a float), the dimensions are initialized with the initialization string of dimensions init_dimensions, the angles are constructed with new_angles\&. With 1 angle the vector will be in 2D, with 2 angles it will be in 3D\&. "
.ti -1c
.RI "\fBvector_unit_nd\fP (long double new_value, const string &init_dimensions, const vector< \fBangle\fP > &new_angles)"
.br
.RI "Constructor\&. The value is new_value (the long double is casted to a float), the dimensions are initialized with the initialization string of dimensions init_dimensions, the angles are new_angles\&. With 1 angle the vector will be in 2D, with 2 angles it will be in 3D\&. "
.ti -1c
.RI "\fBvector_unit_nd\fP (int new_value, const string &init_dimensions)"
.br
.RI "Constructor\&. The value is new_value (the int is casted to a float) and the dimensions are initialized with the initialization string of dimensions init_dimensions\&. "
.ti -1c
.RI "\fBvector_unit_nd\fP (int new_value, const string &init_dimensions, const vector< float > &new_angles)"
.br
.RI "Constructor\&. The value is new_value (the int is casted to a float), the dimensions are initialized with the initialization string of dimensions init_dimensions, the angles are constructed with new_angles\&. With 1 angle the vector will be in 2D, with 2 angles it will be in 3D\&. "
.ti -1c
.RI "\fBvector_unit_nd\fP (int new_value, const string &init_dimensions, const vector< \fBangle\fP > &new_angles)"
.br
.RI "Constructor\&. The value is new_value (the int is casted to a float), the dimensions are initialized with the initialization string of dimensions init_dimensions, the angles are new_angles\&. With 1 angle the vector will be in 2D, with 2 angles it will be in 3D\&. "
.ti -1c
.RI "\fBvector_unit_nd\fP (float new_value, const vector< \fBdimension\fP > &new_dimensions)"
.br
.RI "The value is new_value and the dimensions are initialized with a vector of dimensions\&. "
.ti -1c
.RI "\fBvector_unit_nd\fP (float new_value, const vector< \fBdimension\fP > &new_dimensions, const vector< float > &new_angles)"
.br
.RI "The value is new_value, the dimensions are initialized with a vector of dimensions and the angles are constructed with new_angles\&. "
.ti -1c
.RI "\fBvector_unit_nd\fP (float new_value, const vector< \fBdimension\fP > &new_dimensions, const vector< \fBangle\fP > &new_angles)"
.br
.RI "The value is new_value, the dimensions are initialized with a vector of dimensions and the angles are new_angles\&. "
.ti -1c
.RI "\fBvector_unit_nd\fP (double new_value, const vector< \fBdimension\fP > &new_dimensions)"
.br
.RI "The value is new_value (the double is casted to a float) and the dimensions are initialized with a vector of dimensions\&. "
.ti -1c
.RI "\fBvector_unit_nd\fP (double new_value, const vector< \fBdimension\fP > &new_dimensions, const vector< float > &new_angles)"
.br
.RI "The value is new_value (the double is casted to a float), the dimensions are initialized with a vector of dimensions and the angles are constructed with new_angles\&. "
.ti -1c
.RI "\fBvector_unit_nd\fP (double new_value, const vector< \fBdimension\fP > &new_dimensions, const vector< \fBangle\fP > &new_angles)"
.br
.RI "The value is new_value (the double is casted to a float), the dimensions are initialized with a vector of dimensions and the angles are new_angles\&. "
.ti -1c
.RI "\fBvector_unit_nd\fP (long double new_value, const vector< \fBdimension\fP > &new_dimensions)"
.br
.RI "The value is new_value (the long double is casted to a float) and the dimensions are initialized with a vector of dimensions\&. "
.ti -1c
.RI "\fBvector_unit_nd\fP (long double new_value, const vector< \fBdimension\fP > &new_dimensions, const vector< float > &new_angles)"
.br
.RI "The value is new_value (the long double is casted to a float), the dimensions are initialized with a vector of dimensions and the angles are constructed with new_angles\&. "
.ti -1c
.RI "\fBvector_unit_nd\fP (long double new_value, const vector< \fBdimension\fP > &new_dimensions, const vector< \fBangle\fP > &new_angles)"
.br
.RI "The value is new_value (the long double is casted to a float), the dimensions are initialized with a vector of dimensions and the angles are new_angles\&. "
.ti -1c
.RI "\fBvector_unit_nd\fP (int new_value, const vector< \fBdimension\fP > &new_dimensions)"
.br
.RI "The value is new_value (the int is casted to a float) and the dimensions are initialized with a vector of dimensions\&. "
.ti -1c
.RI "\fBvector_unit_nd\fP (int new_value, const vector< \fBdimension\fP > &new_dimensions, const vector< float > &new_angles)"
.br
.RI "The value is new_value (the int is casted to a float), the dimensions are initialized with a vector of dimensions and the angles are constructed with new_angles\&. "
.ti -1c
.RI "\fBvector_unit_nd\fP (int new_value, const vector< \fBdimension\fP > &new_dimensions, const vector< \fBangle\fP > &new_angles)"
.br
.RI "The value is new_value (the int is casted to a float), the dimensions are initialized with a vector of dimensions and the angles are new_angles\&. "
.ti -1c
.RI "\fBvector_unit_nd\fP (const \fBscalar_unit\fP &x)"
.br
.RI "The value and the dimensions are copied from the \fBscalar_unit\fP x, the angles are empty\&. The vector is in 1D\&. "
.ti -1c
.RI "\fBvector_unit_nd\fP (const \fBscalar_unit\fP &x, const vector< float > &new_angles)"
.br
.RI "The value and the dimensions are copied from the \fBscalar_unit\fP x, the angles are constructed with new_angles\&. "
.ti -1c
.RI "\fBvector_unit_nd\fP (const \fBscalar_unit\fP &x, const vector< \fBangle\fP > &new_angles)"
.br
.RI "The value and the dimensions are copied from the \fBscalar_unit\fP x, the angles are new_angles\&. "
.ti -1c
.RI "\fBvector_unit_nd\fP (const string &init_scalar, const vector< float > &new_angles)"
.br
.RI "The value and the dimensions are copied from the initialization string of \fBscalar_unit\fP init_scalar, the angles are constructed with new_angles\&. "
.ti -1c
.RI "\fBvector_unit_nd\fP (const string &init_scalar, const vector< \fBangle\fP > &new_angles)"
.br
.RI "The value and the dimensions are copied from the initialization string of \fBscalar_unit\fP init_scalar, the angles are new_angles\&. "
.ti -1c
.RI "\fBvector_unit_nd\fP (const string &init_vector_nd)"
.br
.RI "The value, the dimensions and all the angles are initialized from the initialization string of \fBvector_unit_nd\fP init_vector_nd\&. "
.ti -1c
.RI "\fBvector_unit_nd\fP & \fBoperator=\fP (const \fBvector_unit_nd\fP &x)"
.br
.RI "Copy assignment\&. The member-variables are copied from \fBvector_unit_nd\fP x\&. "
.ti -1c
.RI "\fBvector_unit_nd\fP & \fBoperator=\fP (\fBvector_unit_nd\fP &&x)"
.br
.RI "Move assignment\&. The member-variables are moved from \fBvector_unit_nd\fP x\&. "
.ti -1c
.RI "\fBvector_unit_nd\fP & \fBoperator=\fP (const \fBscalar_unit\fP &x)"
.br
.RI "The value and the dimensions are copied from the \fBscalar_unit\fP x, the angles are not changed\&. "
.ti -1c
.RI "\fBvector_unit_nd\fP & \fBoperator=\fP (\fBscalar_unit\fP &&x)"
.br
.RI "The value and the dimensions are moved from the \fBscalar_unit\fP x, the angles are not changed\&. "
.ti -1c
.RI "\fBvector_unit_nd\fP & \fBoperator=\fP (const string &init_vector_nd)"
.br
.RI "The value, the dimensions and the angles are set from the initialization string init_vector_nd\&. "
.ti -1c
.RI "bool \fBoperator==\fP (\fBvector_unit_nd\fP x) const"
.br
.RI "Comparison operator\&. Two \fBvector_unit_nd\fP are equal if their value, dimensions and angles are the same\&. "
.ti -1c
.RI "void \fBpoint_to\fP (\fBdirection::name\fP x)"
.br
.RI "The angles are set to the direction specified in 1D, 2D or 3D, depending on the current ND of \fBvector_unit_nd\fP\&. The possible values are LEFT, RIGHT, TOP, BOTTOM, LEFT_TOP, RIGHT_TOP, RIGHT_BOTTOM, LEFT_BOTTOM, FRONT, BACK, LEFT_FRONT, RIGHT_FRONT, TOP_FRONT, BOTTOM_FRONT, LEFT_BACK, RIGHT_BACK, TOP_BACK, BOTTOM_BACK, LEFT_TOP_FRONT, RIGHT_TOP_FRONT, LEFT_BOTTOM_FRONT, RIGHT_BOTTOM_FRONT, LEFT_TOP_BACK, RIGHT_TOP_BACK, LEFT_BOTTOM_BACK, RIGHT_BOTTOM_BACK\&. "
.ti -1c
.RI "void \fBoperator+=\fP (const \fBvector_unit_nd\fP &x)"
.br
.RI "The \fBvector_unit_nd\fP is summed as vector in 2D, 3D, or more coordinates\&. It's summed as scalar in 1D\&. "
.ti -1c
.RI "void \fBoperator\-=\fP (\fBvector_unit_nd\fP x)"
.br
.RI "The \fBvector_unit_nd\fP is substracted as vector in 2D, 3D, or more coordinates\&. It's substracted as scalar in 1D\&. "
.ti -1c
.RI "\fBvector_unit_nd\fP \fBoperator+\fP (const \fBvector_unit_nd\fP &x) const"
.br
.RI "Addition of vectors in 2D, 3D, or more coordinates\&. It's an addition of scalars in 1D\&. It creates a new vector as the addition of the other two\&. "
.ti -1c
.RI "\fBvector_unit_nd\fP \fBoperator\-\fP (\fBvector_unit_nd\fP x) const"
.br
.RI "Substraction of vectors in 2D, 3D, or more coordinates\&. It's a substraction of scalars in 1D\&. It creates a new vector as the difference of the other two\&. "
.ti -1c
.RI "\fBvector_unit_nd\fP \fBoperator*\fP (const \fBscalar_unit\fP &x) const"
.br
.RI "It creates a new \fBvector_unit_nd\fP scaling a \fBvector_unit_nd\fP by the \fBscalar_unit\fP x\&. "
.ti -1c
.RI "\fBvector_unit_nd\fP \fBoperator/\fP (const \fBscalar_unit\fP &x) const"
.br
.RI "It creates a new \fBvector_unit_3d\fP scaling a \fBvector_unit_3d\fP by the inverse of the \fBscalar_unit\fP x\&. "
.ti -1c
.RI "\fBvector_unit_nd\fP \fBoperator^\fP (const \fBscalar_unit\fP &x) const"
.br
.RI "It powers a vector by a \fBscalar_unit\fP x if that \fBscalar_unit\fP has empty dimensions\&. "
.ti -1c
.RI "template<typename T , typename  = typename enable_if<scifir::is_number<T>::value>::type> \fBvector_unit_nd\fP \fBoperator+\fP (T x) const"
.br
.RI "It creates a new vector as the addition of the numeric type x to the value\&. The angles are not changed\&. "
.ti -1c
.RI "template<typename T , typename  = typename enable_if<scifir::is_number<T>::value>::type> \fBvector_unit_nd\fP \fBoperator\-\fP (T x) const"
.br
.RI "It creates a new vector as the substraction of the numeric type x to the value\&. The angles are not changed\&. "
.ti -1c
.RI "template<typename T , typename  = typename enable_if<scifir::is_number<T>::value>::type> \fBvector_unit_nd\fP \fBoperator*\fP (T x) const"
.br
.RI "It creates a new vector as the multiplication of the numeric type x to the value\&. The angles are not changed\&. "
.ti -1c
.RI "template<typename T , typename  = typename enable_if<scifir::is_number<T>::value>::type> \fBvector_unit_nd\fP \fBoperator/\fP (T x) const"
.br
.RI "It creates a new vector as the division of the value with the numeric type x\&. The angles are not changed\&. "
.ti -1c
.RI "template<typename T , typename  = typename enable_if<is_integer_number<T>::value>::type> \fBvector_unit_nd\fP \fBoperator^\fP (T x) const"
.br
.RI "It creates a new vector as the power of the value with the numeric type x\&. The angles are not changed\&. "
.ti -1c
.RI "template<typename T , typename  = typename enable_if<scifir::is_number<T>::value>::type> void \fBoperator+=\fP (T x)"
.br
.RI "It sums the numeric type x to the value\&. The angles are not changed\&. "
.ti -1c
.RI "template<typename T , typename  = typename enable_if<scifir::is_number<T>::value>::type> void \fBoperator\-=\fP (T x)"
.br
.RI "It substracts the numeric type x to the value\&. The angles are not changed\&. "
.ti -1c
.RI "template<typename T , typename  = typename enable_if<scifir::is_number<T>::value>::type> void \fBoperator*=\fP (T x)"
.br
.RI "It multiplies the numeric type x to the value\&. The angles are not changed\&. "
.ti -1c
.RI "template<typename T , typename  = typename enable_if<scifir::is_number<T>::value>::type> void \fBoperator/=\fP (T x)"
.br
.RI "It divides the numeric type x to the value\&. The angles are not changed\&. "
.ti -1c
.RI "bool \fBis_nd\fP (unsigned int i) const"
.br
.RI "Returns true if the vector is at the same number of dimensions as i\&. "
.ti -1c
.RI "int \fBget_nd\fP () const"
.br
.RI "Returns the number of dimensions\&. "
.ti -1c
.RI "\fBscalar_unit\fP \fBn_projection\fP (int i) const"
.br
.RI "Returns the x projection, the y projection or the z projection, depending if i is 1 (it returns x), 2 (it returns y) or 3 (it returns z)\&. "
.ti -1c
.RI "\fBscalar_unit\fP \fBx_projection\fP () const"
.br
.RI "It creates the x projection of the vector, returning it as a \fBscalar_unit\fP of the same dimensions, and the value corresponds to the projection\&. In 1D the projection is the value, in 2D it's in polar coordinates and in 3D it's in spherical coordinates\&. "
.ti -1c
.RI "\fBscalar_unit\fP \fBy_projection\fP () const"
.br
.RI "It creates the y projection of the vector, returning it as a \fBscalar_unit\fP of the same dimensions, and the value corresponds to the projection\&. In 1D this projection doesn't exist, in 2D it's in polar coordinates and in 3D it's in spherical coordinates\&. "
.ti -1c
.RI "\fBscalar_unit\fP \fBz_projection\fP () const"
.br
.RI "It creates the z projection of the vector, returning it as a \fBscalar_unit\fP of the same dimensions, and the value corresponds to the projection\&. In 1D this projection doesn't exist, in 2D it doesn't exist neither and in 3D it's in spherical coordinates\&. "
.ti -1c
.RI "void \fBinvert\fP ()"
.br
.ti -1c
.RI "string \fBvectorial_display\fP (int number_of_decimals=2) const"
.br
.RI "Displays the vector as the string representation of the scalar unit adding also all the angles\&. "
.ti -1c
.RI "string \fBvectorial_derived_display\fP (int number_of_decimals=2) const"
.br
.RI "Displays the vector as the string representation of the scalar unit adding also all the angles\&. It displays the dimensions with its derived dimensions\&. "
.ti -1c
.RI "string \fBvectorial_custom_display\fP (const string &init_dimensions, int number_of_decimals=2) const"
.br
.RI "Displays the vector as the string representation of the scalar unit adding also all the angles\&. It displays the vector in the dimensions specified in the initialization string of dimensions init_dimensions\&. "
.in -1c
.SS "Static Public Member Functions"

.in +1c
.ti -1c
.RI "static \fBvector_unit_nd\fP \fBcartesian_2d\fP (const string &init_dimensions, float new_x, float new_y)"
.br
.RI "The dimensions are initialized from the initialization string of dimensions new_dimensions, the cartesian coordinates new_x and new_y are converted to polar coordinates and then set the value and theta\&. "
.ti -1c
.RI "static \fBvector_unit_nd\fP \fBcartesian_3d\fP (const string &init_dimensions, float new_x, float new_y, float new_z)"
.br
.RI "The dimensions are initialized from the initialization string of dimensions new_dimensions, the cartesian coordinates new_x, new_y and new_z are converted to spherical coordinates and then set the value, theta and phi\&. "
.ti -1c
.RI "static \fBvector_unit_nd\fP \fBcylindrical\fP (const string &init_dimensions, float new_p, \fBangle\fP new_theta, float new_z)"
.br
.RI "The dimensions are initialized from the initialization string of dimensions new_dimensions, the cylindrical coordinates new_p, new_theta and new_z are converted to spherical coordinates and then set the value, theta and phi\&. "
.in -1c
.SS "Public Attributes"

.in +1c
.ti -1c
.RI "vector< \fBangle\fP > \fBangles\fP"
.br
.RI "The angles\&. A total of one angle means the vector is in 2D in polar coordinates, two angles means it's in 3D in spherical coordinates\&. "
.in -1c
.SS "Private Member Functions"

.in +1c
.ti -1c
.RI "void \fBinitialize_from_string\fP (string init_vector_nd)"
.br
.RI "Initializes the member-variables with the initialization string of \fBvector_unit_nd\fP init_vector_nd\&. "
.in -1c
.SS "Additional Inherited Members"
.SH "Detailed Description"
.PP 
Class that creates a vector in ND, which means a variable number of dimensions\&. A \fBvector_unit_nd\fP can change to be in 1D, in 2D or in 3D, but it cannot be in more than one dimension at the same time\&. The member-variables of \fBvector_unit_nd\fP are the value and the vector<dimension> of \fBscalar_unit\fP, and a vector<angle> angles\&. The number of angles is equal to the number of dimensions vector unit has - 1\&. In 1D \fBvector_unit_nd\fP doesn't has angles, in 2D \fBvector_unit_nd\fP is in \fBpolar coordniates\fP an has 1 angle, and in 3D \fBvector_unit_nd\fP is in \fBspherical coordinates\fP an has 2 angles\&. 
.PP
Definition at line 60 of file vector_unit_nd\&.hpp\&.
.SH "Constructor & Destructor Documentation"
.PP 
.SS "vector_unit_nd::vector_unit_nd ()"

.PP
Default constructor\&. The value is 0, the dimensions are empty and the angles are empty\&. 
.PP
Definition at line 10 of file vector_unit_nd\&.cpp\&.
.PP
.nf
10                                    : scalar_unit(),angles()
11     {}
.fi
.SS "vector_unit_nd::vector_unit_nd (const \fBvector_unit_nd\fP & x)"

.PP
Copy constructor\&. The member-variables are copied from \fBvector_unit_nd\fP x\&. 
.PP
Definition at line 13 of file vector_unit_nd\&.cpp\&.
.PP
.nf
13                                                           : scalar_unit(x),angles(x\&.angles)
14     {}
.fi
.SS "vector_unit_nd::vector_unit_nd (\fBvector_unit_nd\fP && x)"

.PP
Move constructor\&. The member-variables are moved from \fBvector_unit_nd\fP x\&. 
.PP
Definition at line 16 of file vector_unit_nd\&.cpp\&.
.PP
.nf
16                                                      : scalar_unit(std::move(x)),angles(std::move(x\&.angles))
17     {}
.fi
.SS "vector_unit_nd::vector_unit_nd (float new_value, const string & init_dimensions)\fC [explicit]\fP"

.PP
Constructor\&. The value is new_value and the dimensions are initialized with the initialization string of dimensions init_dimensions\&. 
.PP
Definition at line 19 of file vector_unit_nd\&.cpp\&.
.PP
.nf
19                                                                                 : scalar_unit(new_value,init_dimensions),angles()
20     {}
.fi
.SS "vector_unit_nd::vector_unit_nd (float new_value, const string & init_dimensions, const vector< float > & new_angles)\fC [explicit]\fP"

.PP
Constructor\&. The value is new_value, the dimensions are initialized with the initialization string of dimensions init_dimensions, the angles are constructed with new_angles\&. With 1 angle the vector will be in 2D, with 2 angles it will be in 3D\&. 
.PP
Definition at line 22 of file vector_unit_nd\&.cpp\&.
.PP
.nf
22                                                                                                                 : scalar_unit(new_value,init_dimensions),angles()
23     {
24         for(const float& x_angle : new_angles)
25         {
26             angles\&.push_back(angle(x_angle));
27         }
28     }
.fi
.SS "vector_unit_nd::vector_unit_nd (float new_value, const string & init_dimensions, const vector< \fBangle\fP > & new_angles)\fC [explicit]\fP"

.PP
Constructor\&. The value is new_value, the dimensions are initialized with the initialization string of dimensions init_dimensions, the angles are new_angles\&. With 1 angle the vector will be in 2D, with 2 angles it will be in 3D\&. 
.PP
Definition at line 30 of file vector_unit_nd\&.cpp\&.
.PP
.nf
30                                                                                                                 : scalar_unit(new_value,init_dimensions),angles(new_angles)
31     {}
.fi
.SS "vector_unit_nd::vector_unit_nd (double new_value, const string & init_dimensions)\fC [explicit]\fP"

.PP
Constructor\&. The value is new_value (the double is casted to a float) and the dimensions are initialized with the initialization string of dimensions init_dimensions\&. 
.PP
Definition at line 33 of file vector_unit_nd\&.cpp\&.
.PP
.nf
33                                                                                  : scalar_unit(new_value,init_dimensions),angles()
34     {}
.fi
.SS "vector_unit_nd::vector_unit_nd (double new_value, const string & init_dimensions, const vector< float > & new_angles)\fC [explicit]\fP"

.PP
Constructor\&. The value is new_value (the double is casted to a float), the dimensions are initialized with the initialization string of dimensions init_dimensions, the angles are constructed with new_angles\&. With 1 angle the vector will be in 2D, with 2 angles it will be in 3D\&. 
.PP
Definition at line 36 of file vector_unit_nd\&.cpp\&.
.PP
.nf
36                                                                                                                  : scalar_unit(new_value,init_dimensions),angles()
37     {
38         for(const float& x_angle : new_angles)
39         {
40             angles\&.push_back(angle(x_angle));
41         }
42     }
.fi
.SS "vector_unit_nd::vector_unit_nd (double new_value, const string & init_dimensions, const vector< \fBangle\fP > & new_angles)\fC [explicit]\fP"

.PP
Constructor\&. The value is new_value (the double is casted to a float), the dimensions are initialized with the initialization string of dimensions init_dimensions, the angles are new_angles\&. With 1 angle the vector will be in 2D, with 2 angles it will be in 3D\&. 
.PP
Definition at line 44 of file vector_unit_nd\&.cpp\&.
.PP
.nf
44                                                                                                                  : scalar_unit(new_value,init_dimensions),angles(new_angles)
45     {}
.fi
.SS "vector_unit_nd::vector_unit_nd (long double new_value, const string & init_dimensions)\fC [explicit]\fP"

.PP
Constructor\&. The value is new_value (the long double is casted to a float) and the dimensions are initialized with the initialization string of dimensions init_dimensions\&. 
.PP
Definition at line 47 of file vector_unit_nd\&.cpp\&.
.PP
.nf
47                                                                                       : scalar_unit(new_value,init_dimensions),angles()
48     {}
.fi
.SS "vector_unit_nd::vector_unit_nd (long double new_value, const string & init_dimensions, const vector< float > & new_angles)\fC [explicit]\fP"

.PP
Constructor\&. The value is new_value (the long double is casted to a float), the dimensions are initialized with the initialization string of dimensions init_dimensions, the angles are constructed with new_angles\&. With 1 angle the vector will be in 2D, with 2 angles it will be in 3D\&. 
.PP
Definition at line 50 of file vector_unit_nd\&.cpp\&.
.PP
.nf
50                                                                                                                       : scalar_unit(new_value,init_dimensions),angles()
51     {
52         for(const float& x_angle : new_angles)
53         {
54             angles\&.push_back(angle(x_angle));
55         }
56     }
.fi
.SS "vector_unit_nd::vector_unit_nd (long double new_value, const string & init_dimensions, const vector< \fBangle\fP > & new_angles)\fC [explicit]\fP"

.PP
Constructor\&. The value is new_value (the long double is casted to a float), the dimensions are initialized with the initialization string of dimensions init_dimensions, the angles are new_angles\&. With 1 angle the vector will be in 2D, with 2 angles it will be in 3D\&. 
.PP
Definition at line 58 of file vector_unit_nd\&.cpp\&.
.PP
.nf
58                                                                                                                       : scalar_unit(new_value,init_dimensions),angles(new_angles)
59     {}
.fi
.SS "vector_unit_nd::vector_unit_nd (int new_value, const string & init_dimensions)\fC [explicit]\fP"

.PP
Constructor\&. The value is new_value (the int is casted to a float) and the dimensions are initialized with the initialization string of dimensions init_dimensions\&. 
.PP
Definition at line 61 of file vector_unit_nd\&.cpp\&.
.PP
.nf
61                                                                               : scalar_unit(new_value,init_dimensions),angles()
62     {}
.fi
.SS "vector_unit_nd::vector_unit_nd (int new_value, const string & init_dimensions, const vector< float > & new_angles)\fC [explicit]\fP"

.PP
Constructor\&. The value is new_value (the int is casted to a float), the dimensions are initialized with the initialization string of dimensions init_dimensions, the angles are constructed with new_angles\&. With 1 angle the vector will be in 2D, with 2 angles it will be in 3D\&. 
.PP
Definition at line 64 of file vector_unit_nd\&.cpp\&.
.PP
.nf
64                                                                                                               : scalar_unit(new_value,init_dimensions),angles()
65     {
66         for(const float& x_angle : new_angles)
67         {
68             angles\&.push_back(angle(x_angle));
69         }
70     }
.fi
.SS "vector_unit_nd::vector_unit_nd (int new_value, const string & init_dimensions, const vector< \fBangle\fP > & new_angles)\fC [explicit]\fP"

.PP
Constructor\&. The value is new_value (the int is casted to a float), the dimensions are initialized with the initialization string of dimensions init_dimensions, the angles are new_angles\&. With 1 angle the vector will be in 2D, with 2 angles it will be in 3D\&. 
.PP
Definition at line 72 of file vector_unit_nd\&.cpp\&.
.PP
.nf
72                                                                                                               : scalar_unit(new_value,init_dimensions),angles(new_angles)
73     {}
.fi
.SS "vector_unit_nd::vector_unit_nd (float new_value, const vector< \fBdimension\fP > & new_dimensions)\fC [explicit]\fP"

.PP
The value is new_value and the dimensions are initialized with a vector of dimensions\&. 
.PP
Definition at line 75 of file vector_unit_nd\&.cpp\&.
.PP
.nf
75                                                                                           : scalar_unit(new_value,new_dimensions),angles()
76     {}
.fi
.SS "vector_unit_nd::vector_unit_nd (float new_value, const vector< \fBdimension\fP > & new_dimensions, const vector< float > & new_angles)\fC [explicit]\fP"

.PP
The value is new_value, the dimensions are initialized with a vector of dimensions and the angles are constructed with new_angles\&. 
.PP
Definition at line 78 of file vector_unit_nd\&.cpp\&.
.PP
.nf
78                                                                                                                           : scalar_unit(new_value,new_dimensions),angles()
79     {
80         for(const float& x_angle : new_angles)
81         {
82             angles\&.push_back(angle(x_angle));
83         }
84     }
.fi
.SS "vector_unit_nd::vector_unit_nd (float new_value, const vector< \fBdimension\fP > & new_dimensions, const vector< \fBangle\fP > & new_angles)\fC [explicit]\fP"

.PP
The value is new_value, the dimensions are initialized with a vector of dimensions and the angles are new_angles\&. 
.PP
Definition at line 86 of file vector_unit_nd\&.cpp\&.
.PP
.nf
86                                                                                                                           : scalar_unit(new_value,new_dimensions),angles(new_angles)
87     {}
.fi
.SS "vector_unit_nd::vector_unit_nd (double new_value, const vector< \fBdimension\fP > & new_dimensions)\fC [explicit]\fP"

.PP
The value is new_value (the double is casted to a float) and the dimensions are initialized with a vector of dimensions\&. 
.PP
Definition at line 89 of file vector_unit_nd\&.cpp\&.
.PP
.nf
89                                                                                            : scalar_unit(new_value,new_dimensions),angles()
90     {}
.fi
.SS "vector_unit_nd::vector_unit_nd (double new_value, const vector< \fBdimension\fP > & new_dimensions, const vector< float > & new_angles)\fC [explicit]\fP"

.PP
The value is new_value (the double is casted to a float), the dimensions are initialized with a vector of dimensions and the angles are constructed with new_angles\&. 
.PP
Definition at line 92 of file vector_unit_nd\&.cpp\&.
.PP
.nf
92                                                                                                                            : scalar_unit(new_value,new_dimensions),angles()
93     {
94         for(const float& x_angle : new_angles)
95         {
96             angles\&.push_back(angle(x_angle));
97         }
98     }
.fi
.SS "vector_unit_nd::vector_unit_nd (double new_value, const vector< \fBdimension\fP > & new_dimensions, const vector< \fBangle\fP > & new_angles)\fC [explicit]\fP"

.PP
The value is new_value (the double is casted to a float), the dimensions are initialized with a vector of dimensions and the angles are new_angles\&. 
.PP
Definition at line 100 of file vector_unit_nd\&.cpp\&.
.PP
.nf
100                                                                                                                            : scalar_unit(new_value,new_dimensions),angles(new_angles)
101     {}
.fi
.SS "vector_unit_nd::vector_unit_nd (long double new_value, const vector< \fBdimension\fP > & new_dimensions)\fC [explicit]\fP"

.PP
The value is new_value (the long double is casted to a float) and the dimensions are initialized with a vector of dimensions\&. 
.PP
Definition at line 103 of file vector_unit_nd\&.cpp\&.
.PP
.nf
103                                                                                                 : scalar_unit(new_value,new_dimensions),angles()
104     {}
.fi
.SS "vector_unit_nd::vector_unit_nd (long double new_value, const vector< \fBdimension\fP > & new_dimensions, const vector< float > & new_angles)\fC [explicit]\fP"

.PP
The value is new_value (the long double is casted to a float), the dimensions are initialized with a vector of dimensions and the angles are constructed with new_angles\&. 
.PP
Definition at line 106 of file vector_unit_nd\&.cpp\&.
.PP
.nf
106                                                                                                                                 : scalar_unit(new_value,new_dimensions),angles()
107     {
108         for(const float& x_angle : new_angles)
109         {
110             angles\&.push_back(angle(x_angle));
111         }
112     }
.fi
.SS "vector_unit_nd::vector_unit_nd (long double new_value, const vector< \fBdimension\fP > & new_dimensions, const vector< \fBangle\fP > & new_angles)\fC [explicit]\fP"

.PP
The value is new_value (the long double is casted to a float), the dimensions are initialized with a vector of dimensions and the angles are new_angles\&. 
.PP
Definition at line 114 of file vector_unit_nd\&.cpp\&.
.PP
.nf
114                                                                                                                                 : scalar_unit(new_value,new_dimensions),angles(new_angles)
115     {}
.fi
.SS "vector_unit_nd::vector_unit_nd (int new_value, const vector< \fBdimension\fP > & new_dimensions)\fC [explicit]\fP"

.PP
The value is new_value (the int is casted to a float) and the dimensions are initialized with a vector of dimensions\&. 
.PP
Definition at line 117 of file vector_unit_nd\&.cpp\&.
.PP
.nf
117                                                                                         : scalar_unit(new_value,new_dimensions),angles()
118     {}
.fi
.SS "vector_unit_nd::vector_unit_nd (int new_value, const vector< \fBdimension\fP > & new_dimensions, const vector< float > & new_angles)\fC [explicit]\fP"

.PP
The value is new_value (the int is casted to a float), the dimensions are initialized with a vector of dimensions and the angles are constructed with new_angles\&. 
.PP
Definition at line 120 of file vector_unit_nd\&.cpp\&.
.PP
.nf
120                                                                                                                         : scalar_unit(new_value,new_dimensions),angles()
121     {
122         for(const float& x_angle : new_angles)
123         {
124             angles\&.push_back(angle(x_angle));
125         }
126     }
.fi
.SS "vector_unit_nd::vector_unit_nd (int new_value, const vector< \fBdimension\fP > & new_dimensions, const vector< \fBangle\fP > & new_angles)\fC [explicit]\fP"

.PP
The value is new_value (the int is casted to a float), the dimensions are initialized with a vector of dimensions and the angles are new_angles\&. 
.PP
Definition at line 128 of file vector_unit_nd\&.cpp\&.
.PP
.nf
128                                                                                                                         : scalar_unit(new_value,new_dimensions),angles(new_angles)
129     {}
.fi
.SS "vector_unit_nd::vector_unit_nd (const \fBscalar_unit\fP & x)\fC [explicit]\fP"

.PP
The value and the dimensions are copied from the \fBscalar_unit\fP x, the angles are empty\&. The vector is in 1D\&. 
.PP
Definition at line 131 of file vector_unit_nd\&.cpp\&.
.PP
.nf
131                                                        : scalar_unit(x),angles()
132     {}
.fi
.SS "vector_unit_nd::vector_unit_nd (const \fBscalar_unit\fP & x, const vector< float > & new_angles)\fC [explicit]\fP"

.PP
The value and the dimensions are copied from the \fBscalar_unit\fP x, the angles are constructed with new_angles\&. 
.PP
Definition at line 134 of file vector_unit_nd\&.cpp\&.
.PP
.nf
134                                                                                        : scalar_unit(x),angles()
135     {
136         for(const float& x_angle : new_angles)
137         {
138             angles\&.push_back(angle(x_angle));
139         }
140     }
.fi
.SS "vector_unit_nd::vector_unit_nd (const \fBscalar_unit\fP & x, const vector< \fBangle\fP > & new_angles)\fC [explicit]\fP"

.PP
The value and the dimensions are copied from the \fBscalar_unit\fP x, the angles are new_angles\&. 
.PP
Definition at line 142 of file vector_unit_nd\&.cpp\&.
.PP
.nf
142                                                                                        : scalar_unit(x),angles(new_angles)
143     {}
.fi
.SS "vector_unit_nd::vector_unit_nd (const string & init_scalar, const vector< float > & new_angles)\fC [explicit]\fP"

.PP
The value and the dimensions are copied from the initialization string of \fBscalar_unit\fP init_scalar, the angles are constructed with new_angles\&. 
.PP
Definition at line 145 of file vector_unit_nd\&.cpp\&.
.PP
.nf
145                                                                                             : scalar_unit(init_scalar),angles()
146     {
147         for(const float& x_angle : new_angles)
148         {
149             angles\&.push_back(angle(x_angle));
150         }
151     }
.fi
.SS "vector_unit_nd::vector_unit_nd (const string & init_scalar, const vector< \fBangle\fP > & new_angles)\fC [explicit]\fP"

.PP
The value and the dimensions are copied from the initialization string of \fBscalar_unit\fP init_scalar, the angles are new_angles\&. 
.PP
Definition at line 153 of file vector_unit_nd\&.cpp\&.
.PP
.nf
153                                                                                             : scalar_unit(init_scalar),angles(new_angles)
154     {}
.fi
.SS "vector_unit_nd::vector_unit_nd (const string & init_vector_nd)\fC [explicit]\fP"

.PP
The value, the dimensions and all the angles are initialized from the initialization string of \fBvector_unit_nd\fP init_vector_nd\&. 
.PP
Definition at line 156 of file vector_unit_nd\&.cpp\&.
.PP
.nf
156                                                                : vector_unit_nd()
157     {
158         vector_unit_nd::initialize_from_string(init_vector_nd);
159     }
.fi
.SH "Member Function Documentation"
.PP 
.SS "\fBvector_unit_nd\fP vector_unit_nd::cartesian_2d (const string & init_dimensions, float new_x, float new_y)\fC [inline]\fP, \fC [static]\fP"

.PP
The dimensions are initialized from the initialization string of dimensions new_dimensions, the cartesian coordinates new_x and new_y are converted to polar coordinates and then set the value and theta\&. 
.PP
Definition at line 97 of file vector_unit_nd\&.hpp\&.
.PP
.nf
98             {
99                 float new_value = float(std::sqrt(std::pow(new_x,2) + std::pow(new_y,2)));
100                 float new_theta = scifir::atan_degree(new_y / new_x);
101                 return vector_unit_nd(new_value,init_dimensions, {angle(new_theta)});
102             }
.fi
.SS "\fBvector_unit_nd\fP vector_unit_nd::cartesian_3d (const string & init_dimensions, float new_x, float new_y, float new_z)\fC [inline]\fP, \fC [static]\fP"

.PP
The dimensions are initialized from the initialization string of dimensions new_dimensions, the cartesian coordinates new_x, new_y and new_z are converted to spherical coordinates and then set the value, theta and phi\&. 
.PP
Definition at line 104 of file vector_unit_nd\&.hpp\&.
.PP
.nf
105             {
106                 float new_value = float(std::sqrt(std::pow(new_x,2) + std::pow(new_y,2) + std::pow(new_z,2)));
107                 float new_theta = scifir::atan_degree(new_y / new_x);
108                 float new_phi = scifir::acos_degree(new_z / new_value);
109                 return vector_unit_nd(new_value,init_dimensions, {angle(new_theta), angle(new_phi)});
110             }
.fi
.SS "\fBvector_unit_nd\fP vector_unit_nd::cylindrical (const string & init_dimensions, float new_p, \fBangle\fP new_theta, float new_z)\fC [inline]\fP, \fC [static]\fP"

.PP
The dimensions are initialized from the initialization string of dimensions new_dimensions, the cylindrical coordinates new_p, new_theta and new_z are converted to spherical coordinates and then set the value, theta and phi\&. 
.PP
Definition at line 112 of file vector_unit_nd\&.hpp\&.
.PP
.nf
113             {
114                 float new_value = float(std::sqrt(std::pow(new_p,2) + std::pow(new_z,2)));
115                 float new_phi = scifir::atan_degree(new_p / new_z);
116                 return vector_unit_nd(new_value,init_dimensions, {new_theta, angle(new_phi)});
117             }
.fi
.SS "int vector_unit_nd::get_nd () const\fC [inline]\fP"

.PP
Returns the number of dimensions\&. 
.PP
Definition at line 214 of file vector_unit_nd\&.hpp\&.
.PP
.nf
215             {
216                 return int(angles\&.size() + 1);
217             }
.fi
.SS "void vector_unit_nd::initialize_from_string (string init_vector_nd)\fC [private]\fP"

.PP
Initializes the member-variables with the initialization string of \fBvector_unit_nd\fP init_vector_nd\&. 
.PP
Definition at line 722 of file vector_unit_nd\&.cpp\&.
.PP
.nf
723     {
724         vector<string> values;
725         boost::split(values,init_vector_nd,boost::is_any_of(" "));
726         scalar_unit::initialize_from_string(values[0] + " " + values[1]);
727         if (values\&.size() > 2)
728         {
729             angles\&.clear();
730             for (unsigned int i = 2; i < values\&.size(); i++)
731             {
732                 angles\&.push_back(angle(values[i]));
733             }
734         }
735     }
.fi
.SS "void scifir::vector_unit_nd::invert ()"

.PP
Definition at line 676 of file vector_unit_nd\&.cpp\&.
.PP
.nf
677     {
678         if (is_nd(2))
679         {
680             angles[0]\&.invert();
681         }
682         else if (is_nd(3))
683         {
684             angles[0]\&.invert();
685             angles[1] = 180\&.0f - angles[1];
686         }
687     }
.fi
.SS "bool vector_unit_nd::is_nd (unsigned int i) const\fC [inline]\fP"

.PP
Returns true if the vector is at the same number of dimensions as i\&. 
.PP
Definition at line 209 of file vector_unit_nd\&.hpp\&.
.PP
.nf
210             {
211                 return angles\&.size() == (i - 1);
212             }
.fi
.SS "\fBscalar_unit\fP vector_unit_nd::n_projection (int i) const"

.PP
Returns the x projection, the y projection or the z projection, depending if i is 1 (it returns x), 2 (it returns y) or 3 (it returns z)\&. 
.PP
Definition at line 596 of file vector_unit_nd\&.cpp\&.
.PP
.nf
597     {
598         if (i == 1)
599         {
600             return x_projection();
601         }
602         else if (i == 2)
603         {
604             return y_projection();
605         }
606         else if (i == 3)
607         {
608             return z_projection();
609         }
610         else
611         {
612             return scalar_unit();
613         }
614     }
.fi
.SS "\fBvector_unit_nd\fP vector_unit_nd::operator* (const \fBscalar_unit\fP & x) const"

.PP
It creates a new \fBvector_unit_nd\fP scaling a \fBvector_unit_nd\fP by the \fBscalar_unit\fP x\&. 
.PP
Definition at line 523 of file vector_unit_nd\&.cpp\&.
.PP
.nf
524     {
525         long double new_value = scalar_unit::value * x\&.get_value();
526         vector<dimension> new_dimensions = multiply_dimensions(get_dimensions(), x\&.get_dimensions(),new_value);
527         if(is_nd(1))
528         {
529             return vector_unit_nd(float(new_value), new_dimensions);
530         }
531         else if(is_nd(2))
532         {
533             return vector_unit_nd(float(new_value), new_dimensions, {angles[0]});
534         }
535         else if(is_nd(3))
536         {
537             return vector_unit_nd(float(new_value), new_dimensions, {angles[0], angles[1]});
538         }
539         else
540         {
541             return vector_unit_nd(float(new_value), new_dimensions, angles);
542         }
543     }
.fi
.SS "template<typename T , typename  = typename enable_if<scifir::is_number<T>::value>::type> \fBvector_unit_nd\fP vector_unit_nd::operator* (T x) const\fC [inline]\fP"

.PP
It creates a new vector as the multiplication of the numeric type x to the value\&. The angles are not changed\&. 
.PP
Definition at line 156 of file vector_unit_nd\&.hpp\&.
.PP
.nf
157             {
158                 vector_unit_nd y = *this;
159                 y *= x;
160                 return y;
161             }
.fi
.SS "template<typename T , typename  = typename enable_if<scifir::is_number<T>::value>::type> void vector_unit_nd::operator*= (T x)\fC [inline]\fP"

.PP
It multiplies the numeric type x to the value\&. The angles are not changed\&. 
.PP
Definition at line 190 of file vector_unit_nd\&.hpp\&.
.PP
.nf
191             {
192                 scalar_unit::value *= std::abs(x);
193                 if(x < 0)
194                 {
195                     invert();
196                 }
197             }
.fi
.SS "\fBvector_unit_nd\fP vector_unit_nd::operator+ (const \fBvector_unit_nd\fP & x) const"

.PP
Addition of vectors in 2D, 3D, or more coordinates\&. It's an addition of scalars in 1D\&. It creates a new vector as the addition of the other two\&. 
.PP
Definition at line 439 of file vector_unit_nd\&.cpp\&.
.PP
.nf
440     {
441         if(has_dimensions(x))
442         {
443             if(is_nd(1))
444             {
445                 float new_value = scalar_unit::value + x\&.get_value();
446                 return vector_unit_nd(new_value,get_dimensions());
447             }
448             else if(is_nd(2))
449             {
450                 float new_x = float(x_projection() + x\&.x_projection());
451                 float new_y = float(y_projection() + x\&.y_projection());
452                 float new_value = cartesian_2d_to_polar_p(new_x, new_y);
453                 vector<angle> new_angles = vector<angle>();
454                 new_angles\&.push_back(cartesian_2d_to_polar_theta(new_x, new_y));
455                 return vector_unit_nd(new_value,get_dimensions(),new_angles);
456             }
457             else if(is_nd(3))
458             {
459                 float new_x = float(x_projection() + x\&.x_projection());
460                 float new_y = float(y_projection() + x\&.y_projection());
461                 float new_z = float(z_projection() + x\&.z_projection());
462                 float new_value = cartesian_3d_to_spherical_r(new_x, new_y, new_z);
463                 vector<angle> new_angles = vector<angle>();
464                 new_angles\&.push_back(angle(cartesian_3d_to_spherical_theta(new_x, new_y, new_z)));
465                 new_angles\&.push_back(angle(cartesian_3d_to_spherical_phi(new_x, new_y, new_z)));
466                 return vector_unit_nd(new_value,get_dimensions(),new_angles);
467             }
468             else
469             {
470                 return vector_unit_nd();
471             }
472         }
473         else
474         {
475             cerr << "Cannot sum vectors of different dimensions" << endl;
476             return vector_unit_nd();
477         }
478     }
.fi
.SS "template<typename T , typename  = typename enable_if<scifir::is_number<T>::value>::type> \fBvector_unit_nd\fP vector_unit_nd::operator+ (T x) const\fC [inline]\fP"

.PP
It creates a new vector as the addition of the numeric type x to the value\&. The angles are not changed\&. 
.PP
Definition at line 140 of file vector_unit_nd\&.hpp\&.
.PP
.nf
141             {
142                 vector_unit_nd y = *this;
143                 y += x;
144                 return y;
145             }
.fi
.SS "void vector_unit_nd::operator+= (const \fBvector_unit_nd\fP & x)"

.PP
The \fBvector_unit_nd\fP is summed as vector in 2D, 3D, or more coordinates\&. It's summed as scalar in 1D\&. 
.PP
Definition at line 395 of file vector_unit_nd\&.cpp\&.
.PP
.nf
396     {
397         if(has_dimensions(x) and get_nd() == x\&.get_nd())
398         {
399             if(is_nd(1))
400             {
401                 scalar_unit::value += x\&.get_value();
402             }
403             else if(is_nd(2))
404             {
405                 float new_x = float(x_projection() + x\&.x_projection());
406                 float new_y = float(y_projection() + x\&.y_projection());
407                 scalar_unit::value = cartesian_2d_to_polar_p(new_x, new_y);
408                 angles[0] = cartesian_2d_to_polar_theta(new_x, new_y);
409             }
410             else if(is_nd(3))
411             {
412                 float new_x = float(x_projection() + x\&.x_projection());
413                 float new_y = float(y_projection() + x\&.y_projection());
414                 float new_z = float(z_projection() + x\&.z_projection());
415                 scalar_unit::value = cartesian_3d_to_spherical_r(new_x, new_y, new_z);
416                 angles[0] = cartesian_3d_to_spherical_theta(new_x, new_y, new_z);
417                 angles[1] = cartesian_3d_to_spherical_phi(new_x, new_y, new_z);
418             }
419         }
420         else
421         {
422             cerr << "Cannot sum vectors of different dimensions" << endl;
423         }
424     }
.fi
.SS "template<typename T , typename  = typename enable_if<scifir::is_number<T>::value>::type> void vector_unit_nd::operator+= (T x)\fC [inline]\fP"

.PP
It sums the numeric type x to the value\&. The angles are not changed\&. 
.PP
Definition at line 178 of file vector_unit_nd\&.hpp\&.
.PP
.nf
179             {
180                 scalar_unit::value += x;
181             }
.fi
.SS "template<typename T , typename  = typename enable_if<scifir::is_number<T>::value>::type> \fBvector_unit_nd\fP vector_unit_nd::operator\- (T x) const\fC [inline]\fP"

.PP
It creates a new vector as the substraction of the numeric type x to the value\&. The angles are not changed\&. 
.PP
Definition at line 148 of file vector_unit_nd\&.hpp\&.
.PP
.nf
149             {
150                 vector_unit_nd y = *this;
151                 y -= x;
152                 return y;
153             }
.fi
.SS "\fBvector_unit_nd\fP vector_unit_nd::operator\- (\fBvector_unit_nd\fP x) const"

.PP
Substraction of vectors in 2D, 3D, or more coordinates\&. It's a substraction of scalars in 1D\&. It creates a new vector as the difference of the other two\&. 
.PP
Definition at line 480 of file vector_unit_nd\&.cpp\&.
.PP
.nf
481     {
482         if(has_dimensions(x))
483         {
484             if(is_nd(1))
485             {
486                 float new_value = scalar_unit::value - x\&.get_value();
487                 return vector_unit_nd(new_value,get_dimensions());
488             }
489             else if(is_nd(2))
490             {
491                 x\&.invert();
492                 float new_x = float(x_projection() + x\&.x_projection());
493                 float new_y = float(y_projection() + x\&.y_projection());
494                 float new_value = cartesian_2d_to_polar_p(new_x, new_y);
495                 vector<angle> new_angles = vector<angle>();
496                 new_angles\&.push_back(cartesian_2d_to_polar_theta(new_x, new_y));
497                 return vector_unit_nd(new_value,get_dimensions(),new_angles);
498             }
499             else if(is_nd(3))
500             {
501                 x\&.invert();
502                 float new_x = float(x_projection() + x\&.x_projection());
503                 float new_y = float(y_projection() + x\&.y_projection());
504                 float new_z = float(z_projection() + x\&.z_projection());
505                 float new_value = cartesian_3d_to_spherical_r(new_x, new_y, new_z);
506                 vector<angle> new_angles = vector<angle>();
507                 new_angles\&.push_back(angle(cartesian_3d_to_spherical_theta(new_x, new_y, new_z)));
508                 new_angles\&.push_back(angle(cartesian_3d_to_spherical_phi(new_x, new_y, new_z)));
509                 return vector_unit_nd(new_value,get_dimensions(),new_angles);
510             }
511             else
512             {
513                 return vector_unit_nd();
514             }
515         }
516         else
517         {
518             cerr << "Cannot sum vectors of different dimensions" << endl;
519             return vector_unit_nd();
520         }
521     }
.fi
.SS "template<typename T , typename  = typename enable_if<scifir::is_number<T>::value>::type> void vector_unit_nd::operator\-= (T x)\fC [inline]\fP"

.PP
It substracts the numeric type x to the value\&. The angles are not changed\&. 
.PP
Definition at line 184 of file vector_unit_nd\&.hpp\&.
.PP
.nf
185             {
186                 scalar_unit::value -= x;
187             }
.fi
.SS "void vector_unit_nd::operator\-= (\fBvector_unit_nd\fP x)"

.PP
The \fBvector_unit_nd\fP is substracted as vector in 2D, 3D, or more coordinates\&. It's substracted as scalar in 1D\&. 
.PP
Definition at line 426 of file vector_unit_nd\&.cpp\&.
.PP
.nf
427     {
428         if(has_dimensions(x))
429         {
430             x\&.invert();
431             *this += x;
432         }
433         else
434         {
435             cerr << "Cannot substract vectors of different dimensions" << endl;
436         }
437     }
.fi
.SS "\fBvector_unit_nd\fP vector_unit_nd::operator/ (const \fBscalar_unit\fP & x) const"

.PP
It creates a new \fBvector_unit_3d\fP scaling a \fBvector_unit_3d\fP by the inverse of the \fBscalar_unit\fP x\&. 
.PP
Definition at line 545 of file vector_unit_nd\&.cpp\&.
.PP
.nf
546     {
547         long double new_value = scalar_unit::value / x\&.get_value();
548         vector<dimension> new_dimensions = divide_dimensions(get_dimensions(), x\&.get_dimensions(),new_value);
549         if(is_nd(1))
550         {
551             return vector_unit_nd(float(new_value), new_dimensions);
552         }
553         else if(is_nd(2))
554         {
555             return vector_unit_nd(float(new_value), new_dimensions, {angles[0]});
556         }
557         else if(is_nd(3))
558         {
559             return vector_unit_nd(float(new_value), new_dimensions, {angles[0], angles[1]});
560         }
561         else
562         {
563             return vector_unit_nd(float(new_value), new_dimensions, angles);
564         }
565     }
.fi
.SS "template<typename T , typename  = typename enable_if<scifir::is_number<T>::value>::type> \fBvector_unit_nd\fP vector_unit_nd::operator/ (T x) const\fC [inline]\fP"

.PP
It creates a new vector as the division of the value with the numeric type x\&. The angles are not changed\&. 
.PP
Definition at line 164 of file vector_unit_nd\&.hpp\&.
.PP
.nf
165             {
166                 vector_unit_nd y = *this;
167                 y /= x;
168                 return y;
169             }
.fi
.SS "template<typename T , typename  = typename enable_if<scifir::is_number<T>::value>::type> void vector_unit_nd::operator/= (T x)\fC [inline]\fP"

.PP
It divides the numeric type x to the value\&. The angles are not changed\&. 
.PP
Definition at line 200 of file vector_unit_nd\&.hpp\&.
.PP
.nf
201             {
202                 scalar_unit::value /= std::abs(x);
203                 if(x < 0)
204                 {
205                     invert();
206                 }
207             }
.fi
.SS "\fBvector_unit_nd\fP & vector_unit_nd::operator= (const \fBscalar_unit\fP & x)"

.PP
The value and the dimensions are copied from the \fBscalar_unit\fP x, the angles are not changed\&. 
.PP
Definition at line 175 of file vector_unit_nd\&.cpp\&.
.PP
.nf
176     {
177         scalar_unit::operator =(x);
178         return *this;
179     }
.fi
.SS "\fBvector_unit_nd\fP & vector_unit_nd::operator= (const string & init_vector_nd)"

.PP
The value, the dimensions and the angles are set from the initialization string init_vector_nd\&. 
.PP
Definition at line 187 of file vector_unit_nd\&.cpp\&.
.PP
.nf
188     {
189         vector_unit_nd::initialize_from_string(init_vector_nd);
190         return *this;
191     }
.fi
.SS "\fBvector_unit_nd\fP & vector_unit_nd::operator= (const \fBvector_unit_nd\fP & x)"

.PP
Copy assignment\&. The member-variables are copied from \fBvector_unit_nd\fP x\&. 
.PP
Definition at line 161 of file vector_unit_nd\&.cpp\&.
.PP
.nf
162     {
163         scalar_unit::operator =(x);
164         angles = x\&.angles;
165         return *this;
166     }
.fi
.SS "\fBvector_unit_nd\fP & vector_unit_nd::operator= (\fBscalar_unit\fP && x)"

.PP
The value and the dimensions are moved from the \fBscalar_unit\fP x, the angles are not changed\&. 
.PP
Definition at line 181 of file vector_unit_nd\&.cpp\&.
.PP
.nf
182     {
183         scalar_unit::operator =(std::move(x));
184         return *this;
185     }
.fi
.SS "\fBvector_unit_nd\fP & vector_unit_nd::operator= (\fBvector_unit_nd\fP && x)"

.PP
Move assignment\&. The member-variables are moved from \fBvector_unit_nd\fP x\&. 
.PP
Definition at line 168 of file vector_unit_nd\&.cpp\&.
.PP
.nf
169     {
170         scalar_unit::operator =(std::move(x));
171         angles = std::move(x\&.angles);
172         return *this;
173     }
.fi
.SS "bool vector_unit_nd::operator== (\fBscifir::vector_unit_nd\fP x) const"

.PP
Comparison operator\&. Two \fBvector_unit_nd\fP are equal if their value, dimensions and angles are the same\&. 
.PP
Definition at line 193 of file vector_unit_nd\&.cpp\&.
.PP
.nf
194     {
195         x\&.change_dimensions(*this);
196         if(get_value() == x\&.get_value() and scifir::same_direction(*this,x) and has_dimensions(x))
197         {
198             return true;
199         }
200         else
201         {
202             return false;
203         }
204     }
.fi
.SS "\fBvector_unit_nd\fP vector_unit_nd::operator^ (const \fBscalar_unit\fP & x) const"

.PP
It powers a vector by a \fBscalar_unit\fP x if that \fBscalar_unit\fP has empty dimensions\&. 
.PP
Definition at line 567 of file vector_unit_nd\&.cpp\&.
.PP
.nf
568     {
569         if(x\&.has_empty_dimensions())
570         {
571             scalar_unit new_unit = scalar_unit::operator^(x);
572             if(is_nd(1))
573             {
574                 return vector_unit_nd(new_unit);
575             }
576             else if(is_nd(2))
577             {
578                 return vector_unit_nd(new_unit, {angles[0]});
579             }
580             else if(is_nd(3))
581             {
582                 return vector_unit_nd(new_unit, {angles[0], angles[1]});
583             }
584             else
585             {
586                 return vector_unit_nd(new_unit, angles);
587             }
588         }
589         else
590         {
591             cerr << "Cannot power with as exponent a unit with dimensions" << endl;
592             return vector_unit_nd();
593         }
594     }
.fi
.SS "template<typename T , typename  = typename enable_if<is_integer_number<T>::value>::type> \fBvector_unit_nd\fP vector_unit_nd::operator^ (T x) const\fC [inline]\fP"

.PP
It creates a new vector as the power of the value with the numeric type x\&. The angles are not changed\&. 
.PP
Definition at line 172 of file vector_unit_nd\&.hpp\&.
.PP
.nf
173             {
174                 return vector_unit_nd(std::pow(get_value(),x),power_dimensions(get_dimensions(),x),angles);
175             }
.fi
.SS "void vector_unit_nd::point_to (\fBdirection::name\fP x)"

.PP
The angles are set to the direction specified in 1D, 2D or 3D, depending on the current ND of \fBvector_unit_nd\fP\&. The possible values are LEFT, RIGHT, TOP, BOTTOM, LEFT_TOP, RIGHT_TOP, RIGHT_BOTTOM, LEFT_BOTTOM, FRONT, BACK, LEFT_FRONT, RIGHT_FRONT, TOP_FRONT, BOTTOM_FRONT, LEFT_BACK, RIGHT_BACK, TOP_BACK, BOTTOM_BACK, LEFT_TOP_FRONT, RIGHT_TOP_FRONT, LEFT_BOTTOM_FRONT, RIGHT_BOTTOM_FRONT, LEFT_TOP_BACK, RIGHT_TOP_BACK, LEFT_BOTTOM_BACK, RIGHT_BOTTOM_BACK\&. 
.PP
Definition at line 206 of file vector_unit_nd\&.cpp\&.
.PP
.nf
207     {
208         if (is_nd(1))
209         {
210             if (x == direction::LEFT)
211             {
212                 if (value > 0)
213                 {
214                     value *= -1;
215                 }
216             }
217             else if(x == direction::RIGHT)
218             {
219                 if (value < 0)
220                 {
221                     value *= -1;
222                 }
223             }
224         }
225         else if (is_nd(2))
226         {
227             if (x == direction::LEFT)
228             {
229                 angles[0] = 180\&.0f;
230             }
231             else if(x == direction::RIGHT)
232             {
233                 angles[0] = 0\&.0f;
234             }
235             else if(x == direction::TOP)
236             {
237                 angles[0] = 90\&.0f;
238             }
239             else if(x == direction::BOTTOM)
240             {
241                 angles[0] = 270\&.0f;
242             }
243             else if(x == direction::LEFT_TOP)
244             {
245                 angles[0] = 135\&.0f;
246             }
247             else if(x == direction::RIGHT_TOP)
248             {
249                 angles[0] = 45\&.0f;
250             }
251             else if(x == direction::RIGHT_BOTTOM)
252             {
253                 angles[0] = 315\&.0f;
254             }
255             else if(x == direction::LEFT_BOTTOM)
256             {
257                 angles[0] = 225\&.0f;
258             }
259         }
260         else if (is_nd(3))
261         {
262             if (x == direction::LEFT)
263             {
264                 angles[0] = 270\&.0f;
265                 angles[1] = 90\&.0f;
266             }
267             else if(x == direction::RIGHT)
268             {
269                 angles[0] = 90\&.0f;
270                 angles[1] = 90\&.0f;
271             }
272             else if(x == direction::TOP)
273             {
274                 angles[0] = 0\&.0f;
275                 angles[1] = 0\&.0f;
276             }
277             else if(x == direction::BOTTOM)
278             {
279                 angles[0] = 0\&.0f;
280                 angles[1] = 180\&.0f;
281             }
282             else if(x == direction::LEFT_TOP)
283             {
284                 angles[0] = 270\&.0f;
285                 angles[1] = 45\&.0f;
286             }
287             else if(x == direction::RIGHT_TOP)
288             {
289                 angles[0] = 90\&.0f;
290                 angles[1] = 45\&.0f;
291             }
292             else if(x == direction::RIGHT_BOTTOM)
293             {
294                 angles[0] = 90\&.0f;
295                 angles[1] = 135\&.0f;
296             }
297             else if(x == direction::LEFT_BOTTOM)
298             {
299                 angles[0] = 270\&.0f;
300                 angles[1] = 135\&.0f;
301             }
302             else if(x == direction::FRONT)
303             {
304                 angles[0] = 0\&.0f;
305                 angles[1] = 90\&.0f;
306             }
307             else if(x == direction::BACK)
308             {
309                 angles[0] = 180\&.0f;
310                 angles[1] = 90\&.0f;
311             }
312             else if(x == direction::LEFT_FRONT)
313             {
314                 angles[0] = 315\&.0f;
315                 angles[1] = 90\&.0f;
316             }
317             else if(x == direction::RIGHT_FRONT)
318             {
319                 angles[0] = 45\&.0f;
320                 angles[1] = 90\&.0f;
321             }
322             else if(x == direction::TOP_FRONT)
323             {
324                 angles[0] = 0\&.0f;
325                 angles[1] = 45\&.0f;
326             }
327             else if(x == direction::BOTTOM_FRONT)
328             {
329                 angles[0] = 0\&.0f;
330                 angles[1] = 135\&.0f;
331             }
332             else if(x == direction::LEFT_BACK)
333             {
334                 angles[0] = 225\&.0f;
335                 angles[1] = 90\&.0f;
336             }
337             else if(x == direction::RIGHT_BACK)
338             {
339                 angles[0] = 135\&.0f;
340                 angles[1] = 90\&.0f;
341             }
342             else if(x == direction::TOP_BACK)
343             {
344                 angles[0] = 180\&.0f;
345                 angles[1] = 45\&.0f;
346             }
347             else if(x == direction::BOTTOM_BACK)
348             {
349                 angles[0] = 180\&.0f;
350                 angles[1] = 135\&.0f;
351             }
352             else if(x == direction::LEFT_TOP_FRONT)
353             {
354                 angles[0] = 315\&.0f;
355                 angles[1] = 45\&.0f;
356             }
357             else if(x == direction::RIGHT_TOP_FRONT)
358             {
359                 angles[0] = 45\&.0f;
360                 angles[1] = 45\&.0f;
361             }
362             else if(x == direction::LEFT_BOTTOM_FRONT)
363             {
364                 angles[0] = 315\&.0f;
365                 angles[1] = 135\&.0f;
366             }
367             else if(x == direction::RIGHT_BOTTOM_FRONT)
368             {
369                 angles[0] = 45\&.0f;
370                 angles[1] = 135\&.0f;
371             }
372             else if(x == direction::LEFT_TOP_BACK)
373             {
374                 angles[0] = 225\&.0f;
375                 angles[1] = 45\&.0f;
376             }
377             else if(x == direction::RIGHT_TOP_BACK)
378             {
379                 angles[0] = 135\&.0f;
380                 angles[1] = 45\&.0f;
381             }
382             else if(x == direction::LEFT_BOTTOM_BACK)
383             {
384                 angles[0] = 225\&.0f;
385                 angles[1] = 135\&.0f;
386             }
387             else if(x == direction::RIGHT_BOTTOM_BACK)
388             {
389                 angles[0] = 135\&.0f;
390                 angles[1] = 135\&.0f;
391             }
392         }
393     }
.fi
.SS "string vector_unit_nd::vectorial_custom_display (const string & init_dimensions, int number_of_decimals = \fC2\fP) const"

.PP
Displays the vector as the string representation of the scalar unit adding also all the angles\&. It displays the vector in the dimensions specified in the initialization string of dimensions init_dimensions\&. 
.PP
Definition at line 711 of file vector_unit_nd\&.cpp\&.
.PP
.nf
712     {
713         ostringstream out;
714         out << custom_display(init_dimensions,number_of_decimals);
715         for (const angle& x_angle : angles)
716         {
717             out << " " << x_angle\&.display(number_of_decimals);
718         }
719         return out\&.str();
720     }
.fi
.SS "string vector_unit_nd::vectorial_derived_display (int number_of_decimals = \fC2\fP) const"

.PP
Displays the vector as the string representation of the scalar unit adding also all the angles\&. It displays the dimensions with its derived dimensions\&. 
.PP
Definition at line 700 of file vector_unit_nd\&.cpp\&.
.PP
.nf
701     {
702         ostringstream out;
703         out << derived_display(number_of_decimals);
704         for (const angle& x_angle : angles)
705         {
706             out << " " << x_angle\&.display(number_of_decimals);
707         }
708         return out\&.str();
709     }
.fi
.SS "string vector_unit_nd::vectorial_display (int number_of_decimals = \fC2\fP) const"

.PP
Displays the vector as the string representation of the scalar unit adding also all the angles\&. 
.PP
Definition at line 689 of file vector_unit_nd\&.cpp\&.
.PP
.nf
690     {
691         ostringstream out;
692         out << display(number_of_decimals);
693         for (const angle& x_angle : angles)
694         {
695             out << " " << x_angle\&.display(number_of_decimals);
696         }
697         return out\&.str();
698     }
.fi
.SS "\fBscalar_unit\fP vector_unit_nd::x_projection () const"

.PP
It creates the x projection of the vector, returning it as a \fBscalar_unit\fP of the same dimensions, and the value corresponds to the projection\&. In 1D the projection is the value, in 2D it's in polar coordinates and in 3D it's in spherical coordinates\&. 
.PP
Definition at line 616 of file vector_unit_nd\&.cpp\&.
.PP
.nf
617     {
618         if (is_nd(1))
619         {
620             return scalar_unit(scalar_unit::value,get_dimensions());
621         }
622         else if (is_nd(2))
623         {
624             return scalar_unit(scalar_unit::value * scifir::cos(angles[0]),get_dimensions());
625         }
626         else if (is_nd(3))
627         {
628             return scalar_unit(scalar_unit::value * scifir::cos(angles[0]) * scifir::sin(angles[1]),get_dimensions());
629         }
630         else
631         {
632             return scalar_unit();
633         }
634     }
.fi
.SS "\fBscalar_unit\fP vector_unit_nd::y_projection () const"

.PP
It creates the y projection of the vector, returning it as a \fBscalar_unit\fP of the same dimensions, and the value corresponds to the projection\&. In 1D this projection doesn't exist, in 2D it's in polar coordinates and in 3D it's in spherical coordinates\&. 
.PP
Definition at line 636 of file vector_unit_nd\&.cpp\&.
.PP
.nf
637     {
638         if (is_nd(1))
639         {
640             return scalar_unit();
641         }
642         else if (is_nd(2))
643         {
644             return scalar_unit(scalar_unit::value * scifir::sin(angles[0]),get_dimensions());
645         }
646         else if (is_nd(3))
647         {
648             return scalar_unit(scalar_unit::value * scifir::sin(angles[0]) * scifir::sin(angles[1]),get_dimensions());
649         }
650         else
651         {
652             return scalar_unit();
653         }
654     }
.fi
.SS "\fBscalar_unit\fP vector_unit_nd::z_projection () const"

.PP
It creates the z projection of the vector, returning it as a \fBscalar_unit\fP of the same dimensions, and the value corresponds to the projection\&. In 1D this projection doesn't exist, in 2D it doesn't exist neither and in 3D it's in spherical coordinates\&. 
.PP
Definition at line 656 of file vector_unit_nd\&.cpp\&.
.PP
.nf
657     {
658         if (is_nd(1))
659         {
660             return scalar_unit();
661         }
662         else if (is_nd(2))
663         {
664             return scalar_unit();
665         }
666         else if (is_nd(3))
667         {
668             return scalar_unit(scalar_unit::value * scifir::cos(angles[1]),get_dimensions());
669         }
670         else
671         {
672             return scalar_unit();
673         }
674     }
.fi
.SH "Member Data Documentation"
.PP 
.SS "vector< \fBangle\fP > vector_unit_nd::angles"

.PP
The angles\&. A total of one angle means the vector is in 2D in polar coordinates, two angles means it's in 3D in spherical coordinates\&. 
.PP
Definition at line 230 of file vector_unit_nd\&.hpp\&.

.SH "Author"
.PP 
Generated automatically by Doxygen for scifir-units from the source code\&.
