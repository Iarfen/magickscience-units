.TH "scifir::vector_unit_nd" 3 "Version 2.0.0" "scifir-units" \" -*- nroff -*-
.ad l
.nh
.SH NAME
scifir::vector_unit_nd
.SH SYNOPSIS
.br
.PP
.PP
\fC#include <vector_unit_nd\&.hpp>\fP
.PP
Inherits \fBscifir::scalar_unit\fP\&.
.SS "Public Member Functions"

.in +1c
.ti -1c
.RI "\fBvector_unit_nd\fP ()"
.br
.ti -1c
.RI "\fBvector_unit_nd\fP (\fBconst\fP \fBvector_unit_nd\fP &x)"
.br
.ti -1c
.RI "\fBvector_unit_nd\fP (\fBvector_unit_nd\fP &&x)"
.br
.ti -1c
.RI "\fBvector_unit_nd\fP (\fBfloat\fP \fBnew_value\fP, \fBconst\fP \fBstring\fP &\fBinit_dimensions\fP)"
.br
.ti -1c
.RI "\fBvector_unit_nd\fP (\fBfloat\fP \fBnew_value\fP, \fBconst\fP \fBstring\fP &\fBinit_dimensions\fP, \fBconst\fP vector< \fBfloat\fP > &\fBnew_angles\fP)"
.br
.ti -1c
.RI "\fBvector_unit_nd\fP (\fBfloat\fP \fBnew_value\fP, \fBconst\fP \fBstring\fP &\fBinit_dimensions\fP, \fBconst\fP vector< \fBangle\fP > &\fBnew_angles\fP)"
.br
.ti -1c
.RI "\fBvector_unit_nd\fP (\fBdouble\fP \fBnew_value\fP, \fBconst\fP \fBstring\fP &\fBinit_dimensions\fP)"
.br
.ti -1c
.RI "\fBvector_unit_nd\fP (\fBdouble\fP \fBnew_value\fP, \fBconst\fP \fBstring\fP &\fBinit_dimensions\fP, \fBconst\fP vector< \fBfloat\fP > &\fBnew_angles\fP)"
.br
.ti -1c
.RI "\fBvector_unit_nd\fP (\fBdouble\fP \fBnew_value\fP, \fBconst\fP \fBstring\fP &\fBinit_dimensions\fP, \fBconst\fP vector< \fBangle\fP > &\fBnew_angles\fP)"
.br
.ti -1c
.RI "\fBvector_unit_nd\fP (\fBlong\fP \fBdouble\fP \fBnew_value\fP, \fBconst\fP \fBstring\fP &\fBinit_dimensions\fP)"
.br
.ti -1c
.RI "\fBvector_unit_nd\fP (\fBlong\fP \fBdouble\fP \fBnew_value\fP, \fBconst\fP \fBstring\fP &\fBinit_dimensions\fP, \fBconst\fP vector< \fBfloat\fP > &\fBnew_angles\fP)"
.br
.ti -1c
.RI "\fBvector_unit_nd\fP (\fBlong\fP \fBdouble\fP \fBnew_value\fP, \fBconst\fP \fBstring\fP &\fBinit_dimensions\fP, \fBconst\fP vector< \fBangle\fP > &\fBnew_angles\fP)"
.br
.ti -1c
.RI "\fBvector_unit_nd\fP (\fBint\fP \fBnew_value\fP, \fBconst\fP \fBstring\fP &\fBinit_dimensions\fP)"
.br
.ti -1c
.RI "\fBvector_unit_nd\fP (\fBint\fP \fBnew_value\fP, \fBconst\fP \fBstring\fP &\fBinit_dimensions\fP, \fBconst\fP vector< \fBfloat\fP > &\fBnew_angles\fP)"
.br
.ti -1c
.RI "\fBvector_unit_nd\fP (\fBint\fP \fBnew_value\fP, \fBconst\fP \fBstring\fP &\fBinit_dimensions\fP, \fBconst\fP vector< \fBangle\fP > &\fBnew_angles\fP)"
.br
.ti -1c
.RI "\fBvector_unit_nd\fP (\fBfloat\fP \fBnew_value\fP, \fBconst\fP vector< \fBdimension\fP > &\fBnew_dimensions\fP)"
.br
.ti -1c
.RI "\fBvector_unit_nd\fP (\fBfloat\fP \fBnew_value\fP, \fBconst\fP vector< \fBdimension\fP > &\fBnew_dimensions\fP, \fBconst\fP vector< \fBfloat\fP > &\fBnew_angles\fP)"
.br
.ti -1c
.RI "\fBvector_unit_nd\fP (\fBfloat\fP \fBnew_value\fP, \fBconst\fP vector< \fBdimension\fP > &\fBnew_dimensions\fP, \fBconst\fP vector< \fBangle\fP > &\fBnew_angles\fP)"
.br
.ti -1c
.RI "\fBvector_unit_nd\fP (\fBdouble\fP \fBnew_value\fP, \fBconst\fP vector< \fBdimension\fP > &\fBnew_dimensions\fP)"
.br
.ti -1c
.RI "\fBvector_unit_nd\fP (\fBdouble\fP \fBnew_value\fP, \fBconst\fP vector< \fBdimension\fP > &\fBnew_dimensions\fP, \fBconst\fP vector< \fBfloat\fP > &\fBnew_angles\fP)"
.br
.ti -1c
.RI "\fBvector_unit_nd\fP (\fBdouble\fP \fBnew_value\fP, \fBconst\fP vector< \fBdimension\fP > &\fBnew_dimensions\fP, \fBconst\fP vector< \fBangle\fP > &\fBnew_angles\fP)"
.br
.ti -1c
.RI "\fBvector_unit_nd\fP (\fBlong\fP \fBdouble\fP \fBnew_value\fP, \fBconst\fP vector< \fBdimension\fP > &\fBnew_dimensions\fP)"
.br
.ti -1c
.RI "\fBvector_unit_nd\fP (\fBlong\fP \fBdouble\fP \fBnew_value\fP, \fBconst\fP vector< \fBdimension\fP > &\fBnew_dimensions\fP, \fBconst\fP vector< \fBfloat\fP > &\fBnew_angles\fP)"
.br
.ti -1c
.RI "\fBvector_unit_nd\fP (\fBlong\fP \fBdouble\fP \fBnew_value\fP, \fBconst\fP vector< \fBdimension\fP > &\fBnew_dimensions\fP, \fBconst\fP vector< \fBangle\fP > &\fBnew_angles\fP)"
.br
.ti -1c
.RI "\fBvector_unit_nd\fP (\fBint\fP \fBnew_value\fP, \fBconst\fP vector< \fBdimension\fP > &\fBnew_dimensions\fP)"
.br
.ti -1c
.RI "\fBvector_unit_nd\fP (\fBint\fP \fBnew_value\fP, \fBconst\fP vector< \fBdimension\fP > &\fBnew_dimensions\fP, \fBconst\fP vector< \fBfloat\fP > &\fBnew_angles\fP)"
.br
.ti -1c
.RI "\fBvector_unit_nd\fP (\fBint\fP \fBnew_value\fP, \fBconst\fP vector< \fBdimension\fP > &\fBnew_dimensions\fP, \fBconst\fP vector< \fBangle\fP > &\fBnew_angles\fP)"
.br
.ti -1c
.RI "\fBvector_unit_nd\fP (\fBconst\fP \fBscalar_unit\fP &x)"
.br
.ti -1c
.RI "\fBvector_unit_nd\fP (\fBconst\fP \fBscalar_unit\fP &x, \fBconst\fP vector< \fBfloat\fP > &\fBnew_angles\fP)"
.br
.ti -1c
.RI "\fBvector_unit_nd\fP (\fBconst\fP \fBscalar_unit\fP &x, \fBconst\fP vector< \fBangle\fP > &\fBnew_angles\fP)"
.br
.ti -1c
.RI "\fBvector_unit_nd\fP (\fBconst\fP \fBstring\fP &\fBinit_scalar\fP, \fBconst\fP vector< \fBfloat\fP > &\fBnew_angles\fP)"
.br
.ti -1c
.RI "\fBvector_unit_nd\fP (\fBconst\fP \fBstring\fP &\fBinit_scalar\fP, \fBconst\fP vector< \fBangle\fP > &\fBnew_angles\fP)"
.br
.ti -1c
.RI "\fBvector_unit_nd\fP (\fBconst\fP \fBstring\fP &\fBinit_vector_nd\fP)"
.br
.ti -1c
.RI "\fBvector_unit_nd\fP & \fBoperator=\fP (\fBconst\fP \fBvector_unit_nd\fP &x)"
.br
.ti -1c
.RI "\fBvector_unit_nd\fP & \fBoperator=\fP (\fBvector_unit_nd\fP &&x)"
.br
.ti -1c
.RI "\fBvector_unit_nd\fP & \fBoperator=\fP (\fBconst\fP \fBscalar_unit\fP &x)"
.br
.ti -1c
.RI "\fBvector_unit_nd\fP & \fBoperator=\fP (\fBscalar_unit\fP &&x)"
.br
.ti -1c
.RI "\fBvector_unit_nd\fP & \fBoperator=\fP (\fBconst\fP \fBstring\fP &\fBinit_vector_nd\fP)"
.br
.ti -1c
.RI "\fBbool\fP \fBoperator==\fP (\fBvector_unit_nd\fP x) \fBconst\fP"
.br
.ti -1c
.RI "\fBvoid\fP \fBpoint_to\fP (\fBdirection::name\fP x)"
.br
.ti -1c
.RI "\fBvoid\fP \fBoperator+=\fP (\fBconst\fP \fBvector_unit_nd\fP &x)"
.br
.ti -1c
.RI "\fBvoid\fP \fBoperator\-=\fP (\fBvector_unit_nd\fP x)"
.br
.ti -1c
.RI "\fBvector_unit_nd\fP \fBoperator+\fP (\fBconst\fP \fBvector_unit_nd\fP &x) \fBconst\fP"
.br
.ti -1c
.RI "\fBvector_unit_nd\fP \fBoperator\-\fP (\fBvector_unit_nd\fP x) \fBconst\fP"
.br
.ti -1c
.RI "\fBvector_unit_nd\fP \fBoperator*\fP (\fBconst\fP \fBscalar_unit\fP &x) \fBconst\fP"
.br
.ti -1c
.RI "\fBvector_unit_nd\fP \fBoperator/\fP (\fBconst\fP \fBscalar_unit\fP &x) \fBconst\fP"
.br
.ti -1c
.RI "\fBvector_unit_nd\fP \fBoperator^\fP (\fBconst\fP \fBscalar_unit\fP &x) \fBconst\fP"
.br
.ti -1c
.RI "template<\fBtypename\fP \fBU\fP , \fBtypename\fP  = typename enable_if<scifir::is_number<U>::value>::type> \fBvector_unit_nd\fP \fBoperator+\fP (\fBU\fP x) \fBconst\fP"
.br
.ti -1c
.RI "template<\fBtypename\fP \fBU\fP , \fBtypename\fP  = typename enable_if<scifir::is_number<U>::value>::type> \fBvector_unit_nd\fP \fBoperator\-\fP (\fBU\fP x) \fBconst\fP"
.br
.ti -1c
.RI "template<\fBtypename\fP \fBU\fP , \fBtypename\fP  = typename enable_if<scifir::is_number<U>::value>::type> \fBvector_unit_nd\fP \fBoperator*\fP (\fBU\fP x) \fBconst\fP"
.br
.ti -1c
.RI "template<\fBtypename\fP \fBU\fP , \fBtypename\fP  = typename enable_if<scifir::is_number<U>::value>::type> \fBvector_unit_nd\fP \fBoperator/\fP (\fBU\fP x) \fBconst\fP"
.br
.ti -1c
.RI "template<\fBtypename\fP \fBU\fP , \fBtypename\fP  = typename enable_if<is_integer_number<U>::value>::type> \fBvector_unit_nd\fP \fBoperator^\fP (\fBU\fP x) \fBconst\fP"
.br
.ti -1c
.RI "template<\fBtypename\fP \fBU\fP , \fBtypename\fP  = typename enable_if<scifir::is_number<U>::value>::type> \fBvoid\fP \fBoperator+=\fP (\fBU\fP x)"
.br
.ti -1c
.RI "template<\fBtypename\fP \fBU\fP , \fBtypename\fP  = typename enable_if<scifir::is_number<U>::value>::type> \fBvoid\fP \fBoperator\-=\fP (\fBU\fP x)"
.br
.ti -1c
.RI "template<\fBtypename\fP \fBU\fP , \fBtypename\fP  = typename enable_if<scifir::is_number<U>::value>::type> \fBvoid\fP \fBoperator*=\fP (\fBU\fP x)"
.br
.ti -1c
.RI "template<\fBtypename\fP \fBU\fP , \fBtypename\fP  = typename enable_if<scifir::is_number<U>::value>::type> \fBvoid\fP \fBoperator/=\fP (\fBU\fP x)"
.br
.ti -1c
.RI "\fBbool\fP \fBis_nd\fP (\fBunsigned\fP \fBint\fP \fBi\fP) \fBconst\fP"
.br
.ti -1c
.RI "\fBint\fP \fBget_nd\fP () \fBconst\fP"
.br
.ti -1c
.RI "\fBscalar_unit\fP \fBn_projection\fP (\fBint\fP \fBi\fP) \fBconst\fP"
.br
.ti -1c
.RI "\fBscalar_unit\fP \fBx_projection\fP () \fBconst\fP"
.br
.ti -1c
.RI "\fBscalar_unit\fP \fBy_projection\fP () \fBconst\fP"
.br
.ti -1c
.RI "\fBscalar_unit\fP \fBz_projection\fP () \fBconst\fP"
.br
.ti -1c
.RI "\fBvoid\fP \fBinvert\fP ()"
.br
.ti -1c
.RI "\fBstring\fP \fBvectorial_display\fP (\fBint\fP \fBnumber_of_decimals\fP=2) \fBconst\fP"
.br
.ti -1c
.RI "\fBstring\fP \fBvectorial_derived_display\fP (\fBint\fP \fBnumber_of_decimals\fP=2) \fBconst\fP"
.br
.ti -1c
.RI "\fBstring\fP \fBvectorial_custom_display\fP (\fBconst\fP \fBstring\fP &\fBinit_dimensions\fP, \fBint\fP \fBnumber_of_decimals\fP=2) \fBconst\fP"
.br
.in -1c

Public Member Functions inherited from \fBscifir::scalar_unit\fP
.in +1c
.ti -1c
.RI "\fBscalar_unit\fP ()"
.br
.RI "Default constructor, the value is 0 and the dimensions are empty\&. "
.ti -1c
.RI "\fBscalar_unit\fP (\fBconst\fP \fBscalar_unit\fP &x)"
.br
.RI "Copy constructor, copies the value and the dimensions\&. "
.ti -1c
.RI "\fBscalar_unit\fP (\fBscalar_unit\fP &&x)"
.br
.RI "Move constructor, moves the value and the dimensions\&. "
.ti -1c
.RI "\fBscalar_unit\fP (\fBfloat\fP \fBnew_value\fP, \fBconst\fP \fBstring\fP &\fBinit_dimensions\fP)"
.br
.RI "Creates a new \fBscalar_unit\fP with the value and with the dimensions specified in the string\&. "
.ti -1c
.RI "\fBscalar_unit\fP (\fBdouble\fP \fBnew_value\fP, \fBconst\fP \fBstring\fP &\fBinit_dimensions\fP)"
.br
.RI "Creates a new \fBscalar_unit\fP, the double is casted to a float\&. "
.ti -1c
.RI "\fBscalar_unit\fP (\fBlong\fP \fBdouble\fP \fBnew_value\fP, \fBconst\fP \fBstring\fP &\fBinit_dimensions\fP)"
.br
.RI "Creates a new \fBscalar_unit\fP, the long double is casted to a float\&. "
.ti -1c
.RI "\fBscalar_unit\fP (\fBint\fP \fBnew_value\fP, \fBconst\fP \fBstring\fP &\fBinit_dimensions\fP)"
.br
.RI "Creates a new \fBscalar_unit\fP, the int is casted to a float\&. "
.ti -1c
.RI "\fBscalar_unit\fP (\fBfloat\fP \fBnew_value\fP, \fBconst\fP vector< \fBdimension\fP > &\fBnew_dimensions\fP)"
.br
.RI "Creates a new \fBscalar_unit\fP with the value given and copying the dimensions\&. "
.ti -1c
.RI "\fBscalar_unit\fP (\fBdouble\fP \fBnew_value\fP, \fBconst\fP vector< \fBdimension\fP > &\fBnew_dimensions\fP)"
.br
.RI "Creates a new \fBscalar_unit\fP, the double is casted to a float, the dimensions are copied\&. "
.ti -1c
.RI "\fBscalar_unit\fP (\fBlong\fP \fBdouble\fP \fBnew_value\fP, \fBconst\fP vector< \fBdimension\fP > &\fBnew_dimensions\fP)"
.br
.RI "Creates a new \fBscalar_unit\fP, the long double is casted to a float, the dimensions are copied\&. "
.ti -1c
.RI "\fBscalar_unit\fP (\fBint\fP \fBnew_value\fP, \fBconst\fP vector< \fBdimension\fP > &\fBnew_dimensions\fP)"
.br
.RI "Creates a new \fBscalar_unit\fP, the int is casted to a float, the dimensions are copied\&. "
.ti -1c
.RI "\fBscalar_unit\fP (\fBconst\fP \fBstring\fP &\fBinit_scalar\fP)"
.br
.RI "Creates a new \fBscalar_unit\fP, the initialization string specifies both the value and the dimensions\&. "
.ti -1c
.RI "\fBscalar_unit\fP & \fBoperator=\fP (\fBconst\fP \fBscalar_unit\fP &x)"
.br
.RI "Copy assignment, it assigns a copy of the \fBscalar_unit\fP\&. "
.ti -1c
.RI "\fBscalar_unit\fP & \fBoperator=\fP (\fBscalar_unit\fP &&x)"
.br
.RI "Move assignment, it moves the \fBscalar_unit\fP\&. "
.ti -1c
.RI "\fBscalar_unit\fP & \fBoperator=\fP (\fBconst\fP \fBstring\fP &\fBinit_scalar\fP)"
.br
.RI "Assignment with an initialization string, the value and the dimensions are both specified\&. "
.ti -1c
.RI "\fBoperator float\fP () \fBconst\fP"
.br
.RI "Cast the \fBscalar_unit\fP to their float equivalent, it discards the dimensions and copies the value to a float\&. "
.ti -1c
.RI "\fBbool\fP \fBoperator==\fP (\fBscalar_unit\fP x) \fBconst\fP"
.br
.RI "Comparison operator, two \fBscalar_unit\fP classes are considered equivalent if they have the same value given the same dimensions\&. "
.ti -1c
.RI "\fBscalar_unit\fP \fBoperator+\fP (\fBscalar_unit\fP x) \fBconst\fP"
.br
.RI "Addition operator, it sums two \fBscalar_unit\fP classes, their dimensions are changed to be equal first\&. If the basic dimensions are different, it returns an empty \fBscalar_unit\fP class\&. "
.ti -1c
.RI "\fBscalar_unit\fP \fBoperator\-\fP (\fBscalar_unit\fP x) \fBconst\fP"
.br
.RI "Substraction operator, it substracts one \fBscalar_unit\fP from the other, their dimensions are changed to be equal first\&. If the basic dimensions are different, it returns an empty \fBscalar_unit\fP class\&. "
.ti -1c
.RI "\fBscalar_unit\fP \fBoperator*\fP (\fBscalar_unit\fP x) \fBconst\fP"
.br
.RI "Multiplication operator, it multiplies two \fBscalar_unit\fP classes, their dimensions are also multiplied\&. "
.ti -1c
.RI "\fBscalar_unit\fP \fBoperator/\fP (\fBscalar_unit\fP x) \fBconst\fP"
.br
.RI "Division operator, it divides one \fBscalar_unit\fP class with the other, their dimensions are also divided\&. "
.ti -1c
.RI "\fBscalar_unit\fP \fBoperator^\fP (\fBconst\fP \fBscalar_unit\fP &x) \fBconst\fP"
.br
.RI "Power operator, it powers a \fBscalar_unit\fP class with another, if that second \fBscalar_unit\fP class, which is the exponent, as empty dimensions\&. If the exponent doesn't has empty dimensions it returns an empty \fBscalar_unit\fP class\&. "
.ti -1c
.RI "\fBvoid\fP \fBoperator+=\fP (\fBscalar_unit\fP x)"
.br
.RI "Addition operator, it adds a \fBscalar_unit\fP class to another, by converting their dimensions to be equal first\&. If their basic dimensions are different, it doesn't sums to the value\&. "
.ti -1c
.RI "\fBvoid\fP \fBoperator\-=\fP (\fBscalar_unit\fP x)"
.br
.RI "Substraction operator, it substracts a \fBscalar_unit\fP class to another, by converting their dimensions to be equal first\&. If their basic dimensions are different, it doesn't substracts to the value\&. "
.ti -1c
.RI "template<\fBtypename\fP T , \fBtypename\fP  = typename enable_if<scifir::is_number<T>::value>::type> \fBscalar_unit\fP \fBoperator+\fP (T y) \fBconst\fP"
.br
.RI "Addition operator, it sums the numeric type to the value, independent of the dimensions\&. "
.ti -1c
.RI "template<\fBtypename\fP T , \fBtypename\fP  = typename enable_if<scifir::is_number<T>::value>::type> \fBscalar_unit\fP \fBoperator\-\fP (T y) \fBconst\fP"
.br
.RI "Substraction operator, it substracts the numeric type to the value, independent of the dimensions\&. "
.ti -1c
.RI "template<\fBtypename\fP T , \fBtypename\fP  = typename enable_if<scifir::is_number<T>::value>::type> \fBscalar_unit\fP \fBoperator*\fP (T y) \fBconst\fP"
.br
.RI "Multiplication operator, it multiplies the numeric type with the value, independent of the dimensions\&. "
.ti -1c
.RI "template<\fBtypename\fP T , \fBtypename\fP  = typename enable_if<scifir::is_number<T>::value>::type> \fBscalar_unit\fP \fBoperator/\fP (T y) \fBconst\fP"
.br
.RI "Division operator, it divides the value with the numeric type, independent of the dimensions\&. "
.ti -1c
.RI "template<\fBtypename\fP T , \fBtypename\fP  = typename enable_if<is_integer_number<T>::value>::type> \fBscalar_unit\fP \fBoperator^\fP (T y) \fBconst\fP"
.br
.RI "Power operator, it powers the value with the numeric type, independent of the dimensions\&. "
.ti -1c
.RI "template<\fBtypename\fP T , \fBtypename\fP  = typename enable_if<scifir::is_number<T>::value>::type> \fBvoid\fP \fBoperator+=\fP (T y)"
.br
.RI "Addition operator, it adds the numeric type to the value, independent of the dimensions\&. "
.ti -1c
.RI "template<\fBtypename\fP T , \fBtypename\fP  = typename enable_if<scifir::is_number<T>::value>::type> \fBvoid\fP \fBoperator\-=\fP (T y)"
.br
.RI "Substraction operator, it substracts the numeric type to the value, independent of the dimensions\&. "
.ti -1c
.RI "template<\fBtypename\fP T , \fBtypename\fP  = typename enable_if<scifir::is_number<T>::value>::type> \fBvoid\fP \fBoperator*=\fP (T y)"
.br
.RI "Multiplication operator, it multiplies the numeric type to the value, independent of the dimensions\&. "
.ti -1c
.RI "template<\fBtypename\fP T , \fBtypename\fP  = typename enable_if<scifir::is_number<T>::value>::type> \fBvoid\fP \fBoperator/=\fP (T y)"
.br
.RI "Division operator, it divides the numeric type to the value, independent of the dimensions\&. "
.ti -1c
.RI "\fBscalar_unit\fP & \fBoperator++\fP ()"
.br
.RI "Increment operator, it increases the value by one\&. "
.ti -1c
.RI "\fBscalar_unit\fP & \fBoperator++\fP (\fBint\fP)"
.br
.RI "Increment operator, it increases the value by one\&. "
.ti -1c
.RI "\fBscalar_unit\fP & \fBoperator\-\-\fP ()"
.br
.RI "Decrement operator, it decreases the value by one\&. "
.ti -1c
.RI "\fBscalar_unit\fP & \fBoperator\-\-\fP (\fBint\fP)"
.br
.RI "Decrement operator, it decreases the value by one\&. "
.ti -1c
.RI "\fBvoid\fP \fBchange_dimensions\fP (\fBconst\fP \fBstring\fP &\fBinit_dimensions\fP)"
.br
.RI "Changes the dimensions to the dimensions specified by the initialization string of dimensions\&. "
.ti -1c
.RI "\fBvoid\fP \fBchange_dimensions\fP (\fBconst\fP \fBscalar_unit\fP &x)"
.br
.RI "Changes the dimensions to the same dimensions of the \fBscalar_unit\fP\&. "
.ti -1c
.RI "\fBbool\fP \fBhas_dimensions\fP (\fBconst\fP \fBstring\fP &\fBinit_dimensions\fP) \fBconst\fP"
.br
.RI "Checks if the basic dimensions are the same as the initialization string of dimensions\&. "
.ti -1c
.RI "\fBbool\fP \fBhas_dimensions\fP (\fBconst\fP vector< \fBdimension\fP > &\fBx_dimensions\fP) \fBconst\fP"
.br
.RI "Checks if the basic dimensions are the same as some set of dimensions\&. "
.ti -1c
.RI "\fBbool\fP \fBhas_dimensions\fP (\fBconst\fP \fBscalar_unit\fP &x) \fBconst\fP"
.br
.RI "Checks if the basic dimensions are the same as other \fBscalar_unit\fP\&. "
.ti -1c
.RI "\fBbool\fP \fBhas_empty_dimensions\fP () \fBconst\fP"
.br
.RI "Checks if there aren't basic dimensions\&. "
.ti -1c
.RI "\fBstring\fP \fBdisplay_dimensions\fP () \fBconst\fP"
.br
.RI "Generates an string of the dimensions of the \fBscalar_unit\fP, with the same format as the initialization string of dimensions\&. "
.ti -1c
.RI "vector< \fBdimension\fP > \fBget_derived_dimensions\fP () \fBconst\fP"
.br
.RI "Generates a set of the derived dimensions of the dimensions of the \fBscalar_unit\fP\&. "
.ti -1c
.RI "\fBconst\fP vector< \fBdimension\fP > & \fBget_dimensions\fP () \fBconst\fP"
.br
.RI "Read-only getter of the dimensions\&. "
.ti -1c
.RI "\fBconst\fP \fBfloat\fP & \fBget_value\fP () \fBconst\fP"
.br
.RI "Read-only getter of the value\&. "
.ti -1c
.RI "\fBstring\fP \fBdisplay\fP (\fBint\fP \fBnumber_of_decimals\fP=2, \fBbool\fP \fBwith_brackets\fP=\fBfalse\fP, \fBbool\fP \fBuse_close_prefix\fP=\fBfalse\fP) \fBconst\fP"
.br
.RI "Generates an string of the \fBscalar_unit\fP, with the value and the dimensions\&. The dimensions can be enclosed by brackets, and the value can be set to have the closest prefix\&. "
.ti -1c
.RI "\fBstring\fP \fBderived_display\fP (\fBint\fP \fBnumber_of_decimals\fP=2, \fBbool\fP \fBwith_brackets\fP=\fBfalse\fP, \fBbool\fP \fBuse_close_prefix\fP=\fBfalse\fP) \fBconst\fP"
.br
.RI "Generates an string of the \fBscalar_unit\fP, with all dimensions converted to their derived counterpart\&. "
.ti -1c
.RI "\fBstring\fP \fBcustom_display\fP (\fBconst\fP \fBstring\fP &\fBinit_dimensions\fP, \fBint\fP \fBnumber_of_decimals\fP=2, \fBbool\fP \fBwith_brackets\fP=\fBfalse\fP) \fBconst\fP"
.br
.RI "Generates an string of the \fBscalar_unit\fP, with the dimensions changed to any set of dimensions, specified by an initialization string of dimensions\&. "
.in -1c
.SS "Static Public Member Functions"

.in +1c
.ti -1c
.RI "\fBstatic\fP \fBvector_unit_nd\fP \fBcartesian_2d\fP (\fBconst\fP \fBstring\fP &\fBnew_dimensions\fP, \fBfloat\fP \fBnew_x\fP, \fBfloat\fP \fBnew_y\fP)"
.br
.ti -1c
.RI "\fBstatic\fP \fBvector_unit_nd\fP \fBcartesian_3d\fP (\fBconst\fP \fBstring\fP &\fBnew_dimensions\fP, \fBfloat\fP \fBnew_x\fP, \fBfloat\fP \fBnew_y\fP, \fBfloat\fP \fBnew_z\fP)"
.br
.ti -1c
.RI "\fBstatic\fP \fBvector_unit_nd\fP \fBcylindrical\fP (\fBconst\fP \fBstring\fP &\fBnew_dimensions\fP, \fBfloat\fP \fBnew_p\fP, \fBangle\fP \fBnew_theta\fP, \fBfloat\fP \fBnew_z\fP)"
.br
.in -1c
.SS "Public Attributes"

.in +1c
.ti -1c
.RI "vector< \fBangle\fP > \fBangles\fP"
.br
.in -1c
.SS "Private Member Functions"

.in +1c
.ti -1c
.RI "\fBvoid\fP \fBinitialize_from_string\fP (\fBstring\fP \fBinit_vector_nd\fP)"
.br
.in -1c
.SS "Additional Inherited Members"


Protected Member Functions inherited from \fBscifir::scalar_unit\fP
.in +1c
.ti -1c
.RI "\fBvoid\fP \fBadd_dimension\fP (\fBconst\fP \fBdimension\fP &\fBnew_dimension\fP)"
.br
.RI "Internal function\&. It adds a dimension, changing the value according to the conversion factor of the added dimension and the prefix\&. "
.ti -1c
.RI "\fBvoid\fP \fBremove_dimension\fP (\fBconst\fP \fBdimension\fP &\fBold_dimension\fP)"
.br
.RI "Internal function\&. It removes a dimension, changing the value according to the conversion factor of the removed dimension and the prefix\&. "
.ti -1c
.RI "\fBvoid\fP \fBinitialize_from_string\fP (\fBstring\fP \fBinit_scalar\fP)"
.br
.RI "Internal function\&. It sets the value and the dimensions of the \fBscalar_unit\fP to the value and dimensions specified by the initialization string of \fBscalar_unit\fP\&. "
.in -1c

Protected Attributes inherited from \fBscifir::scalar_unit\fP
.in +1c
.ti -1c
.RI "vector< \fBdimension\fP > \fBdimensions\fP"
.br
.RI "Dimensions of the \fBscalar_unit\fP\&. They can be basic dimensions or abbreviations\&. "
.ti -1c
.RI "\fBfloat\fP \fBvalue\fP"
.br
.RI "Value of the \fBscalar_unit\fP\&. It changes automatically when the dimensions change\&. "
.in -1c
.SH "Detailed Description"
.PP 
Definition at line \fB60\fP of file \fBvector_unit_nd\&.hpp\fP\&.
.SH "Constructor & Destructor Documentation"
.PP 
.SS "scifir::vector_unit_nd::vector_unit_nd ()"

.PP
Definition at line \fB10\fP of file \fBvector_unit_nd\&.cpp\fP\&..PP
.nf
10                                    : scalar_unit(),angles()
11     {}
.fi

.SS "scifir::vector_unit_nd::vector_unit_nd (\fBconst\fP \fBvector_unit_nd\fP & x)"

.PP
Definition at line \fB13\fP of file \fBvector_unit_nd\&.cpp\fP\&..PP
.nf
13                                                           : scalar_unit(x),angles(x\&.angles)
14     {}
.fi

.SS "scifir::vector_unit_nd::vector_unit_nd (\fBvector_unit_nd\fP && x)"

.PP
Definition at line \fB16\fP of file \fBvector_unit_nd\&.cpp\fP\&..PP
.nf
16                                                      : scalar_unit(std::move(x)),angles(std::move(x\&.angles))
17     {}
.fi

.SS "scifir::vector_unit_nd::vector_unit_nd (\fBfloat\fP new_value, \fBconst\fP \fBstring\fP & init_dimensions)\fC [explicit]\fP"

.PP
Definition at line \fB19\fP of file \fBvector_unit_nd\&.cpp\fP\&..PP
.nf
19                                                                                 : scalar_unit(new_value,init_dimensions),angles()
20     {}
.fi

.SS "scifir::vector_unit_nd::vector_unit_nd (\fBfloat\fP new_value, \fBconst\fP \fBstring\fP & init_dimensions, \fBconst\fP vector< \fBfloat\fP > & new_angles)\fC [explicit]\fP"

.PP
Definition at line \fB22\fP of file \fBvector_unit_nd\&.cpp\fP\&..PP
.nf
22                                                                                                                 : scalar_unit(new_value,init_dimensions),angles()
23     {
24         for(const float& x_angle : new_angles)
25         {
26             angles\&.push_back(angle(x_angle));
27         }
28     }
.fi

.SS "scifir::vector_unit_nd::vector_unit_nd (\fBfloat\fP new_value, \fBconst\fP \fBstring\fP & init_dimensions, \fBconst\fP vector< \fBangle\fP > & new_angles)\fC [explicit]\fP"

.PP
Definition at line \fB30\fP of file \fBvector_unit_nd\&.cpp\fP\&..PP
.nf
30                                                                                                                 : scalar_unit(new_value,init_dimensions),angles(new_angles)
31     {}
.fi

.SS "scifir::vector_unit_nd::vector_unit_nd (\fBdouble\fP new_value, \fBconst\fP \fBstring\fP & init_dimensions)\fC [explicit]\fP"

.PP
Definition at line \fB33\fP of file \fBvector_unit_nd\&.cpp\fP\&..PP
.nf
33                                                                                  : scalar_unit(new_value,init_dimensions),angles()
34     {}
.fi

.SS "scifir::vector_unit_nd::vector_unit_nd (\fBdouble\fP new_value, \fBconst\fP \fBstring\fP & init_dimensions, \fBconst\fP vector< \fBfloat\fP > & new_angles)\fC [explicit]\fP"

.PP
Definition at line \fB36\fP of file \fBvector_unit_nd\&.cpp\fP\&..PP
.nf
36                                                                                                                  : scalar_unit(new_value,init_dimensions),angles()
37     {
38         for(const float& x_angle : new_angles)
39         {
40             angles\&.push_back(angle(x_angle));
41         }
42     }
.fi

.SS "scifir::vector_unit_nd::vector_unit_nd (\fBdouble\fP new_value, \fBconst\fP \fBstring\fP & init_dimensions, \fBconst\fP vector< \fBangle\fP > & new_angles)\fC [explicit]\fP"

.PP
Definition at line \fB44\fP of file \fBvector_unit_nd\&.cpp\fP\&..PP
.nf
44                                                                                                                  : scalar_unit(new_value,init_dimensions),angles(new_angles)
45     {}
.fi

.SS "scifir::vector_unit_nd::vector_unit_nd (\fBlong\fP \fBdouble\fP new_value, \fBconst\fP \fBstring\fP & init_dimensions)\fC [explicit]\fP"

.PP
Definition at line \fB47\fP of file \fBvector_unit_nd\&.cpp\fP\&..PP
.nf
47                                                                                       : scalar_unit(new_value,init_dimensions),angles()
48     {}
.fi

.SS "scifir::vector_unit_nd::vector_unit_nd (\fBlong\fP \fBdouble\fP new_value, \fBconst\fP \fBstring\fP & init_dimensions, \fBconst\fP vector< \fBfloat\fP > & new_angles)\fC [explicit]\fP"

.PP
Definition at line \fB50\fP of file \fBvector_unit_nd\&.cpp\fP\&..PP
.nf
50                                                                                                                       : scalar_unit(new_value,init_dimensions),angles()
51     {
52         for(const float& x_angle : new_angles)
53         {
54             angles\&.push_back(angle(x_angle));
55         }
56     }
.fi

.SS "scifir::vector_unit_nd::vector_unit_nd (\fBlong\fP \fBdouble\fP new_value, \fBconst\fP \fBstring\fP & init_dimensions, \fBconst\fP vector< \fBangle\fP > & new_angles)\fC [explicit]\fP"

.PP
Definition at line \fB58\fP of file \fBvector_unit_nd\&.cpp\fP\&..PP
.nf
58                                                                                                                       : scalar_unit(new_value,init_dimensions),angles(new_angles)
59     {}
.fi

.SS "scifir::vector_unit_nd::vector_unit_nd (\fBint\fP new_value, \fBconst\fP \fBstring\fP & init_dimensions)\fC [explicit]\fP"

.PP
Definition at line \fB61\fP of file \fBvector_unit_nd\&.cpp\fP\&..PP
.nf
61                                                                               : scalar_unit(new_value,init_dimensions),angles()
62     {}
.fi

.SS "scifir::vector_unit_nd::vector_unit_nd (\fBint\fP new_value, \fBconst\fP \fBstring\fP & init_dimensions, \fBconst\fP vector< \fBfloat\fP > & new_angles)\fC [explicit]\fP"

.PP
Definition at line \fB64\fP of file \fBvector_unit_nd\&.cpp\fP\&..PP
.nf
64                                                                                                               : scalar_unit(new_value,init_dimensions),angles()
65     {
66         for(const float& x_angle : new_angles)
67         {
68             angles\&.push_back(angle(x_angle));
69         }
70     }
.fi

.SS "scifir::vector_unit_nd::vector_unit_nd (\fBint\fP new_value, \fBconst\fP \fBstring\fP & init_dimensions, \fBconst\fP vector< \fBangle\fP > & new_angles)\fC [explicit]\fP"

.PP
Definition at line \fB72\fP of file \fBvector_unit_nd\&.cpp\fP\&..PP
.nf
72                                                                                                               : scalar_unit(new_value,init_dimensions),angles(new_angles)
73     {}
.fi

.SS "scifir::vector_unit_nd::vector_unit_nd (\fBfloat\fP new_value, \fBconst\fP vector< \fBdimension\fP > & new_dimensions)\fC [explicit]\fP"

.PP
Definition at line \fB75\fP of file \fBvector_unit_nd\&.cpp\fP\&..PP
.nf
75                                                                                           : scalar_unit(new_value,new_dimensions),angles()
76     {}
.fi

.SS "scifir::vector_unit_nd::vector_unit_nd (\fBfloat\fP new_value, \fBconst\fP vector< \fBdimension\fP > & new_dimensions, \fBconst\fP vector< \fBfloat\fP > & new_angles)\fC [explicit]\fP"

.PP
Definition at line \fB78\fP of file \fBvector_unit_nd\&.cpp\fP\&..PP
.nf
78                                                                                                                           : scalar_unit(new_value,new_dimensions),angles()
79     {
80         for(const float& x_angle : new_angles)
81         {
82             angles\&.push_back(angle(x_angle));
83         }
84     }
.fi

.SS "scifir::vector_unit_nd::vector_unit_nd (\fBfloat\fP new_value, \fBconst\fP vector< \fBdimension\fP > & new_dimensions, \fBconst\fP vector< \fBangle\fP > & new_angles)\fC [explicit]\fP"

.PP
Definition at line \fB86\fP of file \fBvector_unit_nd\&.cpp\fP\&..PP
.nf
86                                                                                                                           : scalar_unit(new_value,new_dimensions),angles(new_angles)
87     {}
.fi

.SS "scifir::vector_unit_nd::vector_unit_nd (\fBdouble\fP new_value, \fBconst\fP vector< \fBdimension\fP > & new_dimensions)\fC [explicit]\fP"

.PP
Definition at line \fB89\fP of file \fBvector_unit_nd\&.cpp\fP\&..PP
.nf
89                                                                                            : scalar_unit(new_value,new_dimensions),angles()
90     {}
.fi

.SS "scifir::vector_unit_nd::vector_unit_nd (\fBdouble\fP new_value, \fBconst\fP vector< \fBdimension\fP > & new_dimensions, \fBconst\fP vector< \fBfloat\fP > & new_angles)\fC [explicit]\fP"

.PP
Definition at line \fB92\fP of file \fBvector_unit_nd\&.cpp\fP\&..PP
.nf
92                                                                                                                            : scalar_unit(new_value,new_dimensions),angles()
93     {
94         for(const float& x_angle : new_angles)
95         {
96             angles\&.push_back(angle(x_angle));
97         }
98     }
.fi

.SS "scifir::vector_unit_nd::vector_unit_nd (\fBdouble\fP new_value, \fBconst\fP vector< \fBdimension\fP > & new_dimensions, \fBconst\fP vector< \fBangle\fP > & new_angles)\fC [explicit]\fP"

.PP
Definition at line \fB100\fP of file \fBvector_unit_nd\&.cpp\fP\&..PP
.nf
100                                                                                                                            : scalar_unit(new_value,new_dimensions),angles(new_angles)
101     {}
.fi

.SS "scifir::vector_unit_nd::vector_unit_nd (\fBlong\fP \fBdouble\fP new_value, \fBconst\fP vector< \fBdimension\fP > & new_dimensions)\fC [explicit]\fP"

.PP
Definition at line \fB103\fP of file \fBvector_unit_nd\&.cpp\fP\&..PP
.nf
103                                                                                                 : scalar_unit(new_value,new_dimensions),angles()
104     {}
.fi

.SS "scifir::vector_unit_nd::vector_unit_nd (\fBlong\fP \fBdouble\fP new_value, \fBconst\fP vector< \fBdimension\fP > & new_dimensions, \fBconst\fP vector< \fBfloat\fP > & new_angles)\fC [explicit]\fP"

.PP
Definition at line \fB106\fP of file \fBvector_unit_nd\&.cpp\fP\&..PP
.nf
106                                                                                                                                 : scalar_unit(new_value,new_dimensions),angles()
107     {
108         for(const float& x_angle : new_angles)
109         {
110             angles\&.push_back(angle(x_angle));
111         }
112     }
.fi

.SS "scifir::vector_unit_nd::vector_unit_nd (\fBlong\fP \fBdouble\fP new_value, \fBconst\fP vector< \fBdimension\fP > & new_dimensions, \fBconst\fP vector< \fBangle\fP > & new_angles)\fC [explicit]\fP"

.PP
Definition at line \fB114\fP of file \fBvector_unit_nd\&.cpp\fP\&..PP
.nf
114                                                                                                                                 : scalar_unit(new_value,new_dimensions),angles(new_angles)
115     {}
.fi

.SS "scifir::vector_unit_nd::vector_unit_nd (\fBint\fP new_value, \fBconst\fP vector< \fBdimension\fP > & new_dimensions)\fC [explicit]\fP"

.PP
Definition at line \fB117\fP of file \fBvector_unit_nd\&.cpp\fP\&..PP
.nf
117                                                                                         : scalar_unit(new_value,new_dimensions),angles()
118     {}
.fi

.SS "scifir::vector_unit_nd::vector_unit_nd (\fBint\fP new_value, \fBconst\fP vector< \fBdimension\fP > & new_dimensions, \fBconst\fP vector< \fBfloat\fP > & new_angles)\fC [explicit]\fP"

.PP
Definition at line \fB120\fP of file \fBvector_unit_nd\&.cpp\fP\&..PP
.nf
120                                                                                                                         : scalar_unit(new_value,new_dimensions),angles()
121     {
122         for(const float& x_angle : new_angles)
123         {
124             angles\&.push_back(angle(x_angle));
125         }
126     }
.fi

.SS "scifir::vector_unit_nd::vector_unit_nd (\fBint\fP new_value, \fBconst\fP vector< \fBdimension\fP > & new_dimensions, \fBconst\fP vector< \fBangle\fP > & new_angles)\fC [explicit]\fP"

.PP
Definition at line \fB128\fP of file \fBvector_unit_nd\&.cpp\fP\&..PP
.nf
128                                                                                                                         : scalar_unit(new_value,new_dimensions),angles(new_angles)
129     {}
.fi

.SS "scifir::vector_unit_nd::vector_unit_nd (\fBconst\fP \fBscalar_unit\fP & x)\fC [explicit]\fP"

.PP
Definition at line \fB131\fP of file \fBvector_unit_nd\&.cpp\fP\&..PP
.nf
131                                                        : scalar_unit(x),angles()
132     {}
.fi

.SS "scifir::vector_unit_nd::vector_unit_nd (\fBconst\fP \fBscalar_unit\fP & x, \fBconst\fP vector< \fBfloat\fP > & new_angles)\fC [explicit]\fP"

.PP
Definition at line \fB134\fP of file \fBvector_unit_nd\&.cpp\fP\&..PP
.nf
134                                                                                        : scalar_unit(x),angles()
135     {
136         for(const float& x_angle : new_angles)
137         {
138             angles\&.push_back(angle(x_angle));
139         }
140     }
.fi

.SS "scifir::vector_unit_nd::vector_unit_nd (\fBconst\fP \fBscalar_unit\fP & x, \fBconst\fP vector< \fBangle\fP > & new_angles)\fC [explicit]\fP"

.PP
Definition at line \fB142\fP of file \fBvector_unit_nd\&.cpp\fP\&..PP
.nf
142                                                                                        : scalar_unit(x),angles(new_angles)
143     {}
.fi

.SS "scifir::vector_unit_nd::vector_unit_nd (\fBconst\fP \fBstring\fP & init_scalar, \fBconst\fP vector< \fBfloat\fP > & new_angles)\fC [explicit]\fP"

.PP
Definition at line \fB145\fP of file \fBvector_unit_nd\&.cpp\fP\&..PP
.nf
145                                                                                             : scalar_unit(init_scalar),angles()
146     {
147         for(const float& x_angle : new_angles)
148         {
149             angles\&.push_back(angle(x_angle));
150         }
151     }
.fi

.SS "scifir::vector_unit_nd::vector_unit_nd (\fBconst\fP \fBstring\fP & init_scalar, \fBconst\fP vector< \fBangle\fP > & new_angles)\fC [explicit]\fP"

.PP
Definition at line \fB153\fP of file \fBvector_unit_nd\&.cpp\fP\&..PP
.nf
153                                                                                             : scalar_unit(init_scalar),angles(new_angles)
154     {}
.fi

.SS "scifir::vector_unit_nd::vector_unit_nd (\fBconst\fP \fBstring\fP & init_vector_nd)\fC [explicit]\fP"

.PP
Definition at line \fB156\fP of file \fBvector_unit_nd\&.cpp\fP\&..PP
.nf
156                                                                : vector_unit_nd()
157     {
158         vector_unit_nd::initialize_from_string(init_vector_nd);
159     }
.fi

.SH "Member Function Documentation"
.PP 
.SS "\fBstatic\fP \fBvector_unit_nd\fP scifir::vector_unit_nd::cartesian_2d (\fBconst\fP \fBstring\fP & new_dimensions, \fBfloat\fP new_x, \fBfloat\fP new_y)\fC [inline]\fP, \fC [static]\fP"

.PP
Definition at line \fB97\fP of file \fBvector_unit_nd\&.hpp\fP\&..PP
.nf
98             {
99                 float new_value = float(std::sqrt(std::pow(new_x,2) + std::pow(new_y,2)));
100                 float new_theta = scifir::atan_grade(new_y / new_x);
101                 return vector_unit_nd(new_value,new_dimensions, {angle(new_theta)});
102             }
.fi

.SS "\fBstatic\fP \fBvector_unit_nd\fP scifir::vector_unit_nd::cartesian_3d (\fBconst\fP \fBstring\fP & new_dimensions, \fBfloat\fP new_x, \fBfloat\fP new_y, \fBfloat\fP new_z)\fC [inline]\fP, \fC [static]\fP"

.PP
Definition at line \fB104\fP of file \fBvector_unit_nd\&.hpp\fP\&..PP
.nf
105             {
106                 float new_value = float(std::sqrt(std::pow(new_x,2) + std::pow(new_y,2) + std::pow(new_z,2)));
107                 float new_theta = scifir::atan_grade(new_y / new_x);
108                 float new_phi = scifir::acos_grade(new_z / new_value);
109                 return vector_unit_nd(new_value,new_dimensions, {angle(new_theta), angle(new_phi)});
110             }
.fi

.SS "\fBstatic\fP \fBvector_unit_nd\fP scifir::vector_unit_nd::cylindrical (\fBconst\fP \fBstring\fP & new_dimensions, \fBfloat\fP new_p, \fBangle\fP new_theta, \fBfloat\fP new_z)\fC [inline]\fP, \fC [static]\fP"

.PP
Definition at line \fB112\fP of file \fBvector_unit_nd\&.hpp\fP\&..PP
.nf
113             {
114                 float new_value = float(std::sqrt(std::pow(new_p,2) + std::pow(new_z,2)));
115                 float new_phi = scifir::atan_grade(new_p / new_z);
116                 return vector_unit_nd(new_value,new_dimensions, {new_theta, angle(new_phi)});
117             }
.fi

.SS "\fBint\fP scifir::vector_unit_nd::get_nd () const\fC [inline]\fP"

.PP
Definition at line \fB214\fP of file \fBvector_unit_nd\&.hpp\fP\&..PP
.nf
215             {
216                 return int(angles\&.size() + 1);
217             }
.fi

.SS "\fBvoid\fP scifir::vector_unit_nd::initialize_from_string (\fBstring\fP init_vector_nd)\fC [private]\fP"

.PP
Definition at line \fB722\fP of file \fBvector_unit_nd\&.cpp\fP\&..PP
.nf
723     {
724         vector<string> values;
725         boost::split(values,init_vector_nd,boost::is_any_of(" "));
726         scalar_unit::initialize_from_string(values[0] + " " + values[1]);
727         if (values\&.size() > 2)
728         {
729             angles\&.clear();
730             for (unsigned int i = 2; i < values\&.size(); i++)
731             {
732                 angles\&.push_back(angle(values[i]));
733             }
734         }
735     }
.fi

.SS "\fBvoid\fP scifir::vector_unit_nd::invert ()"

.PP
Definition at line \fB676\fP of file \fBvector_unit_nd\&.cpp\fP\&..PP
.nf
677     {
678         if (is_nd(2))
679         {
680             angles[0]\&.invert();
681         }
682         else if (is_nd(3))
683         {
684             angles[0]\&.invert();
685             angles[1] = 180\&.0f \- angles[1];
686         }
687     }
.fi

.SS "\fBbool\fP scifir::vector_unit_nd::is_nd (\fBunsigned\fP \fBint\fP i) const\fC [inline]\fP"

.PP
Definition at line \fB209\fP of file \fBvector_unit_nd\&.hpp\fP\&..PP
.nf
210             {
211                 return angles\&.size() == (i \- 1);
212             }
.fi

.SS "\fBscalar_unit\fP scifir::vector_unit_nd::n_projection (\fBint\fP i) const"

.PP
Definition at line \fB596\fP of file \fBvector_unit_nd\&.cpp\fP\&..PP
.nf
597     {
598         if (i == 1)
599         {
600             return x_projection();
601         }
602         else if (i == 2)
603         {
604             return y_projection();
605         }
606         else if (i == 3)
607         {
608             return z_projection();
609         }
610         else
611         {
612             return scalar_unit();
613         }
614     }
.fi

.SS "\fBvector_unit_nd\fP scifir::vector_unit_nd::operator* (\fBconst\fP \fBscalar_unit\fP & x) const"

.PP
Definition at line \fB523\fP of file \fBvector_unit_nd\&.cpp\fP\&..PP
.nf
524     {
525         long double new_value = scalar_unit::value * x\&.get_value();
526         vector<dimension> new_dimensions = multiply_dimensions(get_dimensions(), x\&.get_dimensions(),new_value);
527         if(is_nd(1))
528         {
529             return vector_unit_nd(float(new_value), new_dimensions);
530         }
531         else if(is_nd(2))
532         {
533             return vector_unit_nd(float(new_value), new_dimensions, {angles[0]});
534         }
535         else if(is_nd(3))
536         {
537             return vector_unit_nd(float(new_value), new_dimensions, {angles[0], angles[1]});
538         }
539         else
540         {
541             return vector_unit_nd(float(new_value), new_dimensions, angles);
542         }
543     }
.fi

.SS "template<\fBtypename\fP \fBU\fP , \fBtypename\fP  = typename enable_if<scifir::is_number<U>::value>::type> \fBvector_unit_nd\fP scifir::vector_unit_nd::operator* (\fBU\fP x) const\fC [inline]\fP"

.PP
Definition at line \fB156\fP of file \fBvector_unit_nd\&.hpp\fP\&..PP
.nf
157             {
158                 vector_unit_nd y = *this;
159                 y *= x;
160                 return y;
161             }
.fi

.SS "template<\fBtypename\fP \fBU\fP , \fBtypename\fP  = typename enable_if<scifir::is_number<U>::value>::type> \fBvoid\fP scifir::vector_unit_nd::operator*= (\fBU\fP x)\fC [inline]\fP"

.PP
Definition at line \fB190\fP of file \fBvector_unit_nd\&.hpp\fP\&..PP
.nf
191             {
192                 scalar_unit::value *= std::abs(x);
193                 if(x < 0)
194                 {
195                     invert();
196                 }
197             }
.fi

.SS "\fBvector_unit_nd\fP scifir::vector_unit_nd::operator+ (\fBconst\fP \fBvector_unit_nd\fP & x) const"

.PP
Definition at line \fB439\fP of file \fBvector_unit_nd\&.cpp\fP\&..PP
.nf
440     {
441         if(has_dimensions(x))
442         {
443             if(is_nd(1))
444             {
445                 float new_value = scalar_unit::value + x\&.get_value();
446                 return vector_unit_nd(new_value,get_dimensions());
447             }
448             else if(is_nd(2))
449             {
450                 float new_x = float(x_projection() + x\&.x_projection());
451                 float new_y = float(y_projection() + x\&.y_projection());
452                 float new_value = cartesian_2d_to_polar_p(new_x, new_y);
453                 vector<angle> new_angles = vector<angle>();
454                 new_angles\&.push_back(cartesian_2d_to_polar_theta(new_x, new_y));
455                 return vector_unit_nd(new_value,get_dimensions(),new_angles);
456             }
457             else if(is_nd(3))
458             {
459                 float new_x = float(x_projection() + x\&.x_projection());
460                 float new_y = float(y_projection() + x\&.y_projection());
461                 float new_z = float(z_projection() + x\&.z_projection());
462                 float new_value = cartesian_3d_to_spherical_r(new_x, new_y, new_z);
463                 vector<angle> new_angles = vector<angle>();
464                 new_angles\&.push_back(angle(cartesian_3d_to_spherical_theta(new_x, new_y, new_z)));
465                 new_angles\&.push_back(angle(cartesian_3d_to_spherical_phi(new_x, new_y, new_z)));
466                 return vector_unit_nd(new_value,get_dimensions(),new_angles);
467             }
468             else
469             {
470                 return vector_unit_nd();
471             }
472         }
473         else
474         {
475             cerr << "Cannot sum vectors of different dimensions" << endl;
476             return vector_unit_nd();
477         }
478     }
.fi

.SS "template<\fBtypename\fP \fBU\fP , \fBtypename\fP  = typename enable_if<scifir::is_number<U>::value>::type> \fBvector_unit_nd\fP scifir::vector_unit_nd::operator+ (\fBU\fP x) const\fC [inline]\fP"

.PP
Definition at line \fB140\fP of file \fBvector_unit_nd\&.hpp\fP\&..PP
.nf
141             {
142                 vector_unit_nd y = *this;
143                 y += x;
144                 return y;
145             }
.fi

.SS "\fBvoid\fP scifir::vector_unit_nd::operator+= (\fBconst\fP \fBvector_unit_nd\fP & x)"

.PP
Definition at line \fB395\fP of file \fBvector_unit_nd\&.cpp\fP\&..PP
.nf
396     {
397         if(has_dimensions(x) and get_nd() == x\&.get_nd())
398         {
399             if(is_nd(1))
400             {
401                 scalar_unit::value += x\&.get_value();
402             }
403             else if(is_nd(2))
404             {
405                 float new_x = float(x_projection() + x\&.x_projection());
406                 float new_y = float(y_projection() + x\&.y_projection());
407                 scalar_unit::value = cartesian_2d_to_polar_p(new_x, new_y);
408                 angles[0] = cartesian_2d_to_polar_theta(new_x, new_y);
409             }
410             else if(is_nd(3))
411             {
412                 float new_x = float(x_projection() + x\&.x_projection());
413                 float new_y = float(y_projection() + x\&.y_projection());
414                 float new_z = float(z_projection() + x\&.z_projection());
415                 scalar_unit::value = cartesian_3d_to_spherical_r(new_x, new_y, new_z);
416                 angles[0] = cartesian_3d_to_spherical_theta(new_x, new_y, new_z);
417                 angles[1] = cartesian_3d_to_spherical_phi(new_x, new_y, new_z);
418             }
419         }
420         else
421         {
422             cerr << "Cannot sum vectors of different dimensions" << endl;
423         }
424     }
.fi

.SS "template<\fBtypename\fP \fBU\fP , \fBtypename\fP  = typename enable_if<scifir::is_number<U>::value>::type> \fBvoid\fP scifir::vector_unit_nd::operator+= (\fBU\fP x)\fC [inline]\fP"

.PP
Definition at line \fB178\fP of file \fBvector_unit_nd\&.hpp\fP\&..PP
.nf
179             {
180                 scalar_unit::value += x;
181             }
.fi

.SS "template<\fBtypename\fP \fBU\fP , \fBtypename\fP  = typename enable_if<scifir::is_number<U>::value>::type> \fBvector_unit_nd\fP scifir::vector_unit_nd::operator\- (\fBU\fP x) const\fC [inline]\fP"

.PP
Definition at line \fB148\fP of file \fBvector_unit_nd\&.hpp\fP\&..PP
.nf
149             {
150                 vector_unit_nd y = *this;
151                 y \-= x;
152                 return y;
153             }
.fi

.SS "\fBvector_unit_nd\fP scifir::vector_unit_nd::operator\- (\fBvector_unit_nd\fP x) const"

.PP
Definition at line \fB480\fP of file \fBvector_unit_nd\&.cpp\fP\&..PP
.nf
481     {
482         if(has_dimensions(x))
483         {
484             if(is_nd(1))
485             {
486                 float new_value = scalar_unit::value \- x\&.get_value();
487                 return vector_unit_nd(new_value,get_dimensions());
488             }
489             else if(is_nd(2))
490             {
491                 x\&.invert();
492                 float new_x = float(x_projection() + x\&.x_projection());
493                 float new_y = float(y_projection() + x\&.y_projection());
494                 float new_value = cartesian_2d_to_polar_p(new_x, new_y);
495                 vector<angle> new_angles = vector<angle>();
496                 new_angles\&.push_back(cartesian_2d_to_polar_theta(new_x, new_y));
497                 return vector_unit_nd(new_value,get_dimensions(),new_angles);
498             }
499             else if(is_nd(3))
500             {
501                 x\&.invert();
502                 float new_x = float(x_projection() + x\&.x_projection());
503                 float new_y = float(y_projection() + x\&.y_projection());
504                 float new_z = float(z_projection() + x\&.z_projection());
505                 float new_value = cartesian_3d_to_spherical_r(new_x, new_y, new_z);
506                 vector<angle> new_angles = vector<angle>();
507                 new_angles\&.push_back(angle(cartesian_3d_to_spherical_theta(new_x, new_y, new_z)));
508                 new_angles\&.push_back(angle(cartesian_3d_to_spherical_phi(new_x, new_y, new_z)));
509                 return vector_unit_nd(new_value,get_dimensions(),new_angles);
510             }
511             else
512             {
513                 return vector_unit_nd();
514             }
515         }
516         else
517         {
518             cerr << "Cannot sum vectors of different dimensions" << endl;
519             return vector_unit_nd();
520         }
521     }
.fi

.SS "template<\fBtypename\fP \fBU\fP , \fBtypename\fP  = typename enable_if<scifir::is_number<U>::value>::type> \fBvoid\fP scifir::vector_unit_nd::operator\-= (\fBU\fP x)\fC [inline]\fP"

.PP
Definition at line \fB184\fP of file \fBvector_unit_nd\&.hpp\fP\&..PP
.nf
185             {
186                 scalar_unit::value \-= x;
187             }
.fi

.SS "\fBvoid\fP scifir::vector_unit_nd::operator\-= (\fBvector_unit_nd\fP x)"

.PP
Definition at line \fB426\fP of file \fBvector_unit_nd\&.cpp\fP\&..PP
.nf
427     {
428         if(has_dimensions(x))
429         {
430             x\&.invert();
431             *this += x;
432         }
433         else
434         {
435             cerr << "Cannot substract vectors of different dimensions" << endl;
436         }
437     }
.fi

.SS "\fBvector_unit_nd\fP scifir::vector_unit_nd::operator/ (\fBconst\fP \fBscalar_unit\fP & x) const"

.PP
Definition at line \fB545\fP of file \fBvector_unit_nd\&.cpp\fP\&..PP
.nf
546     {
547         long double new_value = scalar_unit::value / x\&.get_value();
548         vector<dimension> new_dimensions = divide_dimensions(get_dimensions(), x\&.get_dimensions(),new_value);
549         if(is_nd(1))
550         {
551             return vector_unit_nd(float(new_value), new_dimensions);
552         }
553         else if(is_nd(2))
554         {
555             return vector_unit_nd(float(new_value), new_dimensions, {angles[0]});
556         }
557         else if(is_nd(3))
558         {
559             return vector_unit_nd(float(new_value), new_dimensions, {angles[0], angles[1]});
560         }
561         else
562         {
563             return vector_unit_nd(float(new_value), new_dimensions, angles);
564         }
565     }
.fi

.SS "template<\fBtypename\fP \fBU\fP , \fBtypename\fP  = typename enable_if<scifir::is_number<U>::value>::type> \fBvector_unit_nd\fP scifir::vector_unit_nd::operator/ (\fBU\fP x) const\fC [inline]\fP"

.PP
Definition at line \fB164\fP of file \fBvector_unit_nd\&.hpp\fP\&..PP
.nf
165             {
166                 vector_unit_nd y = *this;
167                 y /= x;
168                 return y;
169             }
.fi

.SS "template<\fBtypename\fP \fBU\fP , \fBtypename\fP  = typename enable_if<scifir::is_number<U>::value>::type> \fBvoid\fP scifir::vector_unit_nd::operator/= (\fBU\fP x)\fC [inline]\fP"

.PP
Definition at line \fB200\fP of file \fBvector_unit_nd\&.hpp\fP\&..PP
.nf
201             {
202                 scalar_unit::value /= std::abs(x);
203                 if(x < 0)
204                 {
205                     invert();
206                 }
207             }
.fi

.SS "\fBvector_unit_nd\fP & scifir::vector_unit_nd::operator= (\fBconst\fP \fBscalar_unit\fP & x)"

.PP
Definition at line \fB175\fP of file \fBvector_unit_nd\&.cpp\fP\&..PP
.nf
176     {
177         scalar_unit::operator=(x);
178         return *this;
179     }
.fi

.SS "\fBvector_unit_nd\fP & scifir::vector_unit_nd::operator= (\fBconst\fP \fBstring\fP & init_vector_nd)"

.PP
Definition at line \fB187\fP of file \fBvector_unit_nd\&.cpp\fP\&..PP
.nf
188     {
189         vector_unit_nd::initialize_from_string(init_vector_nd);
190         return *this;
191     }
.fi

.SS "\fBvector_unit_nd\fP & scifir::vector_unit_nd::operator= (\fBconst\fP \fBvector_unit_nd\fP & x)"

.PP
Definition at line \fB161\fP of file \fBvector_unit_nd\&.cpp\fP\&..PP
.nf
162     {
163         scalar_unit::operator=(x);
164         angles = x\&.angles;
165         return *this;
166     }
.fi

.SS "\fBvector_unit_nd\fP & scifir::vector_unit_nd::operator= (\fBscalar_unit\fP && x)"

.PP
Definition at line \fB181\fP of file \fBvector_unit_nd\&.cpp\fP\&..PP
.nf
182     {
183         scalar_unit::operator=(std::move(x));
184         return *this;
185     }
.fi

.SS "\fBvector_unit_nd\fP & scifir::vector_unit_nd::operator= (\fBvector_unit_nd\fP && x)"

.PP
Definition at line \fB168\fP of file \fBvector_unit_nd\&.cpp\fP\&..PP
.nf
169     {
170         scalar_unit::operator=(std::move(x));
171         angles = std::move(x\&.angles);
172         return *this;
173     }
.fi

.SS "\fBbool\fP scifir::vector_unit_nd::operator== (\fBscifir::vector_unit_nd\fP x) const"

.PP
Definition at line \fB193\fP of file \fBvector_unit_nd\&.cpp\fP\&..PP
.nf
194     {
195         x\&.change_dimensions(*this);
196         if(get_value() == x\&.get_value() and scifir::same_direction(*this,x) and has_dimensions(x))
197         {
198             return true;
199         }
200         else
201         {
202             return false;
203         }
204     }
.fi

.SS "\fBvector_unit_nd\fP scifir::vector_unit_nd::operator^ (\fBconst\fP \fBscalar_unit\fP & x) const"

.PP
Definition at line \fB567\fP of file \fBvector_unit_nd\&.cpp\fP\&..PP
.nf
568     {
569         if(x\&.has_empty_dimensions())
570         {
571             scalar_unit new_unit = scalar_unit::operator^(x);
572             if(is_nd(1))
573             {
574                 return vector_unit_nd(new_unit);
575             }
576             else if(is_nd(2))
577             {
578                 return vector_unit_nd(new_unit, {angles[0]});
579             }
580             else if(is_nd(3))
581             {
582                 return vector_unit_nd(new_unit, {angles[0], angles[1]});
583             }
584             else
585             {
586                 return vector_unit_nd(new_unit, angles);
587             }
588         }
589         else
590         {
591             cerr << "Cannot power with as exponent a unit with dimensions" << endl;
592             return vector_unit_nd();
593         }
594     }
.fi

.SS "template<\fBtypename\fP \fBU\fP , \fBtypename\fP  = typename enable_if<is_integer_number<U>::value>::type> \fBvector_unit_nd\fP scifir::vector_unit_nd::operator^ (\fBU\fP x) const\fC [inline]\fP"

.PP
Definition at line \fB172\fP of file \fBvector_unit_nd\&.hpp\fP\&..PP
.nf
173             {
174                 return vector_unit_nd(std::pow(get_value(),x),power_dimensions(get_dimensions(),x),angles);
175             }
.fi

.SS "\fBvoid\fP scifir::vector_unit_nd::point_to (\fBdirection::name\fP x)"

.PP
Definition at line \fB206\fP of file \fBvector_unit_nd\&.cpp\fP\&..PP
.nf
207     {
208         if (is_nd(1))
209         {
210             if (x == direction::LEFT)
211             {
212                 if (value > 0)
213                 {
214                     value *= \-1;
215                 }
216             }
217             else if(x == direction::RIGHT)
218             {
219                 if (value < 0)
220                 {
221                     value *= \-1;
222                 }
223             }
224         }
225         else if (is_nd(2))
226         {
227             if (x == direction::LEFT)
228             {
229                 angles[0] = 180\&.0f;
230             }
231             else if(x == direction::RIGHT)
232             {
233                 angles[0] = 0\&.0f;
234             }
235             else if(x == direction::TOP)
236             {
237                 angles[0] = 90\&.0f;
238             }
239             else if(x == direction::BOTTOM)
240             {
241                 angles[0] = 270\&.0f;
242             }
243             else if(x == direction::LEFT_TOP)
244             {
245                 angles[0] = 135\&.0f;
246             }
247             else if(x == direction::RIGHT_TOP)
248             {
249                 angles[0] = 45\&.0f;
250             }
251             else if(x == direction::RIGHT_BOTTOM)
252             {
253                 angles[0] = 315\&.0f;
254             }
255             else if(x == direction::LEFT_BOTTOM)
256             {
257                 angles[0] = 225\&.0f;
258             }
259         }
260         else if (is_nd(3))
261         {
262             if (x == direction::LEFT)
263             {
264                 angles[0] = 270\&.0f;
265                 angles[1] = 90\&.0f;
266             }
267             else if(x == direction::RIGHT)
268             {
269                 angles[0] = 90\&.0f;
270                 angles[1] = 90\&.0f;
271             }
272             else if(x == direction::TOP)
273             {
274                 angles[0] = 0\&.0f;
275                 angles[1] = 0\&.0f;
276             }
277             else if(x == direction::BOTTOM)
278             {
279                 angles[0] = 0\&.0f;
280                 angles[1] = 180\&.0f;
281             }
282             else if(x == direction::LEFT_TOP)
283             {
284                 angles[0] = 270\&.0f;
285                 angles[1] = 45\&.0f;
286             }
287             else if(x == direction::RIGHT_TOP)
288             {
289                 angles[0] = 90\&.0f;
290                 angles[1] = 45\&.0f;
291             }
292             else if(x == direction::RIGHT_BOTTOM)
293             {
294                 angles[0] = 90\&.0f;
295                 angles[1] = 135\&.0f;
296             }
297             else if(x == direction::LEFT_BOTTOM)
298             {
299                 angles[0] = 270\&.0f;
300                 angles[1] = 135\&.0f;
301             }
302             else if(x == direction::FRONT)
303             {
304                 angles[0] = 0\&.0f;
305                 angles[1] = 90\&.0f;
306             }
307             else if(x == direction::BACK)
308             {
309                 angles[0] = 180\&.0f;
310                 angles[1] = 90\&.0f;
311             }
312             else if(x == direction::LEFT_FRONT)
313             {
314                 angles[0] = 315\&.0f;
315                 angles[1] = 90\&.0f;
316             }
317             else if(x == direction::RIGHT_FRONT)
318             {
319                 angles[0] = 45\&.0f;
320                 angles[1] = 90\&.0f;
321             }
322             else if(x == direction::TOP_FRONT)
323             {
324                 angles[0] = 0\&.0f;
325                 angles[1] = 45\&.0f;
326             }
327             else if(x == direction::BOTTOM_FRONT)
328             {
329                 angles[0] = 0\&.0f;
330                 angles[1] = 135\&.0f;
331             }
332             else if(x == direction::LEFT_BACK)
333             {
334                 angles[0] = 225\&.0f;
335                 angles[1] = 90\&.0f;
336             }
337             else if(x == direction::RIGHT_BACK)
338             {
339                 angles[0] = 135\&.0f;
340                 angles[1] = 90\&.0f;
341             }
342             else if(x == direction::TOP_BACK)
343             {
344                 angles[0] = 180\&.0f;
345                 angles[1] = 45\&.0f;
346             }
347             else if(x == direction::BOTTOM_BACK)
348             {
349                 angles[0] = 180\&.0f;
350                 angles[1] = 135\&.0f;
351             }
352             else if(x == direction::LEFT_TOP_FRONT)
353             {
354                 angles[0] = 315\&.0f;
355                 angles[1] = 45\&.0f;
356             }
357             else if(x == direction::RIGHT_TOP_FRONT)
358             {
359                 angles[0] = 45\&.0f;
360                 angles[1] = 45\&.0f;
361             }
362             else if(x == direction::LEFT_BOTTOM_FRONT)
363             {
364                 angles[0] = 315\&.0f;
365                 angles[1] = 135\&.0f;
366             }
367             else if(x == direction::RIGHT_BOTTOM_FRONT)
368             {
369                 angles[0] = 45\&.0f;
370                 angles[1] = 135\&.0f;
371             }
372             else if(x == direction::LEFT_TOP_BACK)
373             {
374                 angles[0] = 225\&.0f;
375                 angles[1] = 45\&.0f;
376             }
377             else if(x == direction::RIGHT_TOP_BACK)
378             {
379                 angles[0] = 135\&.0f;
380                 angles[1] = 45\&.0f;
381             }
382             else if(x == direction::LEFT_BOTTOM_BACK)
383             {
384                 angles[0] = 225\&.0f;
385                 angles[1] = 135\&.0f;
386             }
387             else if(x == direction::RIGHT_BOTTOM_BACK)
388             {
389                 angles[0] = 135\&.0f;
390                 angles[1] = 135\&.0f;
391             }
392         }
393     }
.fi

.SS "\fBstring\fP scifir::vector_unit_nd::vectorial_custom_display (\fBconst\fP \fBstring\fP & init_dimensions, \fBint\fP number_of_decimals = \fC2\fP) const"

.PP
Definition at line \fB711\fP of file \fBvector_unit_nd\&.cpp\fP\&..PP
.nf
712     {
713         ostringstream out;
714         out << custom_display(init_dimensions,number_of_decimals);
715         for (const angle& x_angle : angles)
716         {
717             out << " " << x_angle\&.display(number_of_decimals);
718         }
719         return out\&.str();
720     }
.fi

.SS "\fBstring\fP scifir::vector_unit_nd::vectorial_derived_display (\fBint\fP number_of_decimals = \fC2\fP) const"

.PP
Definition at line \fB700\fP of file \fBvector_unit_nd\&.cpp\fP\&..PP
.nf
701     {
702         ostringstream out;
703         out << derived_display(number_of_decimals);
704         for (const angle& x_angle : angles)
705         {
706             out << " " << x_angle\&.display(number_of_decimals);
707         }
708         return out\&.str();
709     }
.fi

.SS "\fBstring\fP scifir::vector_unit_nd::vectorial_display (\fBint\fP number_of_decimals = \fC2\fP) const"

.PP
Definition at line \fB689\fP of file \fBvector_unit_nd\&.cpp\fP\&..PP
.nf
690     {
691         ostringstream out;
692         out << display(number_of_decimals);
693         for (const angle& x_angle : angles)
694         {
695             out << " " << x_angle\&.display(number_of_decimals);
696         }
697         return out\&.str();
698     }
.fi

.SS "\fBscalar_unit\fP scifir::vector_unit_nd::x_projection () const"

.PP
Definition at line \fB616\fP of file \fBvector_unit_nd\&.cpp\fP\&..PP
.nf
617     {
618         if (is_nd(1))
619         {
620             return scalar_unit(scalar_unit::value,get_dimensions());
621         }
622         else if (is_nd(2))
623         {
624             return scalar_unit(scalar_unit::value * scifir::cos(angles[0]),get_dimensions());
625         }
626         else if (is_nd(3))
627         {
628             return scalar_unit(scalar_unit::value * scifir::cos(angles[0]) * scifir::sin(angles[1]),get_dimensions());
629         }
630         else
631         {
632             return scalar_unit();
633         }
634     }
.fi

.SS "\fBscalar_unit\fP scifir::vector_unit_nd::y_projection () const"

.PP
Definition at line \fB636\fP of file \fBvector_unit_nd\&.cpp\fP\&..PP
.nf
637     {
638         if (is_nd(1))
639         {
640             return scalar_unit();
641         }
642         else if (is_nd(2))
643         {
644             return scalar_unit(scalar_unit::value * scifir::sin(angles[0]),get_dimensions());
645         }
646         else if (is_nd(3))
647         {
648             return scalar_unit(scalar_unit::value * scifir::sin(angles[0]) * scifir::sin(angles[1]),get_dimensions());
649         }
650         else
651         {
652             return scalar_unit();
653         }
654     }
.fi

.SS "\fBscalar_unit\fP scifir::vector_unit_nd::z_projection () const"

.PP
Definition at line \fB656\fP of file \fBvector_unit_nd\&.cpp\fP\&..PP
.nf
657     {
658         if (is_nd(1))
659         {
660             return scalar_unit();
661         }
662         else if (is_nd(2))
663         {
664             return scalar_unit();
665         }
666         else if (is_nd(3))
667         {
668             return scalar_unit(scalar_unit::value * scifir::cos(angles[1]),get_dimensions());
669         }
670         else
671         {
672             return scalar_unit();
673         }
674     }
.fi

.SH "Member Data Documentation"
.PP 
.SS "vector<\fBangle\fP> scifir::vector_unit_nd::angles"

.PP
Definition at line \fB230\fP of file \fBvector_unit_nd\&.hpp\fP\&.

.SH "Author"
.PP 
Generated automatically by Doxygen for scifir-units from the source code\&.
