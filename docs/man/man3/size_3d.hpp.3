.TH "special_units/size_3d.hpp" 3 "Version 2.0.0" "scifir-units" \" -*- nroff -*-
.ad l
.nh
.SH NAME
special_units/size_3d.hpp
.SH SYNOPSIS
.br
.PP
\fC#include '\&.\&./predefined_units/space_units\&.hpp'\fP
.br
\fC#include '\&.\&./util/types\&.hpp'\fP
.br
\fC#include 'boost/algorithm/string\&.hpp'\fP
.br
\fC#include <string>\fP
.br

.SS "Classes"

.in +1c
.ti -1c
.RI "class \fBscifir::size_3d< T >\fP"
.br
.ti -1c
.RI "class \fBscifir::size_3d< float >\fP"
.br
.in -1c
.SS "Namespaces"

.in +1c
.ti -1c
.RI "namespace \fBscifir\fP"
.br
.RI "The namespace scifir contains all scifir-units, excepting the string literals, which are outside\&. "
.in -1c
.SS "Functions"

.in +1c
.ti -1c
.RI "template<\fBtypename\fP T > \fBstring\fP \fBscifir::to_string\fP (\fBconst\fP \fBsize_3d\fP< T > &x)"
.br
.ti -1c
.RI "\fBstring\fP \fBscifir::to_string\fP (\fBconst\fP \fBsize_3d\fP< \fBfloat\fP > &x)"
.br
.ti -1c
.RI "template<typename T > bool \fBoperator==\fP (const \fBscifir::size_3d\fP< T > &x, const \fBscifir::size_3d\fP< T > &y)"
.br
.ti -1c
.RI "template<typename T > bool \fBoperator!=\fP (const \fBscifir::size_3d\fP< T > &x, const \fBscifir::size_3d\fP< T > &y)"
.br
.ti -1c
.RI "template<typename T > bool \fBoperator==\fP (const \fBscifir::size_3d\fP< T > &x, const string &init_size_3d)"
.br
.ti -1c
.RI "template<typename T > bool \fBoperator!=\fP (const \fBscifir::size_3d\fP< T > &x, const string &init_size_3d)"
.br
.ti -1c
.RI "template<typename T > bool \fBoperator==\fP (const string &init_size_3d, const \fBscifir::size_3d\fP< T > &x)"
.br
.ti -1c
.RI "template<typename T > bool \fBoperator!=\fP (const string &init_size_3d, const \fBscifir::size_3d\fP< T > &x)"
.br
.ti -1c
.RI "template<typename T > void \fBoperator+=\fP (string &x, const \fBscifir::size_3d\fP< T > &y)"
.br
.ti -1c
.RI "template<typename T > string \fBoperator+\fP (const string &x, const \fBscifir::size_3d\fP< T > &y)"
.br
.ti -1c
.RI "template<typename T > string \fBoperator+\fP (const \fBscifir::size_3d\fP< T > &x, const string &y)"
.br
.ti -1c
.RI "template<typename T > ostream & \fBoperator<<\fP (ostream &os, const \fBscifir::size_3d\fP< T > &x)"
.br
.ti -1c
.RI "template<typename T > istream & \fBoperator>>\fP (istream &is, \fBscifir::size_3d\fP< T > &x)"
.br
.in -1c
.SH "Function Documentation"
.PP 
.SS "template<typename T > bool operator!= (const \fBscifir::size_3d\fP< T > & x, const \fBscifir::size_3d\fP< T > & y)"

.PP
Definition at line \fB244\fP of file \fBsize_3d\&.hpp\fP\&..PP
.nf
245 {
246     return !(x == y);
247 }
.fi

.SS "template<typename T > bool operator!= (const \fBscifir::size_3d\fP< T > & x, const string & init_size_3d)"

.PP
Definition at line \fB257\fP of file \fBsize_3d\&.hpp\fP\&..PP
.nf
258 {
259     return !(x == init_size_3d);
260 }
.fi

.SS "template<typename T > bool operator!= (const string & init_size_3d, const \fBscifir::size_3d\fP< T > & x)"

.PP
Definition at line \fB270\fP of file \fBsize_3d\&.hpp\fP\&..PP
.nf
271 {
272     return !(init_size_3d == x);
273 }
.fi

.SS "template<typename T > string operator+ (const \fBscifir::size_3d\fP< T > & x, const string & y)"

.PP
Definition at line \fB288\fP of file \fBsize_3d\&.hpp\fP\&..PP
.nf
289 {
290     return to_string(x) + y;
291 }
.fi

.SS "template<typename T > string operator+ (const string & x, const \fBscifir::size_3d\fP< T > & y)"

.PP
Definition at line \fB282\fP of file \fBsize_3d\&.hpp\fP\&..PP
.nf
283 {
284     return x + to_string(y);
285 }
.fi

.SS "template<typename T > void operator+= (string & x, const \fBscifir::size_3d\fP< T > & y)"

.PP
Definition at line \fB276\fP of file \fBsize_3d\&.hpp\fP\&..PP
.nf
277 {
278     x += to_string(y);
279 }
.fi

.SS "template<typename T > ostream & operator<< (ostream & os, const \fBscifir::size_3d\fP< T > & x)"

.PP
Definition at line \fB294\fP of file \fBsize_3d\&.hpp\fP\&..PP
.nf
295 {
296     return os << to_string(x);
297 }
.fi

.SS "template<typename T > bool operator== (const \fBscifir::size_3d\fP< T > & x, const \fBscifir::size_3d\fP< T > & y)"

.PP
Definition at line \fB231\fP of file \fBsize_3d\&.hpp\fP\&..PP
.nf
232 {
233     if (x\&.width == y\&.width and x\&.height == y\&.height and x\&.depth == y\&.depth)
234     {
235         return true;
236     }
237     else
238     {
239         return false;
240     }
241 }
.fi

.SS "template<typename T > bool operator== (const \fBscifir::size_3d\fP< T > & x, const string & init_size_3d)"

.PP
Definition at line \fB250\fP of file \fBsize_3d\&.hpp\fP\&..PP
.nf
251 {
252     scifir::size_3d<T> y(init_size_3d);
253     return (x == y);
254 }
.fi

.SS "template<typename T > bool operator== (const string & init_size_3d, const \fBscifir::size_3d\fP< T > & x)"

.PP
Definition at line \fB263\fP of file \fBsize_3d\&.hpp\fP\&..PP
.nf
264 {
265     scifir::size_3d<T> y(init_size_3d);
266     return (x == y);
267 }
.fi

.SS "template<typename T > istream & operator>> (istream & is, \fBscifir::size_3d\fP< T > & x)"

.PP
Definition at line \fB300\fP of file \fBsize_3d\&.hpp\fP\&..PP
.nf
301 {
302     char a[256];
303     is\&.getline(a, 256);
304     string b(a);
305     x = scifir::size_3d<T>(b);
306     return is;
307 }
.fi

.SH "Author"
.PP 
Generated automatically by Doxygen for scifir-units from the source code\&.
