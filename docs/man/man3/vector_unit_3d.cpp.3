.TH "units/vector_unit_3d.cpp" 3 "Version 2.0.0" "scifir-units" \" -*- nroff -*-
.ad l
.nh
.SH NAME
units/vector_unit_3d.cpp
.SH SYNOPSIS
.br
.PP
\fC#include '\&./vector_unit_3d\&.hpp'\fP
.br
\fC#include '\&.\&./coordinates/coordinates_3d\&.hpp'\fP
.br
\fC#include '\&.\&./util/types\&.hpp'\fP
.br

.SS "Namespaces"

.in +1c
.ti -1c
.RI "namespace \fBscifir\fP"
.br
.RI "The namespace scifir contains all scifir-units, excepting the string literals, which are outside\&. "
.in -1c
.SS "Functions"

.in +1c
.ti -1c
.RI "\fBscalar_unit\fP \fBscifir::norm\fP (\fBconst\fP \fBvector_unit_3d\fP &x)"
.br
.ti -1c
.RI "\fBvector_unit_3d\fP \fBscifir::sqrt\fP (\fBconst\fP \fBvector_unit_3d\fP &x)"
.br
.ti -1c
.RI "\fBvector_unit_3d\fP \fBscifir::sqrt_nth\fP (\fBconst\fP \fBvector_unit_3d\fP &x, \fBint\fP index)"
.br
.ti -1c
.RI "\fBscalar_unit\fP \fBscifir::dot_product\fP (\fBconst\fP \fBvector_unit_3d\fP &x, \fBconst\fP \fBvector_unit_3d\fP &y)"
.br
.ti -1c
.RI "\fBvector_unit_3d\fP \fBscifir::cross_product\fP (\fBconst\fP \fBvector_unit_3d\fP &x, \fBconst\fP \fBvector_unit_3d\fP &y)"
.br
.ti -1c
.RI "\fBangle\fP \fBscifir::angle_between\fP (\fBconst\fP \fBvector_unit_3d\fP &x, \fBconst\fP \fBvector_unit_3d\fP &y)"
.br
.ti -1c
.RI "\fBbool\fP \fBscifir::same_direction\fP (\fBconst\fP \fBvector_unit_3d\fP &x, \fBconst\fP \fBvector_unit_3d\fP &y)"
.br
.ti -1c
.RI "\fBbool\fP \fBscifir::parallel\fP (\fBconst\fP \fBvector_unit_3d\fP &x, \fBconst\fP \fBvector_unit_3d\fP &y)"
.br
.ti -1c
.RI "\fBbool\fP \fBscifir::orthogonal\fP (\fBconst\fP \fBvector_unit_3d\fP &x, \fBconst\fP \fBvector_unit_3d\fP &y)"
.br
.ti -1c
.RI "\fBscifir::vector_unit_3d\fP \fBoperator*\fP (const \fBscifir::scalar_unit\fP &x, const \fBscifir::vector_unit_3d\fP &y)"
.br
.ti -1c
.RI "bool \fBoperator!=\fP (const \fBscifir::vector_unit_3d\fP &x, const \fBscifir::vector_unit_3d\fP &y)"
.br
.ti -1c
.RI "bool \fBoperator==\fP (const \fBscifir::vector_unit_3d\fP &x, const string &init_vector_3d)"
.br
.ti -1c
.RI "bool \fBoperator!=\fP (const \fBscifir::vector_unit_3d\fP &x, const string &init_vector_3d)"
.br
.ti -1c
.RI "bool \fBoperator==\fP (const string &init_vector_3d, const \fBscifir::vector_unit_3d\fP &y)"
.br
.ti -1c
.RI "bool \fBoperator!=\fP (const string &init_vector_3d, const \fBscifir::vector_unit_3d\fP &y)"
.br
.ti -1c
.RI "void \fBoperator+=\fP (string &x, const \fBscifir::vector_unit_3d\fP &y)"
.br
.ti -1c
.RI "string \fBoperator+\fP (const string &x, const \fBscifir::vector_unit_3d\fP &y)"
.br
.ti -1c
.RI "string \fBoperator+\fP (const \fBscifir::vector_unit_3d\fP &y, const string &x)"
.br
.ti -1c
.RI "ostream & \fBoperator<<\fP (ostream &os, const \fBscifir::vector_unit_3d\fP &x)"
.br
.ti -1c
.RI "istream & \fBoperator>>\fP (istream &is, \fBscifir::vector_unit_3d\fP &x)"
.br
.in -1c
.SH "Function Documentation"
.PP 
.SS "bool operator!= (const \fBscifir::vector_unit_3d\fP & x, const \fBscifir::vector_unit_3d\fP & y)"

.PP
Definition at line \fB515\fP of file \fBvector_unit_3d\&.cpp\fP\&..PP
.nf
516 {
517     return !(x == y);
518 }
.fi

.SS "bool operator!= (const \fBscifir::vector_unit_3d\fP & x, const string & init_vector_3d)"

.PP
Definition at line \fB526\fP of file \fBvector_unit_3d\&.cpp\fP\&..PP
.nf
527 {
528     return !(x == init_vector_3d);
529 }
.fi

.SS "bool operator!= (const string & init_vector_3d, const \fBscifir::vector_unit_3d\fP & y)"

.PP
Definition at line \fB537\fP of file \fBvector_unit_3d\&.cpp\fP\&..PP
.nf
538 {
539     return !(init_vector_3d == y);
540 }
.fi

.SS "\fBscifir::vector_unit_3d\fP operator* (const \fBscifir::scalar_unit\fP & x, const \fBscifir::vector_unit_3d\fP & y)"

.PP
Definition at line \fB508\fP of file \fBvector_unit_3d\&.cpp\fP\&..PP
.nf
509 {
510     long double new_value = x\&.get_value() * y\&.get_value();
511     vector<scifir::dimension> new_dimensions = multiply_dimensions(x\&.get_dimensions(), y\&.get_dimensions(),new_value);
512     return scifir::vector_unit_3d(float(new_value), new_dimensions, y\&.theta, y\&.phi);
513 }
.fi

.SS "string operator+ (const \fBscifir::vector_unit_3d\fP & y, const string & x)"

.PP
Definition at line \fB557\fP of file \fBvector_unit_3d\&.cpp\fP\&..PP
.nf
558 {
559     ostringstream output;
560     output << y;
561     output << x;
562     return output\&.str();
563 }
.fi

.SS "string operator+ (const string & x, const \fBscifir::vector_unit_3d\fP & y)"

.PP
Definition at line \fB549\fP of file \fBvector_unit_3d\&.cpp\fP\&..PP
.nf
550 {
551     ostringstream output;
552     output << x;
553     output << y;
554     return output\&.str();
555 }
.fi

.SS "void operator+= (string & x, const \fBscifir::vector_unit_3d\fP & y)"

.PP
Definition at line \fB542\fP of file \fBvector_unit_3d\&.cpp\fP\&..PP
.nf
543 {
544     ostringstream output;
545     output << y;
546     x += output\&.str();
547 }
.fi

.SS "ostream & operator<< (ostream & os, const \fBscifir::vector_unit_3d\fP & x)"

.PP
Definition at line \fB565\fP of file \fBvector_unit_3d\&.cpp\fP\&..PP
.nf
566 {
567     return os << to_string(x);
568 }
.fi

.SS "bool operator== (const \fBscifir::vector_unit_3d\fP & x, const string & init_vector_3d)"

.PP
Definition at line \fB520\fP of file \fBvector_unit_3d\&.cpp\fP\&..PP
.nf
521 {
522     scifir::vector_unit_3d y(init_vector_3d);
523     return (x == y);
524 }
.fi

.SS "bool operator== (const string & init_vector_3d, const \fBscifir::vector_unit_3d\fP & y)"

.PP
Definition at line \fB531\fP of file \fBvector_unit_3d\&.cpp\fP\&..PP
.nf
532 {
533     scifir::vector_unit_3d x(init_vector_3d);
534     return (x == y);
535 }
.fi

.SS "istream & operator>> (istream & is, \fBscifir::vector_unit_3d\fP & x)"

.PP
Definition at line \fB570\fP of file \fBvector_unit_3d\&.cpp\fP\&..PP
.nf
571 {
572     char a[256];
573     is\&.getline(a, 256);
574     string b(a);
575     boost::trim(b);
576     x = scifir::vector_unit_3d(b);
577     return is;
578 }
.fi

.SH "Author"
.PP 
Generated automatically by Doxygen for scifir-units from the source code\&.
