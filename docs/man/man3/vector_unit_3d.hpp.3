.TH "units/vector_unit_3d.hpp" 3 "Version 2.0.0" "scifir-units" \" -*- nroff -*-
.ad l
.nh
.SH NAME
units/vector_unit_3d.hpp
.SH SYNOPSIS
.br
.PP
\fC#include '\&.\&./units/scalar_unit\&.hpp'\fP
.br
\fC#include '\&.\&./units/vector_unit_2d\&.hpp'\fP
.br
\fC#include '\&.\&./units/vector_unit_nd\&.hpp'\fP
.br
\fC#include '\&.\&./meca_number/angle\&.hpp'\fP
.br
\fC#include '\&.\&./util/is_number\&.hpp'\fP
.br
\fC#include '\&.\&./topology/direction\&.hpp'\fP
.br
\fC#include 'boost/algorithm/string\&.hpp'\fP
.br
\fC#include <cmath>\fP
.br
\fC#include <functional>\fP
.br
\fC#include <iostream>\fP
.br
\fC#include <list>\fP
.br
\fC#include <sstream>\fP
.br
\fC#include <string>\fP
.br
\fC#include <vector>\fP
.br

.SS "Classes"

.in +1c
.ti -1c
.RI "class \fBscifir::vector_unit_3d\fP"
.br
.in -1c
.SS "Namespaces"

.in +1c
.ti -1c
.RI "namespace \fBscifir\fP"
.br
.RI "The namespace scifir contains all scifir-units, excepting the string literals, which are outside\&. "
.in -1c
.SS "Macros"

.in +1c
.ti -1c
.RI "#define \fBVECTOR_UNIT_3D_HPP_BEGIN\fP(name)"
.br
.ti -1c
.RI "#define \fBVECTOR_UNIT_3D_HPP_END\fP()"
.br
.ti -1c
.RI "#define \fBVECTOR_UNIT_3D_HPP\fP(name)"
.br
.ti -1c
.RI "#define \fBVECTOR_UNIT_3D_CPP\fP(name,  init_dimensions)"
.br
.ti -1c
.RI "#define \fBVECTOR_UNIT_HPP\fP(name)"
.br
.ti -1c
.RI "#define \fBVECTOR_UNIT_CPP\fP(name,  init_dimensions)"
.br
.in -1c
.SS "Functions"

.in +1c
.ti -1c
.RI "\fBstring\fP \fBscifir::to_string\fP (\fBconst\fP \fBvector_unit_3d\fP &x)"
.br
.ti -1c
.RI "\fBscalar_unit\fP \fBscifir::norm\fP (\fBconst\fP \fBvector_unit_3d\fP &x)"
.br
.ti -1c
.RI "\fBvector_unit_3d\fP \fBscifir::sqrt\fP (\fBconst\fP \fBvector_unit_3d\fP &x)"
.br
.ti -1c
.RI "\fBvector_unit_3d\fP \fBscifir::sqrt_nth\fP (\fBconst\fP \fBvector_unit_3d\fP &x, \fBint\fP index)"
.br
.ti -1c
.RI "\fBscalar_unit\fP \fBscifir::dot_product\fP (\fBconst\fP \fBvector_unit_3d\fP &x, \fBconst\fP \fBvector_unit_3d\fP &y)"
.br
.ti -1c
.RI "\fBvector_unit_3d\fP \fBscifir::cross_product\fP (\fBconst\fP \fBvector_unit_3d\fP &x, \fBconst\fP \fBvector_unit_3d\fP &y)"
.br
.ti -1c
.RI "\fBangle\fP \fBscifir::angle_between\fP (\fBconst\fP \fBvector_unit_3d\fP &x, \fBconst\fP \fBvector_unit_3d\fP &y)"
.br
.ti -1c
.RI "\fBbool\fP \fBscifir::same_direction\fP (\fBconst\fP \fBvector_unit_3d\fP &x, \fBconst\fP \fBvector_unit_3d\fP &y)"
.br
.ti -1c
.RI "\fBbool\fP \fBscifir::parallel\fP (\fBconst\fP \fBvector_unit_3d\fP &x, \fBconst\fP \fBvector_unit_3d\fP &y)"
.br
.ti -1c
.RI "\fBbool\fP \fBscifir::orthogonal\fP (\fBconst\fP \fBvector_unit_3d\fP &x, \fBconst\fP \fBvector_unit_3d\fP &y)"
.br
.ti -1c
.RI "\fBscifir::vector_unit_3d\fP \fBoperator*\fP (const \fBscifir::scalar_unit\fP &x, const \fBscifir::vector_unit_3d\fP &y)"
.br
.ti -1c
.RI "template<typename T , typename  = typename enable_if<scifir::is_number<T>::value>::type> \fBscifir::vector_unit_3d\fP \fBoperator+\fP (const T y, const \fBscifir::vector_unit_3d\fP &x)"
.br
.ti -1c
.RI "template<typename T , typename  = typename enable_if<scifir::is_number<T>::value>::type> \fBscifir::vector_unit_3d\fP \fBoperator\-\fP (const T y, const \fBscifir::vector_unit_3d\fP &x)"
.br
.ti -1c
.RI "template<typename T , typename  = typename enable_if<scifir::is_number<T>::value>::type> \fBscifir::vector_unit_3d\fP \fBoperator*\fP (const T y, const \fBscifir::vector_unit_3d\fP &x)"
.br
.ti -1c
.RI "template<typename T , typename  = typename enable_if<scifir::is_number<T>::value>::type> \fBscifir::vector_unit_3d\fP \fBoperator/\fP (const T y, const \fBscifir::vector_unit_3d\fP &x)"
.br
.ti -1c
.RI "bool \fBoperator!=\fP (const \fBscifir::vector_unit_3d\fP &x, const \fBscifir::vector_unit_3d\fP &y)"
.br
.ti -1c
.RI "bool \fBoperator==\fP (const \fBscifir::vector_unit_3d\fP &x, const string &init_vector_3d)"
.br
.ti -1c
.RI "bool \fBoperator!=\fP (const \fBscifir::vector_unit_3d\fP &x, const string &init_vector_3d)"
.br
.ti -1c
.RI "bool \fBoperator==\fP (const string &init_vector_3d, const \fBscifir::vector_unit_3d\fP &x)"
.br
.ti -1c
.RI "bool \fBoperator!=\fP (const string &init_vector_3d, const \fBscifir::vector_unit_3d\fP &x)"
.br
.ti -1c
.RI "void \fBoperator+=\fP (string &x, const \fBscifir::vector_unit_3d\fP &y)"
.br
.ti -1c
.RI "string \fBoperator+\fP (const string &x, const \fBscifir::vector_unit_3d\fP &y)"
.br
.ti -1c
.RI "string \fBoperator+\fP (const \fBscifir::vector_unit_3d\fP &y, const string &x)"
.br
.ti -1c
.RI "ostream & \fBoperator<<\fP (ostream &os, const \fBscifir::vector_unit_3d\fP &x)"
.br
.ti -1c
.RI "istream & \fBoperator>>\fP (istream &is, \fBscifir::vector_unit_3d\fP &x)"
.br
.in -1c
.SH "Macro Definition Documentation"
.PP 
.SS "#define VECTOR_UNIT_3D_CPP(name, init_dimensions)"
\fBValue:\fP.PP
.nf
    name##_3d::name##_3d() : vector_unit_3d() {} \\
    name##_3d::name##_3d(const name##_3d& x) : vector_unit_3d(x) {} \\
    name##_3d::name##_3d(name##_3d&& x) : vector_unit_3d(std::move(x)) {} \\
const string name##_3d::dimensions_match = init_dimensions; \\
const vector<dimension> name##_3d::real_dimensions = create_derived_dimensions(init_dimensions)
.fi

.PP
Definition at line \fB52\fP of file \fBvector_unit_3d\&.hpp\fP\&..PP
.nf
52                                                                       : vector_unit_3d() {} \\
53     name##_3d::name##_3d(const name##_3d& x) : vector_unit_3d(x) {} \\
54     name##_3d::name##_3d(name##_3d&& x) : vector_unit_3d(std::move(x)) {} \\
55 const string name##_3d::dimensions_match = init_dimensions; \\
56 const vector<dimension> name##_3d::real_dimensions = create_derived_dimensions(init_dimensions)
.fi

.SS "#define VECTOR_UNIT_3D_HPP(name)"
\fBValue:\fP.PP
.nf
    class name##_3d : public vector_unit_3d \\
    {   \\
        public: \\
            using vector_unit_3d::vector_unit_3d; \\
            name##_3d(); \\
            name##_3d(const name##_3d&); \\
            name##_3d(name##_3d&&); \\
            using vector_unit_3d::operator=; \\
            using vector_unit_3d::operator+=; \\
            using vector_unit_3d::operator\-=; \\
\\
            static const string dimensions_match; \\
            static const vector<dimension> real_dimensions; \\
    }
.fi

.PP
Definition at line \fB37\fP of file \fBvector_unit_3d\&.hpp\fP\&..PP
.nf
37                                                  : public vector_unit_3d \\
38     {   \\
39         public: \\
40             using vector_unit_3d::vector_unit_3d; \\
41             name##_3d(); \\
42             name##_3d(const name##_3d&); \\
43             name##_3d(name##_3d&&); \\
44             using vector_unit_3d::operator=; \\
45             using vector_unit_3d::operator+=; \\
46             using vector_unit_3d::operator\-=; \\
47 \\
48             static const string dimensions_match; \\
49             static const vector<dimension> real_dimensions; \\
50     }
.fi

.SS "#define VECTOR_UNIT_3D_HPP_BEGIN(name)"
\fBValue:\fP.PP
.nf
    class name##_3d : public vector_unit_3d \\
    {   \\
        public: \\
            using vector_unit_3d::vector_unit_3d; \\
            name##_3d(); \\
            name##_3d(const name##_3d&); \\
            name##_3d(name##_3d&&); \\
            using vector_unit_3d::operator=; \\
            using vector_unit_3d::operator+=; \\
            using vector_unit_3d::operator\-=
.fi

.PP
Definition at line \fB21\fP of file \fBvector_unit_3d\&.hpp\fP\&..PP
.nf
21                                                        : public vector_unit_3d \\
22     {   \\
23         public: \\
24             using vector_unit_3d::vector_unit_3d; \\
25             name##_3d(); \\
26             name##_3d(const name##_3d&); \\
27             name##_3d(name##_3d&&); \\
28             using vector_unit_3d::operator=; \\
29             using vector_unit_3d::operator+=; \\
30             using vector_unit_3d::operator\-=
.fi

.SS "#define VECTOR_UNIT_3D_HPP_END()"
\fBValue:\fP.PP
.nf
        public: \\
        static const string dimensions_match; \\
        static const vector<dimension> real_dimensions; \\
    }
.fi

.PP
Definition at line \fB32\fP of file \fBvector_unit_3d\&.hpp\fP\&..PP
.nf
32                                        : \\
33         static const string dimensions_match; \\
34         static const vector<dimension> real_dimensions; \\
35     }
.fi

.SS "#define VECTOR_UNIT_CPP(name, init_dimensions)"
\fBValue:\fP.PP
.nf
SCALAR_UNIT_CPP(name,init_dimensions); \\
VECTOR_UNIT_2D_CPP(name,init_dimensions); \\
VECTOR_UNIT_3D_CPP(name,init_dimensions); \\
VECTOR_UNIT_ND_CPP(name,init_dimensions)
.fi

.PP
Definition at line \fB63\fP of file \fBvector_unit_3d\&.hpp\fP\&.
.SS "#define VECTOR_UNIT_HPP(name)"
\fBValue:\fP.PP
.nf
SCALAR_UNIT_HPP(name); \\
VECTOR_UNIT_2D_HPP(name); \\
VECTOR_UNIT_3D_HPP(name); \\
VECTOR_UNIT_ND_HPP(name)
.fi

.PP
Definition at line \fB58\fP of file \fBvector_unit_3d\&.hpp\fP\&.
.SH "Function Documentation"
.PP 
.SS "bool operator!= (const \fBscifir::vector_unit_3d\fP & x, const \fBscifir::vector_unit_3d\fP & y)"

.PP
Definition at line \fB515\fP of file \fBvector_unit_3d\&.cpp\fP\&..PP
.nf
516 {
517     return !(x == y);
518 }
.fi

.SS "bool operator!= (const \fBscifir::vector_unit_3d\fP & x, const string & init_vector_3d)"

.PP
Definition at line \fB526\fP of file \fBvector_unit_3d\&.cpp\fP\&..PP
.nf
527 {
528     return !(x == init_vector_3d);
529 }
.fi

.SS "bool operator!= (const string & init_vector_3d, const \fBscifir::vector_unit_3d\fP & x)"

.PP
Definition at line \fB537\fP of file \fBvector_unit_3d\&.cpp\fP\&..PP
.nf
538 {
539     return !(init_vector_3d == y);
540 }
.fi

.SS "\fBscifir::vector_unit_3d\fP operator* (const \fBscifir::scalar_unit\fP & x, const \fBscifir::vector_unit_3d\fP & y)"

.PP
Definition at line \fB508\fP of file \fBvector_unit_3d\&.cpp\fP\&..PP
.nf
509 {
510     long double new_value = x\&.get_value() * y\&.get_value();
511     vector<scifir::dimension> new_dimensions = multiply_dimensions(x\&.get_dimensions(), y\&.get_dimensions(),new_value);
512     return scifir::vector_unit_3d(float(new_value), new_dimensions, y\&.theta, y\&.phi);
513 }
.fi

.SS "template<typename T , typename  = typename enable_if<scifir::is_number<T>::value>::type> \fBscifir::vector_unit_3d\fP operator* (const T y, const \fBscifir::vector_unit_3d\fP & x)"

.PP
Definition at line \fB266\fP of file \fBvector_unit_3d\&.hpp\fP\&..PP
.nf
267 {
268     scifir::vector_unit_3d z = x;
269     z *= y;
270     return z;
271 }
.fi

.SS "string operator+ (const \fBscifir::vector_unit_3d\fP & y, const string & x)"

.PP
Definition at line \fB557\fP of file \fBvector_unit_3d\&.cpp\fP\&..PP
.nf
558 {
559     ostringstream output;
560     output << y;
561     output << x;
562     return output\&.str();
563 }
.fi

.SS "string operator+ (const string & x, const \fBscifir::vector_unit_3d\fP & y)"

.PP
Definition at line \fB549\fP of file \fBvector_unit_3d\&.cpp\fP\&..PP
.nf
550 {
551     ostringstream output;
552     output << x;
553     output << y;
554     return output\&.str();
555 }
.fi

.SS "template<typename T , typename  = typename enable_if<scifir::is_number<T>::value>::type> \fBscifir::vector_unit_3d\fP operator+ (const T y, const \fBscifir::vector_unit_3d\fP & x)"

.PP
Definition at line \fB252\fP of file \fBvector_unit_3d\&.hpp\fP\&..PP
.nf
253 {
254     scifir::vector_unit_3d z = x;
255     z += y;
256     return z;
257 }
.fi

.SS "void operator+= (string & x, const \fBscifir::vector_unit_3d\fP & y)"

.PP
Definition at line \fB542\fP of file \fBvector_unit_3d\&.cpp\fP\&..PP
.nf
543 {
544     ostringstream output;
545     output << y;
546     x += output\&.str();
547 }
.fi

.SS "template<typename T , typename  = typename enable_if<scifir::is_number<T>::value>::type> \fBscifir::vector_unit_3d\fP operator\- (const T y, const \fBscifir::vector_unit_3d\fP & x)"

.PP
Definition at line \fB260\fP of file \fBvector_unit_3d\&.hpp\fP\&..PP
.nf
261 {
262     return scifir::vector_unit_3d(y \- x\&.get_value(),x\&.get_dimensions(),x\&.theta,x\&.phi);
263 }
.fi

.SS "template<typename T , typename  = typename enable_if<scifir::is_number<T>::value>::type> \fBscifir::vector_unit_3d\fP operator/ (const T y, const \fBscifir::vector_unit_3d\fP & x)"

.PP
Definition at line \fB274\fP of file \fBvector_unit_3d\&.hpp\fP\&..PP
.nf
275 {
276     vector<scifir::dimension> new_dimensions = x\&.get_dimensions();
277     for (scifir::dimension& new_dimension : new_dimensions)
278     {
279         new_dimension\&.invert();
280     }
281     return scifir::vector_unit_3d(y / x\&.get_value(),new_dimensions,x\&.theta,x\&.phi);
282 }
.fi

.SS "ostream & operator<< (ostream & os, const \fBscifir::vector_unit_3d\fP & x)"

.PP
Definition at line \fB565\fP of file \fBvector_unit_3d\&.cpp\fP\&..PP
.nf
566 {
567     return os << to_string(x);
568 }
.fi

.SS "bool operator== (const \fBscifir::vector_unit_3d\fP & x, const string & init_vector_3d)"

.PP
Definition at line \fB520\fP of file \fBvector_unit_3d\&.cpp\fP\&..PP
.nf
521 {
522     scifir::vector_unit_3d y(init_vector_3d);
523     return (x == y);
524 }
.fi

.SS "bool operator== (const string & init_vector_3d, const \fBscifir::vector_unit_3d\fP & x)"

.PP
Definition at line \fB531\fP of file \fBvector_unit_3d\&.cpp\fP\&..PP
.nf
532 {
533     scifir::vector_unit_3d x(init_vector_3d);
534     return (x == y);
535 }
.fi

.SS "istream & operator>> (istream & is, \fBscifir::vector_unit_3d\fP & x)"

.PP
Definition at line \fB570\fP of file \fBvector_unit_3d\&.cpp\fP\&..PP
.nf
571 {
572     char a[256];
573     is\&.getline(a, 256);
574     string b(a);
575     boost::trim(b);
576     x = scifir::vector_unit_3d(b);
577     return is;
578 }
.fi

.SH "Author"
.PP 
Generated automatically by Doxygen for scifir-units from the source code\&.
