.TH "units/vector_unit_nd.hpp" 3 "Sat Jul 13 2024" "Version 2.0.0" "scifir-units" \" -*- nroff -*-
.ad l
.nh
.SH NAME
units/vector_unit_nd.hpp
.SH SYNOPSIS
.br
.PP
\fC#include '\&.\&./units/scalar_unit\&.hpp'\fP
.br
\fC#include '\&.\&./meca_number/angle\&.hpp'\fP
.br
\fC#include '\&.\&./util/is_number\&.hpp'\fP
.br
\fC#include '\&.\&./topology/direction\&.hpp'\fP
.br
\fC#include 'boost/algorithm/string\&.hpp'\fP
.br
\fC#include <cmath>\fP
.br
\fC#include <functional>\fP
.br
\fC#include <iostream>\fP
.br
\fC#include <list>\fP
.br
\fC#include <sstream>\fP
.br
\fC#include <string>\fP
.br
\fC#include <vector>\fP
.br

.SS "Classes"

.in +1c
.ti -1c
.RI "class \fBscifir::vector_unit_nd\fP"
.br
.in -1c
.SS "Namespaces"

.in +1c
.ti -1c
.RI " \fBscifir\fP"
.br
.RI "The namespace scifir contains all scifir-units, excepting the string literals, which are outside\&. "
.in -1c
.SS "Macros"

.in +1c
.ti -1c
.RI "#define \fBVECTOR_UNIT_ND_HPP_BEGIN\fP(name)"
.br
.ti -1c
.RI "#define \fBVECTOR_UNIT_ND_HPP_END\fP()"
.br
.ti -1c
.RI "#define \fBVECTOR_UNIT_ND_HPP\fP(name)"
.br
.ti -1c
.RI "#define \fBVECTOR_UNIT_ND_CPP\fP(name,  init_dimensions)"
.br
.in -1c
.SS "Functions"

.in +1c
.ti -1c
.RI "string \fBscifir::to_string\fP (const vector_unit_nd &x)"
.br
.RI "It generates a string representation of \fBvector_unit_nd\fP\&. "
.ti -1c
.RI "scalar_unit \fBscifir::norm\fP (const vector_unit_nd &x)"
.br
.RI "It returns the value of the vector, which is the value in 1D, p in 2D (polar coordinates), or r in 3D (spherical coordinates)\&. "
.ti -1c
.RI "vector_unit_nd \fBscifir::sqrt\fP (const vector_unit_nd &x)"
.br
.RI "It squares the vector, creating a \fBvector_unit_nd\fP with the value squared and always the same angles\&. The dimensions are squared with the same rules for the square of dimensions than \fBscalar_unit\fP classes\&. "
.ti -1c
.RI "vector_unit_nd \fBscifir::sqrt_nth\fP (const vector_unit_nd &x, int index)"
.br
.RI "It takes the root of the vector with the index given, creating a \fBvector_unit_nd\fP with the value rooted to that index and always maintains the same angles\&. The dimensions are squared with the same rules for the square of dimensions than \fBscalar_unit\fP classes\&. "
.ti -1c
.RI "scalar_unit \fBscifir::dot_product\fP (const vector_unit_nd &x, const vector_unit_nd &y)"
.br
.RI "Creates a \fBscalar_unit\fP as the dot product of the two vectors x and y\&. "
.ti -1c
.RI "vector_unit_nd \fBscifir::cross_product\fP (const vector_unit_nd &x, const vector_unit_nd &y)"
.br
.RI "Creates a \fBvector_unit_nd\fP as the cross product of the two vectors x and y\&. If both vectors aren't in 3D, it returns an empty \fBvector_unit_nd\fP, because the cross product doesn't exists outside 3D\&. "
.ti -1c
.RI "angle \fBscifir::angle_between\fP (const vector_unit_nd &x, const vector_unit_nd &y)"
.br
.RI "Returns the angle between two vectors x and y inside the ND space, which can be 2D or 3D, depending on the ND of the vectors\&. If the vectors have different ND, it returns an empty \fBvector_unit_nd\fP instead\&. "
.ti -1c
.RI "bool \fBscifir::same_nd\fP (const vector_unit_nd &x, const vector_unit_nd &y)"
.br
.RI "Checks if two vectors have the same number of dimensions\&. "
.ti -1c
.RI "bool \fBscifir::same_direction\fP (const vector_unit_nd &x, const vector_unit_nd &y)"
.br
.RI "Checks if two vectors x and y have the same direction\&. Both vectors must have the same ND, otherwise it returns an empty \fBvector_unit_nd\fP instead\&. "
.ti -1c
.RI "bool \fBscifir::parallel\fP (const vector_unit_nd &x, const vector_unit_nd &y)"
.br
.RI "Checks if two vectors x and y are parallel, which means that their direction is the same or the exact opposite\&. Both vectors must have the same ND, otherwise it returns an empty \fBvector_unit_nd\fP instead\&. "
.ti -1c
.RI "bool \fBscifir::orthogonal\fP (const vector_unit_nd &x, const vector_unit_nd &y)"
.br
.RI "Checks if two vectors x and y are orthogonal, that's, if they have 90 degrees between them\&. Both vectors must have the same ND, otherwise it returns an empty \fBvector_unit_nd\fP instead\&. "
.ti -1c
.RI "\fBscifir::vector_unit_nd\fP \fBoperator*\fP (const \fBscifir::scalar_unit\fP &x, const \fBscifir::vector_unit_nd\fP &y)"
.br
.RI "It creates a new vector_unitn3d scaling a vector_unit_nd by the scalar_unit x\&. "
.ti -1c
.RI "template<typename T , typename  = typename enable_if<scifir::is_number<T>::value>::type> \fBscifir::vector_unit_nd\fP \fBoperator+\fP (const T y, const \fBscifir::vector_unit_nd\fP &x)"
.br
.RI "It creates a new vector as the addition of the numeric type x to the value\&. The angles are not changed\&. "
.ti -1c
.RI "template<typename T , typename  = typename enable_if<scifir::is_number<T>::value>::type> \fBscifir::vector_unit_nd\fP \fBoperator\-\fP (const T y, const \fBscifir::vector_unit_nd\fP &x)"
.br
.RI "It creates a new vector as the substraction of the numeric type x to the value\&. The angles are not changed\&. "
.ti -1c
.RI "template<typename T , typename  = typename enable_if<scifir::is_number<T>::value>::type> \fBscifir::vector_unit_nd\fP \fBoperator*\fP (const T y, const \fBscifir::vector_unit_nd\fP &x)"
.br
.RI "It creates a new vector as the multiplication of the numeric type x to the value\&. The angles are not changed\&. "
.ti -1c
.RI "template<typename T , typename  = typename enable_if<scifir::is_number<T>::value>::type> \fBscifir::vector_unit_nd\fP \fBoperator/\fP (const T y, const \fBscifir::vector_unit_nd\fP &x)"
.br
.RI "It creates a new vector as the division of the value with the numeric type x\&. The angles are not changed\&. "
.ti -1c
.RI "bool \fBoperator!=\fP (const \fBscifir::vector_unit_nd\fP &x, const \fBscifir::vector_unit_nd\fP &y)"
.br
.RI "Comparison operator\&. Two vector_unit_nd are not equal if their value, dimensions or angles are different\&. "
.ti -1c
.RI "bool \fBoperator==\fP (const \fBscifir::vector_unit_nd\fP &x, const string &init_vector_nd)"
.br
.RI "Returns true if x is equal to the vector_unit_nd initialized with the string being compared\&. The vectorial_display() function is not used, and so the values are compared with all its decimal numbers\&. "
.ti -1c
.RI "bool \fBoperator!=\fP (const \fBscifir::vector_unit_nd\fP &x, const string &init_vector_nd)"
.br
.RI "Returns true if x is not equal to the vector_unit_nd initialized with the string being compared\&. The vectorial_display() function is not used, and so the values are compared with all its decimal numbers\&. "
.ti -1c
.RI "bool \fBoperator==\fP (const string &init_vector_nd, const \fBscifir::vector_unit_nd\fP &x)"
.br
.RI "Returns true if x is equal to the vector_unit_nd initialized with the string being compared\&. The vectorial_display() function is not used, and so the values are compared with all its decimal numbers\&. "
.ti -1c
.RI "bool \fBoperator!=\fP (const string &init_vector_nd, const \fBscifir::vector_unit_nd\fP &x)"
.br
.RI "Returns true if x is not equal to the vector_unit_nd initialized with the string being compared\&. The vectorial_display() function is not used, and so the values are compared with all its decimal numbers\&. "
.ti -1c
.RI "void \fBoperator+=\fP (string &x, const \fBscifir::vector_unit_nd\fP &y)"
.br
.RI "Concatenates the string representation of the vector_unit_nd y to the string x\&. "
.ti -1c
.RI "string \fBoperator+\fP (const string &x, const \fBscifir::vector_unit_nd\fP &y)"
.br
.RI "Creates a new string as the concatenation of the string x with the representation string of the vector_unit_nd y\&. "
.ti -1c
.RI "string \fBoperator+\fP (const \fBscifir::vector_unit_nd\fP &y, const string &x)"
.br
.RI "Creates a new string as the concatenation of the string x with the representation string of the vector_unit_nd y\&. "
.ti -1c
.RI "ostream & \fBoperator<<\fP (ostream &os, const \fBscifir::vector_unit_nd\fP &x)"
.br
.RI "Adds the string representation of the vector_unit_nd x to an output stream os\&. "
.ti -1c
.RI "istream & \fBoperator>>\fP (istream &is, \fBscifir::vector_unit_nd\fP &x)"
.br
.RI "Allows that an istream initializes by string a vector_unit_nd x\&. "
.in -1c
.SH "Macro Definition Documentation"
.PP 
.SS "#define VECTOR_UNIT_ND_CPP(name, init_dimensions)"
\fBValue:\fP
.PP
.nf
 name##_nd::name##_nd() : vector_unit_nd() {} \
    name##_nd::name##_nd(const name##_nd& x) : vector_unit_nd(x) {} \
    name##_nd::name##_nd(name##_nd&& x) : vector_unit_nd(std::move(x)) {} \
const string name##_nd::dimensions_match = init_dimensions; \
const vector<dimension> name##_nd::real_dimensions = create_derived_dimensions(init_dimensions)
.fi
.PP
Definition at line 50 of file vector_unit_nd\&.hpp\&.
.SS "#define VECTOR_UNIT_ND_HPP(name)"
\fBValue:\fP
.PP
.nf
 class name##_nd : public vector_unit_nd \
    {   \
        public: \
            using vector_unit_nd::vector_unit_nd; \
            name##_nd(); \
            name##_nd(const name##_nd&); \
            name##_nd(name##_nd&&); \
            using vector_unit_nd::operator =; \
            using vector_unit_nd::operator+=; \
            using vector_unit_nd::operator-=; \
\
            static const string dimensions_match; \
            static const vector<dimension> real_dimensions; \
    }
.fi
.PP
Definition at line 35 of file vector_unit_nd\&.hpp\&.
.SS "#define VECTOR_UNIT_ND_HPP_BEGIN(name)"
\fBValue:\fP
.PP
.nf
   class name##_nd : public vector_unit_nd \
    {   \
        public: \
            using vector_unit_nd::vector_unit_nd; \
            name##_nd(); \
            name##_nd(const name##_nd&); \
            name##_nd(name##_nd&&); \
            using vector_unit_nd::operator =; \
            using vector_unit_nd::operator+=; \
            using vector_unit_nd::operator-=
.fi
.PP
Definition at line 19 of file vector_unit_nd\&.hpp\&.
.SS "#define VECTOR_UNIT_ND_HPP_END()"
\fBValue:\fP
.PP
.nf
     public: \
        static const string dimensions_match; \
        static const vector<dimension> real_dimensions; \
    }
.fi
.PP
Definition at line 30 of file vector_unit_nd\&.hpp\&.
.SH "Function Documentation"
.PP 
.SS "bool operator!= (const \fBscifir::vector_unit_nd\fP & x, const \fBscifir::vector_unit_nd\fP & y)"

.PP
Comparison operator\&. Two vector_unit_nd are not equal if their value, dimensions or angles are different\&. 
.PP
Definition at line 903 of file vector_unit_nd\&.cpp\&.
.PP
.nf
904 {
905     return !(x == y);
906 }
.fi
.SS "bool operator!= (const \fBscifir::vector_unit_nd\fP & x, const string & init_vector_nd)"

.PP
Returns true if x is not equal to the vector_unit_nd initialized with the string being compared\&. The vectorial_display() function is not used, and so the values are compared with all its decimal numbers\&. 
.PP
Definition at line 914 of file vector_unit_nd\&.cpp\&.
.PP
.nf
915 {
916     return !(x == init_vector_nd);
917 }
.fi
.SS "bool operator!= (const string & init_vector_nd, const \fBscifir::vector_unit_nd\fP & x)"

.PP
Returns true if x is not equal to the vector_unit_nd initialized with the string being compared\&. The vectorial_display() function is not used, and so the values are compared with all its decimal numbers\&. 
.PP
Definition at line 925 of file vector_unit_nd\&.cpp\&.
.PP
.nf
926 {
927     return !(init_vector_nd == x);
928 }
.fi
.SS "\fBscifir::vector_unit_nd\fP operator* (const \fBscifir::scalar_unit\fP & x, const \fBscifir::vector_unit_nd\fP & y)"

.PP
It creates a new vector_unitn3d scaling a vector_unit_nd by the scalar_unit x\&. 
.PP
Definition at line 881 of file vector_unit_nd\&.cpp\&.
.PP
.nf
882 {
883     long double new_value = y\&.get_value() * x\&.get_value();
884     vector<scifir::dimension> new_dimensions = multiply_dimensions(y\&.get_dimensions(), x\&.get_dimensions(),new_value);
885     if(y\&.is_nd(1))
886     {
887         return scifir::vector_unit_nd(float(new_value), new_dimensions);
888     }
889     else if(y\&.is_nd(2))
890     {
891         return scifir::vector_unit_nd(float(new_value), new_dimensions, {y\&.angles[0]});
892     }
893     else if(y\&.is_nd(3))
894     {
895         return scifir::vector_unit_nd(float(new_value), new_dimensions, {y\&.angles[0], y\&.angles[1]});
896     }
897     else
898     {
899         return scifir::vector_unit_nd(float(new_value), new_dimensions, y\&.angles);
900     }
901 }
.fi
.SS "template<typename T , typename  = typename enable_if<scifir::is_number<T>::value>::type> \fBscifir::vector_unit_nd\fP operator* (const T y, const \fBscifir::vector_unit_nd\fP & x)"

.PP
It creates a new vector as the multiplication of the numeric type x to the value\&. The angles are not changed\&. 
.PP
Definition at line 266 of file vector_unit_nd\&.hpp\&.
.PP
.nf
267 {
268     scifir::vector_unit_nd z = x;
269     z *= y;
270     return z;
271 }
.fi
.SS "string operator+ (const \fBscifir::vector_unit_nd\fP & y, const string & x)"

.PP
Creates a new string as the concatenation of the string x with the representation string of the vector_unit_nd y\&. 
.PP
Definition at line 945 of file vector_unit_nd\&.cpp\&.
.PP
.nf
946 {
947     ostringstream output;
948     output << y;
949     output << x;
950     return output\&.str();
951 }
.fi
.SS "string operator+ (const string & x, const \fBscifir::vector_unit_nd\fP & y)"

.PP
Creates a new string as the concatenation of the string x with the representation string of the vector_unit_nd y\&. 
.PP
Definition at line 937 of file vector_unit_nd\&.cpp\&.
.PP
.nf
938 {
939     ostringstream output;
940     output << x;
941     output << y;
942     return output\&.str();
943 }
.fi
.SS "template<typename T , typename  = typename enable_if<scifir::is_number<T>::value>::type> \fBscifir::vector_unit_nd\fP operator+ (const T y, const \fBscifir::vector_unit_nd\fP & x)"

.PP
It creates a new vector as the addition of the numeric type x to the value\&. The angles are not changed\&. 
.PP
Definition at line 252 of file vector_unit_nd\&.hpp\&.
.PP
.nf
253 {
254     scifir::vector_unit_nd z = x;
255     z += y;
256     return z;
257 }
.fi
.SS "void operator+= (string & x, const \fBscifir::vector_unit_nd\fP & y)"

.PP
Concatenates the string representation of the vector_unit_nd y to the string x\&. 
.PP
Definition at line 930 of file vector_unit_nd\&.cpp\&.
.PP
.nf
931 {
932     ostringstream output;
933     output << y;
934     x += output\&.str();
935 }
.fi
.SS "template<typename T , typename  = typename enable_if<scifir::is_number<T>::value>::type> \fBscifir::vector_unit_nd\fP operator\- (const T y, const \fBscifir::vector_unit_nd\fP & x)"

.PP
It creates a new vector as the substraction of the numeric type x to the value\&. The angles are not changed\&. 
.PP
Definition at line 260 of file vector_unit_nd\&.hpp\&.
.PP
.nf
261 {
262     return scifir::vector_unit_nd(y - x\&.get_value(),x\&.get_dimensions(),x\&.angles);
263 }
.fi
.SS "template<typename T , typename  = typename enable_if<scifir::is_number<T>::value>::type> \fBscifir::vector_unit_nd\fP operator/ (const T y, const \fBscifir::vector_unit_nd\fP & x)"

.PP
It creates a new vector as the division of the value with the numeric type x\&. The angles are not changed\&. 
.PP
Definition at line 274 of file vector_unit_nd\&.hpp\&.
.PP
.nf
275 {
276     vector<scifir::dimension> new_dimensions = x\&.get_dimensions();
277     for (scifir::dimension& new_dimension : new_dimensions)
278     {
279         new_dimension\&.invert();
280     }
281     return scifir::vector_unit_nd(y / x\&.get_value(),new_dimensions,x\&.angles);
282 }
.fi
.SS "ostream& operator<< (ostream & os, const \fBscifir::vector_unit_nd\fP & x)"

.PP
Adds the string representation of the vector_unit_nd x to an output stream os\&. 
.PP
Definition at line 953 of file vector_unit_nd\&.cpp\&.
.PP
.nf
954 {
955     ostringstream angles_text;
956     if (!x\&.is_nd(1))
957     {
958         for(const auto& x_angle : x\&.angles)
959         {
960             angles_text << " ";
961             angles_text << x_angle;
962         }
963     }
964     return os << x\&.get_value() << " " << x\&.display_dimensions() << angles_text\&.str();
965 }
.fi
.SS "bool operator== (const \fBscifir::vector_unit_nd\fP & x, const string & init_vector_nd)"

.PP
Returns true if x is equal to the vector_unit_nd initialized with the string being compared\&. The vectorial_display() function is not used, and so the values are compared with all its decimal numbers\&. 
.PP
Definition at line 908 of file vector_unit_nd\&.cpp\&.
.PP
.nf
909 {
910     scifir::vector_unit_nd y(init_vector_nd);
911     return (x == y);
912 }
.fi
.SS "bool operator== (const string & init_vector_nd, const \fBscifir::vector_unit_nd\fP & x)"

.PP
Returns true if x is equal to the vector_unit_nd initialized with the string being compared\&. The vectorial_display() function is not used, and so the values are compared with all its decimal numbers\&. 
.PP
Definition at line 919 of file vector_unit_nd\&.cpp\&.
.PP
.nf
920 {
921     scifir::vector_unit_nd y(init_vector_nd);
922     return (y == x);
923 }
.fi
.SS "istream& operator>> (istream & is, \fBscifir::vector_unit_nd\fP & x)"

.PP
Allows that an istream initializes by string a vector_unit_nd x\&. 
.PP
Definition at line 967 of file vector_unit_nd\&.cpp\&.
.PP
.nf
968 {
969     char a[256];
970     is\&.getline(a, 256);
971     string b(a);
972     boost::trim(b);
973     x = scifir::vector_unit_nd(b);
974     return is;
975 }
.fi
.SH "Author"
.PP 
Generated automatically by Doxygen for scifir-units from the source code\&.
